<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>The RISC-V Advanced Interrupt Architecture :: RISC-V Ratified Specifications Library</title>
    <meta name="description" content="Advanced Interrupt Architecture">
    <meta name="generator" content="Antora 3.1.12">
    <script>
!function (theme, navWidth) {
  if (theme === 'dark') document.documentElement.classList.add('dark-theme')
  if (navWidth) document.documentElement.style.setProperty('--nav-width', `${navWidth}px`)
}(localStorage && localStorage.getItem('theme') || (matchMedia('(prefers-color-scheme: dark)')?.matches && 'dark'),
  localStorage && localStorage.getItem('nav-width'))
    </script>
    <link rel="stylesheet" href="../../_/css/site.css">
    <link rel="stylesheet" href="../../_/css/vendor/search.css">
    <link rel="stylesheet" href="../../_/css/vendor/page-search.css">
    <link rel="stylesheet" href="../../_/css/vendor/spring-tabs.css">

    <meta name="antora-ui-version" content="3f4ce2c51445edcfc62ee1f59ab97fffc218fb79"> 
    <meta name="version" content="v1.0">
    <meta name="component" content="aia">
    <meta name="latest-version" content="false">
    <link rel="icon" href="../../_/img/favicon.ico" type="image/vnd.microsoft.icon">
  </head>
  <body class="article">
<link rel="stylesheet" type="text/css" href="/styles.css">

<header class="header" id="antora-header">
    <nav class="navbar">
        <head>
            <link data-rh="true" rel="icon" href="/img/favicon.ico">
            <link data-rh="true" rel="canonical" href="https://developer.riscv.org/ref">
            <link data-rh="true" rel="alternate" href="https://developer.riscv.org/ref" hreflang="en">
            <link data-rh="true" rel="alternate" href="https://developer.riscv.org/ref" hreflang="x-default">
            <link data-rh="true" rel="preconnect" href="https://MGVPU7BN22-dsn.algolia.net" crossorigin="anonymous">
            <link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="RISC-V Developer Portal RSS Feed">
            <link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="RISC-V Developer Portal Atom Feed">

            <link rel="search" type="application/opensearchdescription+xml" title="RISC-V Developer Portal" href="/opensearch.xml">
            <link rel="stylesheet" href="/assets/css/styles.2a6e33aa.css">
            <script src="/assets/js/runtime~main.1f8bbb5b.js" defer="defer"></script>
            <script src="/assets/js/main.0e5d05c8.js" defer="defer"></script>
        </head>
        <script>
            !function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())
        </script>
            <link rel="preload" as="image" href="/img/logo.svg">
            <div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div>
            <div class="announcementBar_mb4j" role="banner">
                <div class="announcementBarPlaceholder_vyr4"></div>
                <div class="content_knG7 announcementBarContent_xLdY">congratulations, you found the RISC-V Developer Portal! ðŸŽ‰ . This site is under active development and not meant for public consumption yet.</div><button type="button" aria-label="Close" class="clean-btn close closeButton_CVFx announcementBarClose_gvF7"><svg viewBox="0 0 15 15" width="14" height="14"><g stroke="currentColor" stroke-width="3.1"><path d="M.75.75l13.5 13.5M14.25.75L.75 14.25"></path></g></svg></button></div>
            <nav aria-label="Main" class="navbar ">
                <div class="navbar__inner">
                    <div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button>
                        <a class="navbar__brand" href="/">
                            <div class="navbar__logo"><img src="/img/logo.svg" alt="RISC-V Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="RISC-V Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Home</b></a>
                        <div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Specifications</a>
                            <ul class="dropdown__menu">
                                <li><a class="dropdown__link" href="/docs/spec/isa">ISA</a></li>
                                <li><a class="dropdown__link" href="/docs/spec/profiles">Profiles</a></li>
                                <li><a class="dropdown__link" docid="spec/non-isa" href="/docs/spec/non-isa">Non-ISA</a></li>
                            </ul>
                        </div>
                        <div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Developers</a>
                            <ul class="dropdown__menu">
                                <li><a class="dropdown__link" href="/docs/spec/intro">Specification Developers</a></li>
                                <li><a class="dropdown__link" href="/docs/hardware/overview">Hardware Developers</a></li>
                                <li><a class="dropdown__link" href="/docs/software/overview">Software Developers</a></li>
                            </ul>
                        </div><a class="navbar__item navbar__link" href="/blog">Blog</a><a href="https://riscv.org/community/calendar/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Events<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></div>
                    <div class="navbar__items navbar__items--right">
                        <div class="navbarSearchContainer_Bca1"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search (Command+K)"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20" aria-hidden="true"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div>
                        <div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite" aria-pressed="false"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div>
                    </div>
                </div>
                <div role="presentation" class="navbar-sidebar__backdrop"></div>
            </nav>
            <div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper__tJE"></div>
        

    </nav>
</header><div class="body">
<div class="nav-container" data-component="aia" data-version="v1.0">
  <aside class="nav">
    <div class="panels">
      <div class="nav-panel-menu is-active" data-panel="menu">
        <nav class="nav-menu">
<div class="context">
  <span class="title">Advanced Interrupt Architecture</span>
  <span class="version">v1.0</span>
  <button class="browse-version" id="browse-version">
    <svg
      height="24px"
      id="Layer_1"
      style="enable-background:new 0 0 512 512;"
      version="1.1"
      viewBox="0 0 512 512"
      width="24px"
      xml:space="preserve"
    ><g><path
          d="M256,224c-17.7,0-32,14.3-32,32s14.3,32,32,32c17.7,0,32-14.3,32-32S273.7,224,256,224L256,224z"
        ></path><path
          d="M128.4,224c-17.7,0-32,14.3-32,32s14.3,32,32,32c17.7,0,32-14.3,32-32S146,224,128.4,224L128.4,224z"
        ></path><path
          d="M384,224c-17.7,0-32,14.3-32,32s14.3,32,32,32s32-14.3,32-32S401.7,224,384,224L384,224z"
        ></path></g></svg>
  </button>
  </div><ul class="nav-list">
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">RISC-V Advanced Interrupt Architecture</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="intro.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="CSRs.html">Control and Status Registers (CSRs) Added to Harts</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="IMSIC.html">Incoming MSI Controller (IMSIC)</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="AdvPLIC.html">Advanced Platform-Level Interrupt Controller (APLIC)</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="MSLevel.html">Interrupts for Machine and Supervisor Levels</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="VSLevel.html">Interrupts for Virtual Machines (VS Level)</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="IPIs.html">Interprocessor Interrupts (IPIs)</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="IOMMU.html">IOMMU Support for MSIs to Virtual Machines</a>
  </li>
</ul>
  </li>
</ul>
          <div class="toggle-sm">
            <button id="nav-toggle-2" class="nav-toggle"></button>
          </div>
        </nav>
      </div>
      <div class="nav-collapse">
        <button id="nav-collapse-toggle"><span></span></button>        
      </div>
    </div>
    <div class="nav-resize"></div>
  </aside>
</div>
<script>
!function (sidebar) {
  if (sidebar) {
    document.body.classList.add('nav-sm')
  }
}(localStorage && localStorage.getItem('sidebar') === 'close')
</script><main class="article">
<div class="toolbar" role="navigation">
  <button id="nav-toggle-1" class="nav-toggle"></button>
</div>
  <div class="content">
<aside class="sidebar">
  <div class="content">
    <div
      class="toc"
      data-title="The RISC-V Advanced Interrupt Architecture"
      data-levels="2"
    >
      <div class="toc-menu"></div>
    </div>
    <div class="sidebar-links">
        <a href="https://github.com/riscv/riscv-aia/edit/antora-refactor/modules/ROOT/pages/riscv-interrupts.adoc">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            height="24"
            viewBox="0 0 24 24"
            width="24"
          ><path
              d="m16 2.012 3 3L16.713 7.3l-3-3zM4 14v3h3l8.299-8.287-3-3zm0 6h16v2H4z"
            ></path></svg>
          Edit this Page
        </a>
              <a href="https://github.com/riscv/riscv-aia" title="GitHub">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            height="512px"
            id="Layer_1"
            version="1.1"
            viewBox="0 0 512 512"
            width="512px"
          ><style type="text/css"><
              .st0{fill-rule:evenodd;clip-rule:evenodd;} ]]></style><g><path
                class="st0"
                d="M256,32C132.3,32,32,134.8,32,261.7c0,101.5,64.2,187.5,153.2,217.9c11.2,2.1,15.3-5,15.3-11.1   c0-5.5-0.2-19.9-0.3-39.1c-62.3,13.9-75.5-30.8-75.5-30.8c-10.2-26.5-24.9-33.6-24.9-33.6c-20.3-14.3,1.5-14,1.5-14   c22.5,1.6,34.3,23.7,34.3,23.7c20,35.1,52.4,25,65.2,19.1c2-14.8,7.8-25,14.2-30.7c-49.7-5.8-102-25.5-102-113.5   c0-25.1,8.7-45.6,23-61.6c-2.3-5.8-10-29.2,2.2-60.8c0,0,18.8-6.2,61.6,23.5c17.9-5.1,37-7.6,56.1-7.7c19,0.1,38.2,2.6,56.1,7.7   c42.8-29.7,61.5-23.5,61.5-23.5c12.2,31.6,4.5,55,2.2,60.8c14.3,16.1,23,36.6,23,61.6c0,88.2-52.4,107.6-102.3,113.3   c8,7.1,15.2,21.1,15.2,42.5c0,30.7-0.3,55.5-0.3,63c0,6.1,4,13.3,15.4,11C415.9,449.1,480,363.1,480,261.7   C480,134.8,379.7,32,256,32z"
              ></path></g></svg>
          GitHub Project
        </a>

      <a href="" title="PDF">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            height="512px"
            id="Layer_1"
            version="1.1"
            viewBox="0 0 512 512"
            width="512px"
          ><style type="text/css"><
              .st0{fill-rule:evenodd;clip-rule:evenodd;} ]]></style><g><path
                class="st0"
                d="M256,32C132.3,32,32,134.8,32,261.7c0,101.5,64.2,187.5,153.2,217.9c11.2,2.1,15.3-5,15.3-11.1   c0-5.5-0.2-19.9-0.3-39.1c-62.3,13.9-75.5-30.8-75.5-30.8c-10.2-26.5-24.9-33.6-24.9-33.6c-20.3-14.3,1.5-14,1.5-14   c22.5,1.6,34.3,23.7,34.3,23.7c20,35.1,52.4,25,65.2,19.1c2-14.8,7.8-25,14.2-30.7c-49.7-5.8-102-25.5-102-113.5   c0-25.1,8.7-45.6,23-61.6c-2.3-5.8-10-29.2,2.2-60.8c0,0,18.8-6.2,61.6,23.5c17.9-5.1,37-7.6,56.1-7.7c19,0.1,38.2,2.6,56.1,7.7   c42.8-29.7,61.5-23.5,61.5-23.5c12.2,31.6,4.5,55,2.2,60.8c14.3,16.1,23,36.6,23,61.6c0,88.2-52.4,107.6-102.3,113.3   c8,7.1,15.2,21.1,15.2,42.5c0,30.7-0.3,55.5-0.3,63c0,6.1,4,13.3,15.4,11C415.9,449.1,480,363.1,480,261.7   C480,134.8,379.7,32,256,32z"
              ></path></g></svg>
          Download PDF
        </a>
    </div>
  </div>
</aside>
<article class="doc">
<div class="breadcrumbs-container">
  <nav class="breadcrumbs" aria-label="breadcrumbs">
    <ul>
      <li><a href="index.html">Advanced Interrupt Architecture</a></li>
      <li><a href="riscv-interrupts.html">The RISC-V Advanced Interrupt Architecture</a></li>
    </ul>
  </nav>
</div><h1 id="page-title" class="page">The RISC-V Advanced Interrupt Architecture</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Contributors to all versions of this specification in alphabetical order
(please contact the editor to suggest corrections): Krste AsanoviÄ‡, Paul
Donahue, Greg Favor, John Hauser, James Kenney, David Kruckemyer, Shubu
Mukherjee, Stefan Oâ€™Rear, Vernon Pang, Anup Patel, Josh Scheid, Ved
Shanbhogue, and Andrew Waterman.</p>
</div>
<div class="paragraph">
<p>This document is released under a Creative Commons Attribution 4.0
International License.</p>
</div>
<div style="page-break-after: always;"></div>
<div class="paragraph">
<p>This document describes an Advanced Interrupt Architecture (AIA) for RISC-V
systems. This specification was ratified by the RISC-V International
Association in June of 2023.</p>
</div>
<div class="paragraph">
<p>The table below indicates which chapters of this document specify
extensions to the RISC-V ISA (instruction set architecture) and which
are non-ISA.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Chapter</th>
<th class="tableblock halign-center valign-top">ISA?</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.Â Introduction</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â€”</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.Â Control and Status Registers (CSRs) Added to Harts</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3.Â Incoming MSI Controller (IMSIC)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">4.Â Advanced Platform-Level Interrupt Controller (APLIC)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5.Â Interrupts for Machine and Supervisor Levels</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">6.Â Interrupts for Virtual Machines (VS Level)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">7.Â Interprocessor Interrupts (IPIs)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">8.Â IOMMU Support for MSIs to Virtual Machines</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Changes for version 20250312</strong></p>
</div>
<div class="paragraph">
<p>Made the following clarifications to AIA 1.0:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Where there are irreconcilable conflicts between the AIA and other
implemented RISC-V extensions, the AIA usually has priority by default.</p>
</li>
<li>
<p>Deference is given to extension
Smcsrind/Sscsrind (indirectly accessed CSRs).</p>
</li>
<li>
<p>Names are given to the bits defined in <code>mstateen0</code> and <code>hstateen0</code>
when extension Smstateen/Ssstateen is also implemented.</p>
</li>
<li>
<p>An IMSIC interrupt file&#8217;s <code>eidelivery</code> register affects only
whether an interrupt appears in a hart&#8217;s <code>mip</code> or <code>hgeip</code> register.</p>
</li>
<li>
<p>IMSIC CSRs <code>mtopei</code>, <code>stopei</code>, and <code>vstopei</code> are not affected
by the values of <code>mie</code>, <code>sie</code>, <code>hie</code>, <code>hgeie</code>, or <code>vsie</code>.</p>
</li>
<li>
<p>There may be a visible delay between a change of state of an IMSIC
interrupt file and its effect on a bit in <code>mip</code>, <code>sip</code>, or <code>hgeip</code>.</p>
</li>
<li>
<p>An APLIC&#8217;s <code>idelivery</code> registers and
the IE bits of its <code>domaincfg</code> registers affect only whether
pending-and-enabled interrupts are delivered to harts.</p>
</li>
<li>
<p>The default priority order for major interrupts is applicable
only when multiple interrupts would trap to the same privilege mode.</p>
</li>
<li>
<p>The example pseudocode given for handling major interrupts at M-level
and S-level has additional requirements not mentioned previously.</p>
</li>
<li>
<p>An interrupt priority number in the S-level <code>iprio</code> array
may be writable (not read-only zero) if
the correponding bit is writable in either <code>sie</code> or <code>hie</code>.</p>
</li>
<li>
<p>If a supervisor external interrupt (SEI) is injected from M-level
when there is no actual interrupt from an external interrupt controller,
the injected SEI is assigned an S-level priority number of 256.</p>
</li>
<li>
<p>CSR <code>hvictl</code> affects only <code>vstopi</code> and the trapping of
some instructions, not <code>mip</code>, <code>sip</code>, <code>hip</code>, or <code>vsip</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Changes for the ratified version 1.0</strong></p>
</div>
<div class="paragraph">
<p>Resolved some inconsistencies in <a href="#CSRs">Chapter 2</a> about when to raise
a virtual instruction exception versus an illegal instruction exception.</p>
</div>
<div class="paragraph">
<p><strong>Changes for RC5 (Release Candidate 5)</strong></p>
</div>
<div class="paragraph">
<p>Better aligned the rules for indirectly accessed registers with the
hypervisor extension and with forthcoming extension Smcsrind/Sscsrind.
In particular, when <code>vsiselect</code> has a reserved value, attempts to
access <code>sireg</code> from a virtual machine (VS or VU-mode) should
preferably raise an illegal instruction exception instead of a virtual
instruction exception.</p>
</div>
<div class="paragraph">
<p>Added clarification about the term <em>IOMMU</em> used in <a href="#IOMMU">Chapter 8</a>.</p>
</div>
<div class="paragraph">
<p>Added clarification about MSI write replaced by MRIF update and notice
MSI sent after the update.</p>
</div>
<div class="paragraph">
<p><strong>Changes for RC4</strong></p>
</div>
<div class="paragraph">
<p>For alignment with other forthcoming RISC-V ISA extensions, the widths
of the indirect-access CSRs, <code>miselect</code>, <code>mireg</code>, <code>siselect</code>,
<code>sireg</code>, <code>vsiselect</code>, and <code>vsireg</code>, were changed to all be the
current XLEN rather than being tied to their respective privilege levels
(previously MXLEN for <code>miselect</code> and <code>mireg</code>, SXLEN for <code>siselect</code>
and <code>sireg</code>, and VSXLEN for <code>vsiselect</code> and <code>vsireg</code>).</p>
</div>
<div class="paragraph">
<p>Changed the description (but not the actual function) of <em>high-half</em>
CSRs and their partner CSRs to match the latest RISC-V Privileged ISA
specification. (An example of a high-half CSR is <code>miph</code>, and its
partner here is <code>mip</code>.)</p>
</div>
<div class="paragraph">
<p><strong>Changes for RC3</strong></p>
</div>
<div class="paragraph">
<p>Removed the still-draft Duo-PLIC chapter to a separate document.</p>
</div>
<div class="paragraph">
<p>Allocated major interrupts 35 and 43 for signaling RAS events
(<a href="#majorIntrs">Section 5.1</a>).</p>
</div>
<div class="paragraph">
<p>In <a href="#virtIntrs-S">Section 5.3</a> added the options for bits 1 and 9 to
be writable in CSR <code>mvien</code>, and specified the effects of setting each
of these bits.</p>
</div>
<div class="paragraph">
<p>Upgraded <a href="#IOMMU">Chapter 8</a> ("IOMMU Support") to the <em>frozen</em> state.</p>
</div>
<div class="paragraph">
<p><strong>Changes for RC2</strong></p>
</div>
<div class="paragraph">
<p>Clarified that field IID of CSR <code>hvictl</code> must support all unsigned
integer values of the number of bits implemented for that field, and
that writes to <code>hvictl</code> always set IID in the most straightforward
way.</p>
</div>
<div class="paragraph">
<p>A comment was added to <a href="#IPIs">Chapter 7</a> warning about the possible
need for FENCE instructions when IPIs are sent to other harts by writing
MSIs to those harts' IMSICs.</p>
</div>
</div>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#ch:intro">1. Introduction</a>
<ul class="sectlevel2">
<li><a href="#goals">1.1. Goals</a></li>
<li><a href="#limits">1.2. Limits</a></li>
<li><a href="#overview-of-main-components">1.3. Overview of main components</a>
<ul class="sectlevel3">
<li><a href="#external-interrupts-without-imsics">1.3.1. External interrupts without IMSICs</a></li>
<li><a href="#external-interrupts-with-imsics">1.3.2. External interrupts with IMSICs</a></li>
<li><a href="#other-interrupts">1.3.3. Other interrupts</a></li>
</ul>
</li>
<li><a href="#interrupt-identities-at-a-hart">1.4. Interrupt identities at a hart</a></li>
<li><a href="#selection-of-harts-to-receive-an-interrupt">1.5. Selection of harts to receive an interrupt</a></li>
<li><a href="#isa-extensions-smaia-and-ssaia">1.6. ISA extensions Smaia and Ssaia</a></li>
</ul>
</li>
<li><a href="#CSRs">2. Control and Status Registers (CSRs) Added to Harts</a>
<ul class="sectlevel2">
<li><a href="#machine-level-csrs">2.1. Machine-level CSRs</a></li>
<li><a href="#supervisor-level-csrs">2.2. Supervisor-level CSRs</a></li>
<li><a href="#hypervisor-vs-csrs">2.3. Hypervisor and VS CSRs</a></li>
<li><a href="#virtual-instruction-exceptions">2.4. Virtual instruction exceptions</a></li>
<li><a href="#CSRs-stateen">2.5. Access control by the state-enable CSRs</a></li>
</ul>
</li>
<li><a href="#IMSIC">3. Incoming MSI Controller (IMSIC)</a>
<ul class="sectlevel2">
<li><a href="#IMSIC-intrFilesAndIdents">3.1. Interrupt files and interrupt identities</a></li>
<li><a href="#MSIEncoding">3.2. MSI encoding</a></li>
<li><a href="#interrupt-priorities">3.3. Interrupt priorities</a></li>
<li><a href="#reset-and-revealed-state">3.4. Reset and revealed state</a></li>
<li><a href="#IMSIC-memRegion">3.5. Memory region for an interrupt file</a></li>
<li><a href="#IMSIC-systemMemRegions">3.6. Arrangement of the memory regions of multiple interrupt files</a></li>
<li><a href="#csrs-for-external-interrupts-via-an-imsic">3.7. CSRs for external interrupts via an IMSIC</a></li>
<li><a href="#indirectly-accessed-interrupt-file-registers">3.8. Indirectly accessed interrupt-file registers</a>
<ul class="sectlevel3">
<li><a href="#IMSIC-reg-eidelivery">3.8.1. External interrupt delivery enable register (<code>eidelivery</code>)</a></li>
<li><a href="#external-interrupt-enable-threshold-register-eithreshold">3.8.2. External interrupt enable threshold register (<code>eithreshold</code>)</a></li>
<li><a href="#external-interrupt-pending-registers-eip0-eip63">3.8.3. External interrupt-pending registers (<code>eip0</code>-<code>eip63</code>)</a></li>
<li><a href="#external-interrupt-enable-registers-eie0-eie63">3.8.4. External interrupt-enable registers (<code>eie0</code>-<code>eie63</code>)</a></li>
</ul>
</li>
<li><a href="#top-external-interrupt-csrs-mtopei-stopei-vstopei">3.9. Top external interrupt CSRs (<code>mtopei</code>, <code>stopei</code>, <code>vstopei</code>)</a></li>
<li><a href="#interrupt-delivery-and-handling">3.10. Interrupt delivery and handling</a></li>
</ul>
</li>
<li><a href="#AdvPLIC">4. Advanced Platform-Level Interrupt Controller (APLIC)</a>
<ul class="sectlevel2">
<li><a href="#interrupt-sources-and-identities">4.1. Interrupt sources and identities</a></li>
<li><a href="#interrupt-domains">4.2. Interrupt domains</a></li>
<li><a href="#hart-index-numbers">4.3. Hart index numbers</a></li>
<li><a href="#overview-of-interrupt-control-for-a-single-domain">4.4. Overview of interrupt control for a single domain</a></li>
<li><a href="#AdvPLIC-domainControlRegion">4.5. Memory-mapped control region for an interrupt domain</a>
<ul class="sectlevel3">
<li><a href="#AdvPLIC-reg-domaincfg">4.5.1. Domain configuration (<code>domaincfg</code>)</a></li>
<li><a href="#AdvPLIC-reg-sourcecfg">4.5.2. Source configurations (<code>sourcecfg[1]â€“sourcecfg[1023]</code>)</a></li>
<li><a href="#AdvPLIC-reg-mmsiaddrcfg">4.5.3. Machine MSI address configuration (<code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code>)</a></li>
<li><a href="#AdvPLIC-reg-smsiaddrcfg">4.5.4. Supervisor MSI address configuration (<code>smsiaddrcfg</code> and <code>smsiaddrcfgh</code>)</a></li>
<li><a href="#set-interrupt-pending-bits-setip0-setip31">4.5.5. Set interrupt-pending bits (<code>setip[0]</code>-<code>setip[31]</code>)</a></li>
<li><a href="#set-interrupt-pending-bit-by-number-setipnum">4.5.6. Set interrupt-pending bit by number (<code>setipnum</code>)</a></li>
<li><a href="#rectified-inputs-clear-interrupt-pending-bits-in_clrip0-in_clrip31">4.5.7. Rectified inputs, clear interrupt-pending bits (<code>in_clrip[0]</code>-<code>in_clrip[31]</code>)</a></li>
<li><a href="#clear-interrupt-pending-bit-by-number-clripnum">4.5.8. Clear interrupt-pending bit by number (<code>clripnum</code>)</a></li>
<li><a href="#set-interrupt-enable-bits-setie0-setie31">4.5.9. Set interrupt-enable bits (<code>setie[0]</code>-<code>setie[31]</code>)</a></li>
<li><a href="#set-interrupt-enable-bit-by-number-setienum">4.5.10. Set interrupt-enable bit by number (<code>setienum</code>)</a></li>
<li><a href="#clear-interrupt-enable-bits-clrie0-clrie31">4.5.11. Clear interrupt-enable bits (<code>clrie[0]</code>-<code>clrie[31]</code>)</a></li>
<li><a href="#clear-interrupt-enable-bit-by-number-clrienum">4.5.12. Clear interrupt-enable bit by number (<code>clrienum</code>)</a></li>
<li><a href="#set-interrupt-pending-bit-by-number-little-endian-setipnum_le">4.5.13. Set interrupt-pending bit by number, little-endian (<code>setipnum_le</code>)</a></li>
<li><a href="#set-interrupt-pending-bit-by-number-big-endian-setipnum_be">4.5.14. Set interrupt-pending bit by number, big-endian (<code>setipnum_be</code>)</a></li>
<li><a href="#AdvPLIC-reg-genmsi">4.5.15. Generate MSI (<code>genmsi</code>)</a></li>
<li><a href="#AdvPLIC-reg-target">4.5.16. Interrupt targets (<code>target[1]-target[1023]</code>)</a>
<ul class="sectlevel4">
<li><a href="#active-source-direct-delivery-mode">4.5.16.1. Active source, direct delivery mode</a></li>
<li><a href="#active-source-msi-delivery-mode">4.5.16.2. Active source, MSI delivery mode</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#reset">4.6. Reset</a></li>
<li><a href="#AdvPLIC-pendingBits">4.7. Precise effects on interrupt-pending bits</a></li>
<li><a href="#AdvPLIC-directMode">4.8. Interrupt delivery directly by the APLIC</a>
<ul class="sectlevel3">
<li><a href="#AdvPLIC-IDC">4.8.1. Interrupt delivery control (IDC) structure</a>
<ul class="sectlevel4">
<li><a href="#interrupt-delivery-enable-idelivery">4.8.1.1. Interrupt delivery enable (<code>idelivery</code>)</a></li>
<li><a href="#interrupt-force-iforce">4.8.1.2. Interrupt force (<code>iforce</code>)</a></li>
<li><a href="#interrupt-enable-threshold-ithreshold">4.8.1.3. Interrupt enable threshold (<code>ithreshold</code>)</a></li>
<li><a href="#top-interrupt-topi">4.8.1.4. Top interrupt (<code>topi</code>)</a></li>
<li><a href="#claim-top-interrupt-claimi">4.8.1.5. Claim top interrupt (<code>claimi</code>)</a></li>
</ul>
</li>
<li><a href="#AdvPLIC-directMode-intrDelivery">4.8.2. Interrupt delivery and handling</a></li>
</ul>
</li>
<li><a href="#interrupt-forwarding-by-msis">4.9. Interrupt forwarding by MSIs</a>
<ul class="sectlevel3">
<li><a href="#AdvPLIC-MSIAddrs">4.9.1. Addresses and data for outgoing MSIs</a></li>
<li><a href="#special-consideration-for-level-sensitive-interrupt-sources">4.9.2. Special consideration for level-sensitive interrupt sources</a></li>
<li><a href="#AdvPLIC-MSISync">4.9.3. Synchronizing interactions between a hart and the APLIC</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#MSLevel">5. Interrupts for Machine and Supervisor Levels</a>
<ul class="sectlevel2">
<li><a href="#majorIntrs">5.1. Defined major interrupts and default priorities</a></li>
<li><a href="#interrupts-at-machine-level">5.2. Interrupts at machine level</a>
<ul class="sectlevel3">
<li><a href="#intrPrios-M">5.2.1. Configuring priorities of major interrupts at machine level</a></li>
<li><a href="#mtopi">5.2.2. Machine top interrupt CSR (<code>mtopi</code>)</a></li>
</ul>
</li>
<li><a href="#virtIntrs-S">5.3. Interrupt filtering and virtual interrupts for supervisor level</a></li>
<li><a href="#intrs-S">5.4. Interrupts at supervisor level</a>
<ul class="sectlevel3">
<li><a href="#intrPrios-S">5.4.1. Configuring priorities of major interrupts at supervisor level</a></li>
<li><a href="#stopi">5.4.2. Supervisor top interrupt CSR (<code>stopi</code>)</a></li>
</ul>
</li>
<li><a href="#wfi-wait-for-interrupt-instruction">5.5. WFI (Wait for Interrupt) instruction</a></li>
</ul>
</li>
<li><a href="#VSLevel">6. Interrupts for Virtual Machines (VS Level)</a>
<ul class="sectlevel2">
<li><a href="#vs-level-external-interrupts-with-a-guest-interrupt-file">6.1. VS-level external interrupts with a guest interrupt file</a>
<ul class="sectlevel3">
<li><a href="#direct-control-of-a-device-by-a-guest-os">6.1.1. Direct control of a device by a guest OS</a></li>
<li><a href="#virtHartMigration">6.1.2. Migrating a virtual hart to a different guest interrupt file</a></li>
</ul>
</li>
<li><a href="#vs-level-external-interrupts-without-a-guest-interrupt-file">6.2. VS-level external interrupts without a guest interrupt file</a></li>
<li><a href="#interrupts-at-vs-level">6.3. Interrupts at VS level</a>
<ul class="sectlevel3">
<li><a href="#configuring-priorities-of-major-interrupts-at-vs-level">6.3.1. Configuring priorities of major interrupts at VS level</a></li>
<li><a href="#virtual-interrupts-for-vs-level">6.3.2. Virtual interrupts for VS level</a></li>
<li><a href="#vstopi">6.3.3. Virtual supervisor top interrupt CSR (<code>vstopi</code>)</a></li>
<li><a href="#interrupt-traps-to-vs-mode">6.3.4. Interrupt traps to VS-mode</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#IPIs">7. Interprocessor Interrupts (IPIs)</a></li>
<li><a href="#IOMMU">8. IOMMU Support for MSIs to Virtual Machines</a>
<ul class="sectlevel2">
<li><a href="#IOMMU-deviceContexts">8.1. Device contexts at an IOMMU</a></li>
<li><a href="#translation-of-addresses-for-msis-from-devices">8.2. Translation of addresses for MSIs from devices</a></li>
<li><a href="#IOMMU-MRIFs">8.3. Memory-resident interrupt files</a>
<ul class="sectlevel3">
<li><a href="#IOMMU-MRIFFormat">8.3.1. Format of a memory-resident interrupt file</a></li>
<li><a href="#recording-of-incoming-msis-to-memory-resident-interrupt-files">8.3.2. Recording of incoming MSIs to memory-resident interrupt files</a></li>
<li><a href="#use-of-memory-resident-interrupt-files-with-atomic-update">8.3.3. Use of memory-resident interrupt files with atomic update</a></li>
<li><a href="#use-of-memory-resident-interrupt-files-without-atomic-update">8.3.4. Use of memory-resident interrupt files without atomic update</a></li>
<li><a href="#allocation-of-guest-interrupt-files-for-receiving-notice-msis">8.3.5. Allocation of guest interrupt files for receiving notice MSIs</a></li>
</ul>
</li>
<li><a href="#IOMMU-identIncomingMSIs">8.4. Identification of page addresses of a VM&#8217;s interrupt files</a></li>
<li><a href="#msi-page-tables">8.5. MSI page tables</a>
<ul class="sectlevel3">
<li><a href="#msi-pte-basic-translate-mode">8.5.1. MSI PTE, basic translate mode</a></li>
<li><a href="#IOMMU-MSIPTE-MRIF">8.5.2. MSI PTE, MRIF mode</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="sect1">
<h2 id="ch:intro"><a class="anchor" href="#ch:intro"></a>1. Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This document specifies the Advanced Interrupt Architecture for RISC-V,
consisting of: (a)Â an extension to the standard RISC-V Privileged Architecture;
(b)Â two
standard interrupt controllers for RISC-V systems, an Advanced Platform-Level
Interrupt Controller (APLIC) and an Incoming Message-Signaled Interrupt
Controller (IMSIC); and (c)Â requirements on other system components
concerning interrupts.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Commentary on our design decisions, implementation options, and
application is formatted as in this paragraph, and can be skipped if the
reader is only interested in the specification itself.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="goals"><a class="anchor" href="#goals"></a>1.1. Goals</h3>
<div class="paragraph">
<p>The RISC-V Advanced Interrupt Architecture has these goals:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Build upon the interrupt-handling functionality of the RISC-V Privileged
Architecture, minimizing the replacement of existing functionality.</p>
</li>
<li>
<p>Provide facilities for RISC-V systems to work directly with message-signaled
interrupts (MSIs) as employed by PCI Express and other device standards,
in addition to basic wired interrupts.</p>
</li>
<li>
<p>For wired interrupts, define a new Platform-Level Interrupt Controller
(the Advanced PLIC, or APLIC) that has an independent control interface
for each level of privilege (such as RISC-V machine and supervisor levels), and
that can convert wired interrupts into MSIs for systems supporting MSIs.</p>
</li>
<li>
<p>Expand the framework for local interrupts at a RISC-V hart.</p>
</li>
<li>
<p>Optionally allow software to configure the relative priorities of all
sources of interrupts to a RISC-V hart (including the standard timer and
software interrupts, among others), instead of being limited just to the
ability of a separate interrupt controller to prioritize external
interrupts only.</p>
</li>
<li>
<p>When harts implement the Privileged Architectureâ€™s H
extension, provide sufficient assistance for virtualizing these same
interrupt facilities for virtual machines.</p>
</li>
<li>
<p>With the help of an IOMMU (I/O memory management unit) for redirecting
MSIs, maximize the opportunities and ability for a guest operating
system running in a virtual machine to have direct control of devices
with minimal involvement of a hypervisor.</p>
</li>
<li>
<p>Avoid having the interrupt hardware be a limiter on the number of
virtual machines.</p>
</li>
<li>
<p>Achieve all of the above with the best possible compromises between
speed, efficiency, and flexibility of implementation.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This initial version of the Advanced Interrupt Architecture is focused
primarily on the needs of larger, high-performance RISC-V systems. Support is
not currently defined for the following interrupt-handling features that
are useful for minimizing interrupt response times in so-called
"real-time" systems but are less appropriate for high-speed processor
cores:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the option to give each interrupt source at a hart a separate trap entry
address;</p>
</li>
<li>
<p>automatic stacking of register values on interrupt trap entry, and
restoration on exit; and</p>
</li>
<li>
<p>automatic preemption (nesting) of interrupts at a hart, based on
priority.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It is intended that such features optimizing for smaller and/or
real-time systems can be developed as a follow-on extension, either
separately or as part of a future version of the interrupt architecture
of this document.</p>
</div>
</div>
<div class="sect2">
<h3 id="limits"><a class="anchor" href="#limits"></a>1.2. Limits</h3>
<div class="paragraph">
<p>In its current version, the RISC-V Advanced Interrupt Architecture can support RISC-V
symmetric multiprocessing (SMP) systems with up to 16,384 harts. If the
harts are 64-bit (RV64) and implement the H extension, and if
all features of the Advanced Interrupt Architecture are fully
implemented as well, then for each physical hart there may be up to 63
active virtual harts and potentially thousands of additional idle
(swapped-out) virtual harts, where each virtual hart has direct control
of one or more physical devices.</p>
</div>
<div class="paragraph">
<p><a href="#overalllimits">Table 1</a> summarizes the main limits
on the numbers of harts, both physical and virtual, and the numbers of
distinct interrupt identities that may be supported with the Advanced
Interrupt Architecture.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>We assume that any single RISC-V computer (or any single node in a cluster or
distributed system) with many thousands of physical harts will probably
need an interrupt infrastructure adapted to the machineâ€™s specific
organization, which we do not attempt to predict.</p>
</div>
</td>
</tr>
</table>
</div>
<table id="overalllimits" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 1. Absolute limits on the numbers of harts and interrupt identities in a system.  Individual implementations are likely to have smaller limits.</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-center valign-top">Maximum</th>
<th class="tableblock halign-left valign-top">Requirements</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Physical harts</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">16,384</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Active virtual harts having direct control of a device, per physical hart</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">31 for RV32, 63 for RV64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RISC-V H extension; IMSICs with guest interrupt files; and an IOMMU</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Idle (swapped-out) virtual harts having direct control of a device, per physical hart</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">potentially thousands</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An IOMMU with support for memory-resident interrupt files</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Wired interrupts at a single APLIC</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1023</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Distinct identities usable for MSIs at each hart (physical or virtual)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2047</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IMSICs</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="overview-of-main-components"><a class="anchor" href="#overview-of-main-components"></a>1.3. Overview of main components</h3>
<div class="paragraph">
<p>A RISC-V system&#8217;s overall architecture for signaling interrupts depends on
whether it is built mainly for message-signaled interrupts (MSIs) or for
more traditional wired interrupts. In systems with full support for
MSIs, every hart has an <em>Incoming MSI Controller</em> (IMSIC) that serves as
the hart&#8217;s own private interrupt controller for external interrupts.
Conversely, in systems based primarily on traditional wired interrupts,
harts do not have IMSICs. Larger systems, and especially those with PCI
devices, are expected to fully support MSIs by giving harts IMSICs,
whereas many smaller systems may continue to be best served with wired
interrupts and simpler harts without IMSICs.</p>
</div>
<div class="sect3">
<h4 id="external-interrupts-without-imsics"><a class="anchor" href="#external-interrupts-without-imsics"></a>1.3.1. External interrupts without IMSICs</h4>
<div class="paragraph">
<p>When RISC-V harts do not have Incoming MSI Controllers, external interrupts are
signaled to harts through dedicated wires. In that case, an <em>Advanced
Platform-Level Interrupt Controller</em> (APLIC) acts as a traditional
central hub for interrupts, routing and prioritizing external interrupts
for each hart as illustrated in <a href="#intrsWithoutIMSICs">Figure 1</a>.
Interrupts may be selectively routed either to machine level or to
supervisor level at each hart. The APLIC is specified in
<a href="#AdvPLIC">Chapter 4</a>.</p>
</div>
<div class="paragraph">
<p>Without IMSICs, the current Advanced Interrupt Architecture does not
support the direct signaling of external interrupts to virtual machines,
even when RISC-V harts implement the H
extension. Instead, an interrupt must be sent to the relevant
hypervisor, which can then choose to inject a virtual interrupt into the
virtual machine.</p>
</div>
<div id="intrsWithoutIMSICs" class="imageblock unresolved">
<div class="content">
<img src="intrsWithoutIMSICs.png" alt="intrsWithoutIMSICs">
</div>
<div class="title">Figure 1. Traditional delivery of wired interrupts to harts without support for MSIs.</div>
</div>
<div id="intrsWithIMSICs" class="imageblock unresolved">
<div class="content">
<img src="intrsWithIMSICs.png" alt="intrsWithIMSICs">
</div>
<div class="title">Figure 2. Interrupt delivery by MSIs when harts have IMSICs for receiving them.</div>
</div>
</div>
<div class="sect3">
<h4 id="external-interrupts-with-imsics"><a class="anchor" href="#external-interrupts-with-imsics"></a>1.3.2. External interrupts with IMSICs</h4>
<div class="paragraph">
<p>To be able to receive message-signaled interrupts (MSIs), each RISC-V hart must
have an Incoming MSI Controller (IMSIC) as shown in <a href="#intrsWithIMSICs">Figure 2</a>. Fundamentally, a message-signaled interrupt is simply a memory write to a specific address that hardware accepts as indicating an interrupt. To that end, every IMSIC is assigned one or more distinct addresses in the machine&#8217;s address space, and when a write is made to one of those addresses in the expected format, the receiving IMSIC interprets the write as an external interrupt for the respective hart.</p>
</div>
<div class="paragraph">
<p>Because all IMSICs have unique addresses in the machine&#8217;s physical
address space, every IMSIC can receive MSI writes from any agent (hart
or device) with permission to write to it. IMSICs have separate
addresses for MSIs directed to machine and supervisor levels, in part so
the ability to signal interrupts at each privilege level can be
separately granted or denied by controlling write permissions at the
different addresses, and in part to better support virtualizability
(pretending that one privilege level is a higher level). MSIs intended
for a hart at a specific privilege level are recorded within the IMSIC
in an <em>interrupt file</em>, which consists mainly of an array of
interrupt-pending bits and a matching array of interrupt-enable bits,
the latter indicating which individual interrupts the hart is currently
prepared to receive.</p>
</div>
<div class="paragraph">
<p>IMSIC units are fully defined in <a href="#IMSIC">Chapter 3</a>. The
format of MSIs used by the RISC-V Advanced Interrupt Architecture is described
in that chapter, <a href="#MSIEncoding">Section 3.2</a>.</p>
</div>
<div class="paragraph">
<p>When the harts in a RISC-V system have IMSICs, the system will normally still
contain an APLIC, but its role is changed. Instead of signaling
interrupts to harts directly by wires as in <a href="#intrsWithoutIMSICs">Figure 1</a>, an APLIC converts incoming wired interrupts into MSI writes that are sent to harts via their IMSIC units. Each MSI is sent to a single target hart according to the APLIC&#8217;s configuration set by software.</p>
</div>
<div class="paragraph">
<p>If RISC-V harts implement the H extension,
IMSICs may have additional <em>guest interrupt files</em> for delivering
interrupts to virtual machines. Besides <a href="#IMSIC">Chapter 3</a> on
the IMSIC, see <a href="#VSLevel">Chapter 6</a> which specifically
covers interrupts to virtual machines. If the system also contains an
IOMMU to perform address translation of memory accesses made by I/O
devices, then MSIs from those same devices may require special handling.
This topic is addressed in <a href="#IOMMU">Chapter 8</a>, "IOMMU Support for MSIs to Virtual Machines."</p>
</div>
</div>
<div class="sect3">
<h4 id="other-interrupts"><a class="anchor" href="#other-interrupts"></a>1.3.3. Other interrupts</h4>
<div class="paragraph">
<p>In addition to external interrupts from I/O devices, the RISC-V Privileged
Architecture specifies a few other major classes of interrupts for
harts. The Privileged Architecture&#8217;s timer interrupts remain supported
in full, and software interrupts remain at least partly supported,
although neither appears in <a href="#intrsWithoutIMSICs">Figure 1</a>
and <a href="#intrsWithIMSICs">Figure 2</a>. For the specifics on software interrupts,
refer to <a href="#IPIs">Chapter 7</a>, "Interprocessor Interrupts (IPIs).""</p>
</div>
<div class="paragraph">
<p>The Advanced Interrupt Architecture adds considerable support for <em>local
interrupts</em> at a hart, whereby a hart essentially interrupts itself in
response to asynchronous events, usually errors. Local interrupts remain
contained within a hart (or close to it), so like standard RISC-V timer and
software interrupts, they do not pass through an APLIC or IMSIC.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="interrupt-identities-at-a-hart"><a class="anchor" href="#interrupt-identities-at-a-hart"></a>1.4. Interrupt identities at a hart</h3>
<div class="paragraph">
<p>The RISC-V Privileged Architecture gives every interrupt cause at a hart a
distinct <em>major identity number</em>, which is the Exception Code
automatically written to CSR <code>mcause</code> or <code>scause</code> on an interrupt trap. Interrupt causes
that are standardized by the base Privileged Architecture have major
identities in the range 0-15, while numbers 16 and higher are officially
available for platform standards or for custom use. The Advanced
Interrupt Architecture claims further authority over identity numbers in
the ranges 16-23 and 32-47, leaving numbers in the range 24-31 and all
major identities 48 and higher still free for custom use.
<a href="#interruptIdents">Table 2</a> characterizes all
major interrupt identities with this extension.</p>
</div>
<table id="interruptIdents" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 2. Major and minor identities for all interrupt causes at a hart. Major identities 0-15 are the purview of the base Privileged Architecture.</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Major identity</th>
<th class="tableblock halign-center valign-top">Minor identity</th>
<th class="tableblock halign-left valign-top"></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Reserved by base Privileged Architecture</em></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<br>
2<br>
3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-<br>
-<br>
-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Supervisor software interrupt<br>
Virtual supervisor software interrupt<br>
Machine software interrupt</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Reserved by base Privileged Architecture</em></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">5<br>
6<br>
7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-<br>
-<br>
-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Supervisor timer interrupt<br>
Virtual supervisor timer interrupt<br>
Machine timer interrupt</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Reserved by base Privileged Architecture</em></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">9<br>
10<br>
11</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Determined by<br>
external interrupt<br>
controller</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Supervisor external interrupt<br>
Virtual supervisor external interrupt<br>
Machine external interrupt</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">12<br>
13<br>
14-15</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-<br>
-<br>
-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Supervisor guest external interrupt<br>
Counter overflow interrupt<br>
<em>Reserved by base Privileged Architecture</em></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">16-23</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Reserved for standard local interrupts</em></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">24-31</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Designated for custom use</em></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">32-34<br>
35<br>
36-42<br>
43<br>
44-47</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-<br>
-<br>
-<br>
-<br>
-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Reserved for standard local interrupts</em><br>
Low-priority RAS event interrupt<br>
<em>Reserved for standard local interrupts</em><br>
High-priority RAS event interrupt<br>
<em>Reserved for standard local interrupts</em></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">&#8805;48</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Designated for custom use</em></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Interrupts from most I/O devices are conveyed to a hart by the <em>external
interrupt controller</em> for the hart, which is either the hart&#8217;s IMSIC
(<a href="#intrsWithIMSICs">Figure 2</a>) or an APLIC
(<a href="#intrsWithoutIMSICs">Figure 1</a>). As
<a href="#interruptIdents">Table 2</a> shows, external
interrupts at a given privilege level all share a single major identity
number: 11 for machine level, 9 for supervisor level, and 10 for
VS-level. External interrupts from different causes are distinguished
from one another at a hart by their <em>minor identity numbers</em> supplied by
the external interrupt controller.</p>
</div>
<div class="paragraph">
<p>Other interrupt causes besides external interrupts might also have their
own minor identities. However, this document has need to discuss minor
identities only with regard to external interrupts.</p>
</div>
<div class="paragraph">
<p>The local interrupts defined by the Advanced Interrupt Architecture and
their handling are covered mainly in <a href="#MSLevel">Chapter 5</a>,
"Interrupts for Machine and Supervisor Levels."</p>
</div>
</div>
<div class="sect2">
<h3 id="selection-of-harts-to-receive-an-interrupt"><a class="anchor" href="#selection-of-harts-to-receive-an-interrupt"></a>1.5. Selection of harts to receive an interrupt</h3>
<div class="paragraph">
<p>Each signaled interrupt is delivered to only one hart at one privilege
level, usually determined by software in one way or another. Unlike some
other architectures, the RISC-V Advanced Interrupt Architecture provides no
standard hardware mechanism for the broadcast or multicast of interrupts
to multiple harts.</p>
</div>
<div class="paragraph">
<p>For local interrupts, and for any "virtual" interrupts that software
injects into less-privileged levels at a hart, the interrupts are
entirely a local affair at the hart and are never visible to other
harts. The RISC-V Privileged Architecture&#8217;s timer interrupts are also uniquely
tied to individual harts. For other interrupts, received by a hart from
sources outside the hart, each interrupt signal (whether delivered by
wire or by an MSI) is configured by software to go to only a single
hart.</p>
</div>
<div class="paragraph">
<p>To send an interprocessor interrupt (IPI) to multiple harts, the
originating hart need only execute a loop, sending an individual IPI to
each destination hart. For IPIs to a single destination hart, see
<a href="#IPIs">Chapter 7</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The effort that a source hart expends in sending individual IPIs to
multiple destinations will invariably be dwarfed by the combined effort
at the receiving harts to handle those interrupts. Hence, providing an
automated mechanism for IPI multicast could be expected to reduce a
system&#8217;s total overall work only modestly at best. With a very large
number of harts, a hardware mechanism for IPI multicast must contend
with the question of how exactly software specifies the intended
destination set with each use, and furthermore, the actual physical
delivery of IPIs may not differ that much from the software version.</p>
</div>
<div class="paragraph">
<p>We do not exclude the future possibility of an optional hardware
mechanism for multicast IPI, but only if a significant advantage can be
demonstrated in real use. As of 2020, Linux has been observed not to
make use of multicast IPI hardware even on systems that have it.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the rare event that a single interrupt from an I/O device needs to be
communicated to multiple harts, the interrupt must be sent to a single
hart which can then signal the other harts by IPIs.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>We contend that the need to communicate an I/O interrupt to multiple
harts is sufficiently rare that standardizing hardware support for
multicast cannot be justified in this case.</p>
</div>
<div class="paragraph">
<p>Along with multicast delivery, other architectures support an option for
"1-of-\(N\)" delivery of interrupts, whereby the hardware
chooses a single destination hart from among a configured set of
\(N\) harts, with the goal of automatic load balancing of
interrupt handling among the harts. Experiments in the 2010s called into
question the utility of 1-of-\(N\) modes in practice, showing
that software could often do a better job of load balancing than the
hardware algorithms implemented in actual chips. Linux was consequently
modified to discontinue using 1-of-\(N\) interrupt delivery
even on systems that have it.</p>
</div>
<div class="paragraph">
<p>We remain open to the argument that hardware load balancing of interrupt
handling may be beneficial for certain specialized markets, such as
networking. However, the claims made so far in this regard do not
justify requiring support for 1-of-\(N\) delivery in all RISC-V servers. With more evidence, some mechanism for 1-of-\(N\)
delivery might become a future option.</p>
</div>
<div class="paragraph">
<p>The original Platform-Level Interrupt Controller (PLIC) for RISC-V is
configurable so each interrupt source signals external interrupts to any
subset of the harts, potentially all harts. When multiple harts receive
an external interrupt from a single cause at the PLIC, the first hart to
<em>claim</em> the interrupt at the PLIC is the one responsible for servicing
it. Usually this sets up a race, where the subset of harts configured to
receive the multicast interrupt all take an external interrupt trap
simultaneously and compete to be the first to claim the interrupt at the
PLIC. The intention is to provide a form of 1-of-\(N\)
interrupt delivery. However, for all the harts that fail to win the
claim, the interrupt trap becomes wasted effort.</p>
</div>
<div class="paragraph">
<p>For the reasons already given, the Advanced PLIC supports sending each
signaled interrupt to only a single hart chosen by software, not to
multiple harts.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="isa-extensions-smaia-and-ssaia"><a class="anchor" href="#isa-extensions-smaia-and-ssaia"></a>1.6. ISA extensions Smaia and Ssaia</h3>
<div class="paragraph">
<p>The Advanced Interrupt Architecture (AIA) defines two names for
extensions to the RISC-V instruction set architecture (ISA), one for
machine-level execution environments, and another for supervisor-level
environments. For a machine-level environment, extension <strong>Smaia</strong>
encompasses all added CSRs and all modifications to interrupt response
behavior that the AIA specifies for a hart, over all privilege levels.
For a supervisor-level environment, extension <strong>Ssaia</strong> is essentially the
same as Smaia except excluding the machine-level CSRs and behavior not
directly visible to supervisor level.</p>
</div>
<div class="paragraph">
<p>Extensions Smaia and Ssaia cover only those AIA features that impact the
ISA at a hart. Although the following are described or discussed in this
document as part of the AIA, they are not implied by Smaia or Ssaia
because the components are categorized as non-ISA: APLICs, IOMMUs, and
any mechanisms for initiating interprocessor interrupts apart from
writing to IMSICs.</p>
</div>
<div class="paragraph">
<p>As revealed in subsequent chapters, the exact set of CSRs and behavior
added by the AIA, and hence implied by Smaia or Ssaia, depends on the
base ISA&#8217;s XLEN (RV32 or RV64), on whether S-mode and the H
extension are implemented, and on whether the hart has an IMSIC. But
individual AIA extension names are not provided for each possible valid
subset. Rather, the different combinations are inferable from the
intersection of features indicated (such as RV64I + S-mode + Smaia, but
without the H extension).</p>
</div>
<div class="paragraph">
<p>Software development tools like compilers and assemblers need not be
concerned about whether an IMSIC exists but should just allow attempts
to access the IMSIC CSRs (described in <a href="#CSRs">Chapter 2</a>
and <a href="#IMSIC">Chapter 3</a>) if Smaia or Ssaia is indicated. Without an
actual IMSIC, such attempts may trap, but that is not a problem for the
development tools.</p>
</div>
<div class="paragraph">
<p>If extension Smaia/Ssaia is implemented, then anywhere that
the AIA specification has an irreconcilable conflict with the requirements
of another implemented RISC-V extension, the AIA is intended to have priority,
unless the other extension explicitly extends or overrides the AIA.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Extension Smcsrind/Sscsrind explicitly extends
the AIA&#8217;s facility for indirect CSR access provided by
the <code>*iselect</code> and <code>*ireg</code> CSRs described in the next chapter.
Hence, if Smcsrind/Sscsrind is also implemented, any perceived conflicts
between it and the AIA should be resolved in favor of Smcsrind/Sscsrind.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="CSRs"><a class="anchor" href="#CSRs"></a>2. Control and Status Registers (CSRs) Added to Harts</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For each privilege level at which a RISC-V hart can take interrupt traps, the
Advanced Interrupt Architecture adds CSRs for interrupt control and
handling.</p>
</div>
<div class="sect2">
<h3 id="machine-level-csrs"><a class="anchor" href="#machine-level-csrs"></a>2.1. Machine-level CSRs</h3>
<div class="paragraph">
<p><a href="#CSRs-M">Table 3</a> lists both the CSRs added for machine
level and existing machine-level CSRs whose size is changed by the
Advanced Interrupt Architecture. Existing CSRs <code>mie</code>, <code>mip</code>, and <code>mideleg</code> are widened to 64 bits to support a total of 64 interrupt causes.</p>
</div>
<div class="paragraph">
<p>For RV32, the <em>high-half</em> CSRs listed in the table allow access to the
upper 32 bits of registers <code>mideleg</code>, <code>mie</code>, <code>mvien</code>, <code>mvip</code>, and <code>mip</code>. The Advanced Interrupt Architecture requires that these high-half CSRs exist for RV32, but the bits they access may all be merely read-only zeros.</p>
</div>
<div class="paragraph">
<p>CSRs <code>miselect</code> and <code>mireg</code> provide a window for accessing multiple registers beyond the CSRs in <a href="#CSRs-M">Table 3</a>. The value of <code>miselect</code> determines which
register is currently accessible through alias CSR <code>mireg</code>. <code>miselect</code> is a <strong>WARL</strong> register, and it must support a minimum range of values depending on the implemented features. When an IMSIC is not implemented, <code>miselect</code> must be able to hold at least any 6-bit value in the range 0 to 0<code>x3F</code>. When an IMSIC is implemented, <code>miselect</code> must be able to hold any 8-bit value in the range 0 to 0<code>xFF</code>.
The Advanced Interrupt Architecture makes use
of these subranges of values for <code>miselect</code>:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>0x30-0x3F</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">major interrupt priorities</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>0x70-0xFF</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">external interrupts (only with an IMSIC)</p></td>
</tr>
</tbody>
</table>
<table id="CSRs-M" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 3. Machine-level CSRs added or widened by the Advanced Interrupt Architecture.</caption>
<colgroup>
<col>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Number</th>
<th class="tableblock halign-center valign-top">Privilege</th>
<th class="tableblock halign-center valign-top">Width</th>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top" colspan="5"><p class="tableblock">Machine-Level Window to Indirectly Accessed Registers</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0x350<br>
0x351</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">MRW<br>
MRW</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">XLEN<br>
XLEN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>miselect</code><br>
<code>mireg</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Machine indirect register select<br>
Machine indirect register alias</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="5"><p class="tableblock">Machine-Level Interrupts</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0x304<br>
0x344<br>
0x35C<br>
0xFB0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">MRW<br>
MRW<br>
MRW<br>
MRO</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">64<br>
64<br>
MXLEN<br>
MXLEN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mie</code><br>
<code>mip</code><br>
<code>mtopei</code><br>
<code>mtopi</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Machine interrupt-enable bits<br>
Machine interrupt-pending bits<br>
Machine top external interrupt (only with an IMSIC)<br>
Machine top interrupt</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="5"><p class="tableblock">Delegated and Virtual Interrupts for Supervisor Level</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0x303<br>
0x308<br>
0x309</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">MRW<br>
MRW<br>
MRW</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">64<br>
64<br>
64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mideleg</code><br>
<code>mvien</code><br>
<code>mvip</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Machine interrupt delegation<br>
Machine virtual interrupt enables<br>
Machine virtual interrupt-pending bits</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="5"><p class="tableblock">Machine-Level High-Half CSRs (RV32 only)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0x313<br>
0x314<br>
0x318<br>
0x319<br>
0x354</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">MRW<br>
MRW<br>
MRW<br>
MRW<br>
MRW</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">32<br>
32<br>
32<br>
32<br>
32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>midelegh</code><br>
<code>mieh</code><br>
<code>mvienh</code><br>
<code>mviph</code><br>
<code>miph</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Upper 32 bits of <code>mideleg</code> (only with S-mode)<br>
Upper 32 bits of <code>mie</code><br>
Upper 32 bits of <code>mvien</code> (only with S-mode)<br>
Upper 32 bits of <code>mvip</code> (only with S-mode)<br>
Upper 32 bits of <code>mip</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Values of <code>miselect</code> with the most-significant bit set (bit
<code>XLEN - 1</code> = <code>1</code>) are designated for custom use,
presumably for accessing custom registers through <code>mireg</code>. If <code>XLEN</code> changes, the
most-significant bit of <code>miselect</code> moves to the new position, retaining its value
from before. An implementation is not required to support any custom
values for <code>miselect</code>.</p>
</div>
<div class="paragraph">
<p>Other <code>miselect</code> values are reserved for other RISC-V extensions.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>RISC-V extension Smcsrind generalizes the mechanism of
indirect register access provided by <code>miselect</code> and <code>mireg</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Normally, the range for external interrupts, 0x70-0xFF, is populated only when
an IMSIC is implemented; else, attempts to access <code>mireg</code> when <code>miselect</code> is in this range
cause an illegal instruction exception. The contents of the
external-interrupts region are documented in
<a href="#IMSIC">Chapter 3</a> on the IMSIC.</p>
</div>
<div class="paragraph">
<p>CSR <code>mtopei</code> also exists only when an IMSIC is implemented, so is documented in
<a href="#IMSIC">Chapter 3</a> along with the indirectly accessed IMSIC
registers.</p>
</div>
<div class="paragraph">
<p>CSR <code>mtopi</code> reports the highest-priority interrupt that is pending and enabled
for machine level, as specified in <a href="#mtopi">Section 5.2.2</a>.</p>
</div>
<div class="paragraph">
<p>When S-mode is implemented, CSRs <code>mvien</code> and <code>mvip</code> support interrupt filtering and
virtual interrupts for supervisor level. These facilities are explained
in <a href="#virtIntrs-S">Section 5.3</a>.</p>
</div>
<div class="paragraph">
<p>If extension Smcsrind is also implemented, then when <code>miselect</code> has a value in the
range 0x30-0x3F
or 0x70-0xFF, attempts to access alias CSRs <code>mireg2</code> through <code>mireg6</code> raise an illegal
instruction exception.</p>
</div>
</div>
<div class="sect2">
<h3 id="supervisor-level-csrs"><a class="anchor" href="#supervisor-level-csrs"></a>2.2. Supervisor-level CSRs</h3>
<div class="paragraph">
<p><a href="#CSRs-S">Table 4</a> lists the supervisor-level CSRs that are
added and existing CSRs that are widened to 64 bits, if the hart
implements S-mode. The functions of these registers all match their
machine-level counterparts.</p>
</div>
<table id="CSRs-S" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 4. Supervisor-level CSRs added or widened by the Advanced Interrupt Architecture.</caption>
<colgroup>
<col>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Number</th>
<th class="tableblock halign-center valign-top">Privilege</th>
<th class="tableblock halign-center valign-top">Width</th>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top" colspan="5"><p class="tableblock">Supervisor-Level Window to Indirectly Accessed Registers</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0x150<br>
0x151</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">SRW<br>
SRW</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">XLEN<br>
XLEN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>siselect</code><br>
<code>sireg</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Supervisor indirect register select<br>
Supervisor indirect register alias</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="5"><p class="tableblock">Supervisor-Level Interrupts</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0x104<br>
0x144<br>
0x15C<br>
0xDB0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">SRW<br>
SRW<br>
SRW<br>
SRO</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">64<br>
64<br>
SXLEN<br>
SXLEN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sie</code><br>
<code>sip</code><br>
<code>stopei</code><br>
<code>stopi</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Supervisor interrupt-enable bits<br>
Supervisor interrupt-pending bits<br>
Supervisor top external interrupt (only with an IMSIC)<br>
Supervisor top interrupt</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="5"><p class="tableblock">Supervisor-Level High-Half CSRs (RV32 only)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0x114<br>
0x154</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">SRW<br>
SRW</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">32<br>
32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sieh</code><br>
<code>siph</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Upper 32 bits of <code>sie</code><br>
Upper 32 bits of <code>sip</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The space of registers accessible through the <code>siselect</code>/<code>sireg</code> window is separate from
but parallels that of machine level, being for supervisor-level
interrupts instead of machine-level interrupts.
The subranges of values used for <code>siselect</code> are once again these:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>0x30-0x3F</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">major interrupt priorities</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>0x70-0xFF</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">external interrupts (only with an IMSIC)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>For maximum compatibility, it is recommended that <code>siselect</code> support at least a
9-bit range, <code>0</code> to <code>0x1FF</code>, regardless of whether an IMSIC exists.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Because the VS CSR <code>vsiselect</code> (<a href="#hypervisor-vs-csrs">Section 2.3</a>) always has at
least 9 bits, and like other VS CSRs, <code>vsiselect</code> substitutes for <code>siselect</code> when executing in
a virtual machine (VS-mode or VU-mode), implementing a smaller range for
<code>siselect</code> allows software to discover it is not running in a virtual machine.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Like <code>miselect</code>, values of <code>siselect</code> with the most-significant bit set (bit
XLEN - 1 = 1) are designated for custom use.
If XLEN changes, the most-significant bit of <code>siselect</code> moves to the new position,
retaining its value from before. An implementation is not required to
support any custom values for <code>siselect</code>.</p>
</div>
<div class="paragraph">
<p>Other <code>siselect</code> values are reserved for other RISC-V extensions.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>At supervisor level, extension Sscsrind generalizes the mechanism
of indirect register access provided by <code>siselect</code> and <code>sireg</code>,
as well as the parallel at VS-level provided by <code>vsiselect</code> and <code>vsireg</code>,
described in the next subsection.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that the widths of 'siselect' and 'sireg' are always the current XLEN rather than
SXLEN. Hence, for example, if MXLEN = 64 and SXLEN = 32, then these
registers are 64 bits when the current privilege mode is M (running RV64
code) but 32 bits when the privilege mode is S (RV32 code).</p>
</div>
<div class="paragraph">
<p>CSR <code>stopei</code> is described with the IMSIC in <a href="#IMSIC">Chapter 3</a>.</p>
</div>
<div class="paragraph">
<p>Register <code>stopi</code> reports the highest-priority interrupt that is pending and
enabled for supervisor level, as specified in
<a href="#stopi">Section 5.4.2</a>.</p>
</div>
<div class="paragraph">
<p>If extension Sscsrind is also implemented, then when <code>siselect</code> has a value in the range <code>0x30-0x3F</code> or <code>0x70-0xFF</code>, attempts to access alias CSRs <code>sireg2</code> through <code>sireg6</code> raise an illegal instruction exception (unless executing in a virtual machine, covered in the next section).</p>
</div>
</div>
<div class="sect2">
<h3 id="hypervisor-vs-csrs"><a class="anchor" href="#hypervisor-vs-csrs"></a>2.3. Hypervisor and VS CSRs</h3>
<div class="paragraph">
<p>If a hart implements the H extension,
then the hypervisor and VS CSRs listed in <a href="#CSRs-hypervisor">Table 5</a> are also either added or widened to 64 bits.</p>
</div>
<div class="paragraph">
<p>The new hypervisor CSRs in the table (<code>hvien</code>, <code>hvictl</code> , <code>hviprio1</code>, and <code>hviprio2</code>) augment <code>hvip</code> for injecting interrupts into VS level. The use of these registers is covered in <a href="#VSLevel">Chapter 6</a> on interrupts for virtual machines.</p>
</div>
<div class="paragraph">
<p>The new VS CSRs (<code>vsiselect</code>, <code>vsireg</code>, <code>vstopei</code>, and <code>vstopi</code>) all match supervisor CSRs, and substitute for those supervisor CSRs when executing in a virtual machine (in VS-mode or VU-mode).</p>
</div>
<div class="paragraph">
<p>CSR <code>vsiselect</code> is required to support at least a 9-bit range of <code>0</code> to <code>0x1FF</code>, whether or not an IMSIC is implemented. As with <code>siselect</code>, values of <code>vsiselect</code> with the most-significant bit set (bit XLEN - 1 = 1) are designated for custom use. If XLEN changes, the most-significant bit
of <code>vsiselect</code> moves to the new position, retaining its value from before.</p>
</div>
<div class="paragraph">
<p>Like <code>siselect</code> and <code>sireg</code>, the widths of <code>vsiselect</code> and <code>vsireg</code> are always the current XLEN rather than VSXLEN. Hence, for example, if HSXLEN = 64 and VSXLEN = 32, then these registers are 64 bits when accessed by a hypervisor in HS-mode (running RV64 code) but 32 bits for a guest OS in VS-mode (RV32 code).</p>
</div>
<table id="CSRs-hypervisor" class="tableblock frame-all grid-all stretch center">
<caption class="title">Table 5. Hypervisor and VS CSRs added or widened by the Advanced Interrupt Architecture. (Parameter HSXLEN is just another name for SXLEN for hypervisor-extended S-mode).</caption>
<colgroup>
<col style="width: 13.3333%;">
<col style="width: 13.3333%;">
<col style="width: 13.3333%;">
<col style="width: 13.3333%;">
<col style="width: 46.6668%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Number</th>
<th class="tableblock halign-center valign-top">Privilege</th>
<th class="tableblock halign-center valign-top">Width</th>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top" colspan="5"><p class="tableblock">Delegated and Virtual Interrupts, Interrupt Priorities, for VS Level</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0x603<br>
0x608<br>
0x609<br>
0x645<br>
0x646<br>
0x647</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">HRW<br>
HRW<br>
HRW<br>
HRW<br>
HRW<br>
HRW</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">64<br>
64<br>
HSXLEN<br>
64<br>
64<br>
64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hideleg</code><br>
<code>hvien</code><br>
<code>hvictl</code><br>
<code>hvip</code><br>
<code>hviprio1</code><br>
<code>hviprio2</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hypervisor interrupt delegation<br>
Hypervisor virtual interrupt enables<br>
Hypervisor virtual interrupt control<br>
Hypervisor virtual interrupt-pending bits<br>
Hypervisor VS-level interrupt priorities<br>
Hypervisor VS-level interrupt priorities</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="5"><p class="tableblock">VS-Level Window to Indirectly Accessed Registers</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0x250<br>
0x251</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">HRW<br>
HRW</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">XLEN<br>
XLEN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>vsiselect</code><br>
<code>vsireg</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Virtual supervisor indirect register select<br>
Virtual supervisor indirect register alias</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="5"><p class="tableblock">VS-Level Interrupts</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0x204<br>
0x244<br>
0x25C<br>
&nbsp;<br>
0xEB0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">HRW<br>
HRW<br>
HRW<br>
&nbsp;<br>
HRO</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">64<br>
64<br>
VSXLEN<br>
&nbsp;<br>
VSXLEN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>vsie</code><br>
<code>vsip</code><br>
<code>vstopei</code><br>
&nbsp;<br>
<code>vstopi</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Virtual supervisor interrupt-enable bits<br>
Virtual supervisor interrupt-pending bits<br>
Virtual supervisor top external interrupt<br>
 (only with an IMSIC)<br>
Virtual supervisor top interrupt</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="5"><p class="tableblock">Hypervisor and VS-Level High-Half CSRs (RV32 only)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0x613<br>
0x618<br>
0x655<br>
0x656<br>
0x657<br>
0x214<br>
0x254</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">HRW<br>
HRW<br>
HRW<br>
HRW<br>
HRW<br>
HRW<br>
HRW</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">32<br>
32<br>
32<br>
32<br>
32<br>
32<br>
32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hidelegh</code><br>
<code>hvienh</code><br>
<code>hviph</code><br>
<code>hviprio1h</code><br>
<code>hviprio2h</code><br>
<code>vsieh</code><br>
<code>vsiph</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Upper 32 bits of <code>hideleg</code><br>
Upper 32 bits of <code>hvien</code><br>
Upper 32 bits of <code>hvip</code><br>
Upper 32 bits of <code>hviprio1</code><br>
Upper 32 bits of <code>hviprio2</code><br>
Upper 32 bits of <code>vsie</code><br>
Upper 32 bits of <code>vsip</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The space of registers selectable by <code>vsiselect</code> is more limited than for machine and supervisor levels:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>0x030-0x03F</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">inaccessible</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>0x070-0x0FF</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">external interrupts (IMSIC only), or inaccessible</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Other <code>vsiselect</code> values are reserved for other RISC-V extensions.</p>
</div>
<div class="paragraph">
<p>For alias CSRs <code>sireg</code> and <code>vsireg</code>, the H extension&#8217;s usual rules for when to raise a virtual instruction exception (based on whether an instruction is <em>HS-qualified</em>) are not applicable. The rules given in this section for <code>sireg</code> and <code>vsireg</code> apply instead, unless overridden by the requirements of <a href="#CSRs-stateen">Section 2.5</a>, which take precedence over this section
when extension Smstateen is also implemented.</p>
</div>
<div class="paragraph">
<p>A virtual instruction exception is raised for attempts from VS-mode or
VU-mode to directly access <code>vsireg</code>, or attempts from VU-mode to access <code>sireg</code>.</p>
</div>
<div class="paragraph">
<p>When <code>vsiselect</code> has the number of an <em>inaccessible</em> register, attempts from M-mode or HS-mode to access <code>vsireg</code> raise an illegal instruction exception, and attempts from VS-mode to access <code>sireg</code> (really <code>vsireg</code>) raise a virtual instruction exception.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Requiring a range of 0-0x1FF for <code>vsiselect</code>, even though most or all of the space is reserved or inaccessible, permits a hypervisor to emulate indirectly
accessed registers in the implemented range, including registers that
are not currently defined but may be standardized in the future.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The indirectly accessed registers for external interrupts (numbers 0x70-0xFF)
are accessible only when field VGEIN of <code>hstatus</code> is the number of an implemented guest external interrupt, not zero. If VGEIN is not the number of an implemented guest external interrupt (including the case when no IMSIC
is implemented), then all indirect register numbers in the ranges 0x030-0x03F and 0x070-0x0FF designate an inaccessible register at VS level.</p>
</div>
<div class="paragraph">
<p>Along the same lines, when <code>hstatus.VGEIN</code> is not the number of an implemented
guest external interrupt, attempts from M-mode or HS-mode to access CSR <code>vstopei</code> raise an illegal instruction exception, and attempts from VS-mode to
access <code>stopei</code> raise a virtual instruction exception.</p>
</div>
<div class="paragraph">
<p>If extension Sscsrind is also implemented, then when <code>vsiselect</code> has a value in the range 0x30-0x3F or 0x70-0xFF, attempts from M-mode or HS-mode to access alias CSRs <code>vsireg2</code> through <code>vsireg6</code> raise an illegal instruction exception, and attempts from VS-mode to access <code>sireg2</code> through <code>sireg6</code> raise a virtual instruction exception.</p>
</div>
</div>
<div class="sect2">
<h3 id="virtual-instruction-exceptions"><a class="anchor" href="#virtual-instruction-exceptions"></a>2.4. Virtual instruction exceptions</h3>
<div class="paragraph">
<p>Following the default rules for the H extension, attempts from
VS-mode to directly access a hypervisor or VS CSR other than <code>vsireg</code>, or from
VU-mode to access any supervisor-level CSR (including hypervisor and VS
CSRs) other than <code>sireg</code> or <code>vsireg</code>, usually raise not an illegal instruction exception but instead a virtual instruction exception. For details, see the H extension documentation.</p>
</div>
<div class="paragraph">
<p>Instructions that read/write CSR <code>stopei</code> or <code>vstopei</code> are considered to be <em>HS-qualified</em> unless all of following are true: the hart has an IMSIC, extension Smstateen is implemented, and bit 58 of <code>mstateen0</code> is zero. (See the next section, <a href="#CSRs-stateen">Section 2.5</a>, about <code>mstateen0</code>.)</p>
</div>
<div class="paragraph">
<p>For <code>sireg</code> and <code>vsireg</code>, see both the previous section, <a href="#hypervisor-vs-csrs">Section 2.3</a>, and the next, <a href="#CSRs-stateen">Section 2.5</a>, for when a virtual instruction exception is required instead of an illegal instruction exception.</p>
</div>
</div>
<div class="sect2">
<h3 id="CSRs-stateen"><a class="anchor" href="#CSRs-stateen"></a>2.5. Access control by the state-enable CSRs</h3>
<div class="paragraph">
<p>If extension Smstateen is implemented together with the Advanced
Interrupt Architecture (AIA), three bits of state-enable register <code>mstateen0</code> control access to AIA-added state from privilege modes less privileged
than M-mode:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bit 60 CSRIND: CSRs <code>siselect</code>, <code>sireg</code>, <code>vsiselect</code>, and <code>vsireg</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bit 59 AIA: all other state added by the AIA and not controlled by bits CSRIND and IMSIC</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bit 58 IMSIC: all IMSIC state, including CSRs <code>stopei</code> and <code>vstopei</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>If one of these bits is zero in <code>mstateen0</code>, an attempt to access the corresponding state from a privilege mode less privileged than M-mode results in an illegal instruction trap. As always, the state-enable CSRs do not affect
the accessibility of any state when in M-mode, only in less privileged modes. For more explanation, see the documentation for extension Smstateen.</p>
</div>
<div class="paragraph">
<p>The AIA bit controls access to AIA CSRs <code>siph</code>, <code>sieh</code>, <code>stopi</code>, <code>hidelegh</code>, <code>hvien</code>/<code>hvienh</code>, <code>hviph</code>, <code>hvictl</code>, <code>hviprio1</code>/<code>hviprio1h</code>, <code>hviprio2</code>/<code>hviprio2h</code>, <code>vsiph</code>, <code>vsieh</code>, and <code>vstopi</code>, as well as to the supervisor-level interrupt priorities accessed through <code>siselect</code> + <code>sireg</code> (the <code>iprio</code> array of <a href="#intrPrios-S">Section 5.4.1</a>).</p>
</div>
<div class="paragraph">
<p>The IMSIC bit is implemented in <code>mstateen0</code> only if the hart has an IMSIC. If the
H extension is also implemented, this bit does not affect the
behavior or accessibility of hypervisor CSRs <code>hgeip</code> and <code>hgeie</code>, or field VGEIN of <code>hstatus</code>. In particular, guest external interrupts from an IMSIC continue to be visible to HS-mode in <code>hgeip</code> even when <code>mstateen0</code>.IMSIC is zero.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>An earlier, pre-ratification draft of Smstateen said that when <code>mstateen0</code>.IMSIC is zero, registers <code>hgeip</code> and <code>hgeie</code> and field VGEIN of <code>hstatus</code> are all read-only zeros. That effect is no longer correct.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the hart does not have an IMSIC, the IMSIC bit of <code>mstateen0</code> is read-only zero, but Smstateen has no effect on attempts to access the nonexistent IMSIC
state.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This means in particular that, when the hart does not have an IMSIC, the
following raise a virtual instruction exception as described in <a href="#CSRs-hypervisor">Table 5</a>, not an illegal instruction exception, despite that <code>mstateen0</code>.IMSIC is zero:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>attempts from VS-mode to access <code>sireg</code> (really <code>vsireg</code>) while <code>vsiselect</code> has a value in the range 0x70â€“0xFF; and</p>
</li>
<li>
<p>attempts from VS-mode to access <code>stopei</code> (really <code>vstopei</code>).</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the CSRIND bit of <code>mstateen0</code> is one, then regardless of any other <code>mstateen</code> bits (including the AIA and IMSIC bits of <code>mstateen0</code>), a virtual instruction exception is raised as described in <a href="#hypervisor-vs-csrs">Section 2.3</a> for all attempts from VS-mode or
VU-mode to directly access <code>vsireg</code>, and for all attempts from VU-mode to access <code>sireg</code>. This behavior is overridden only when <code>mstateen0</code>.CSRIND is zero.</p>
</div>
<div class="paragraph">
<p>If the H extension is implemented, the same three bits are
defined also in hypervisor CSR <code>hstateen0</code> but concern only the state potentially accessible to a virtual machine executing in privilege modes VS and VU:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bit 60 CSRIND: CSRs <code>siselect</code> and <code>sireg</code> (really <code>vsiselect</code> and <code>vsireg</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bit 59 AIA: CSRs <code>siph</code> and <code>sieh</code> (RV32 only) and <code>stopi</code> (really <code>vsiph</code>, <code>vsieh</code>, and <code>vstopi</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bit 58 IMSIC: all state of IMSIC guest interrupt files, including CSR <code>stopei</code>(really <code>vstopei</code>)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>If one of these bits is zero in <code>hstateen0</code>, and the same bit is one in <code>mstateen0</code>, then an attempt to access the corresponding state from VS or VU-mode raises a virtual instruction exception. (But note that, for high-half CSRs <code>siph</code> and <code>sieh</code>, this applies only when XLEN = 32. When XLEN &gt; 32, an attempt to access <code>siph</code> or <code>sieh</code> raises an illegal instruction exception as usual, not a virtual instruction exception.)</p>
</div>
<div class="paragraph">
<p>If the CSRIND bit is one in <code>mstateen0</code> but is zero in <code>hstateen0</code>, then all attempts from VS or VU-mode to access <code>siselect</code> or <code>sireg</code> raise a virtual instruction exception, not an illegal instruction exception, regardless of the value of <code>vsiselect</code> or any other <code>mstateen</code> bits.</p>
</div>
<div class="paragraph">
<p>The IMSIC bit is implemented in <code>hstateen0</code> only if the hart has an IMSIC. Furthermore, even with an IMSIC, <code>hstateen0</code>.IMSIC may (or may not) be read-only zero if the IMSIC has no <em>guest interrupt files</em> for guest external interrupts (<a href="#IMSIC">Chapter 3</a>). When this bit is zero (whether read-only zero or set to zero), a virtual machine is prevented from accessing the hart&#8217;s IMSIC the same as when <code>hstatus.VGEIN</code> = 0.</p>
</div>
<div class="paragraph">
<p>Extension Ssstateen is defined as the supervisor-level view of Smstateen. Therefore, the combination of Ssaia and Ssstateen incorporates the bits defined above for <code>hstateen0</code> but not those for <code>mstateen0</code>, since machine-level CSRs are not visible to supervisor level.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="IMSIC"><a class="anchor" href="#IMSIC"></a>3. Incoming MSI Controller (IMSIC)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>An Incoming MSI Controller (IMSIC) is an optional RISC-V hardware component
that is closely coupled with a hart, one IMSIC per hart. An IMSIC
receives and records incoming message-signaled interrupts (MSIs) for a
hart, and signals to the hart when there are pending and enabled
interrupts to be serviced.</p>
</div>
<div class="paragraph">
<p>An IMSIC has one or more memory-mapped registers in the machine&#8217;s
address space for receiving MSIs. Aside from those memory-mapped
registers, software interacts with an IMSIC primarily through several RISC-V CSRs at the attached hart.</p>
</div>
<div class="sect2">
<h3 id="IMSIC-intrFilesAndIdents"><a class="anchor" href="#IMSIC-intrFilesAndIdents"></a>3.1. Interrupt files and interrupt identities</h3>
<div class="paragraph">
<p>In a RISC-V system, MSIs are directed not just to a specific hart but to a
specific privilege level of a specific hart, such as machine or
supervisor level. Furthermore, when a hart implements the H
extension, an IMSIC may optionally allow MSIs to be directed to a
specific virtual hart at virtual supervisor level (VS level).</p>
</div>
<div class="paragraph">
<p>For each privilege level and each virtual hart to which MSIs may be
directed at a hart, the hart&#8217;s IMSIC contains a separate <em>interrupt
file</em>. Assuming a hart implements supervisor mode, its IMSIC has at
least two interrupt files, one for machine level and the other for
supervisor level. When a hart also implements the H extension,
its IMSIC may have additional interrupt files for virtual harts, called
<em>guest interrupt files</em>. The number of guest interrupt files an IMSIC
has for virtual harts is exactly <em>GEILEN</em>, the number of supported guest
external interrupts, as defined by the H extension.</p>
</div>
<div class="paragraph">
<p>Each individual interrupt file consists mainly of two arrays of bits of
the same size, one array for recording MSIs that have arrived but are
not yet serviced (interrupt-pending bits), and the other array for
specifying which interrupts the hart will currently accept
(interrupt-enable bits). Each bit position in the two arrays corresponds
with a different interrupt <em>identity number</em> by which MSIs from
different sources are distinguished at an interrupt file. Because an
IMSIC is the external interrupt controller for a hart, an interrupt
file&#8217;s interrupt identities become the <em>minor identities</em> for external
interrupts at the attached hart.</p>
</div>
<div class="paragraph">
<p>The number of interrupt identities supported by an interrupt file (and
hence the number of active bits in each array) is one less than a
multiple of 64, and may be a minimum of 63 and a maximum of 2047.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Platform standards may increase the minimum number of interrupt
identities that must be implemented by each interrupt file.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When an interrupt file supports \(N\) distinct interrupt
identities, valid identity numbers are between 1 and \(N\)
inclusive. The identity numbers within this range are said to be
implemented by the interrupt file; numbers outside this range are not
implemented. The number zero is never a valid interrupt identity.</p>
</div>
<div class="paragraph">
<p>IMSIC hardware does not assume any connection between the interrupt
identity numbers at one interrupt file and those at another interrupt
file. Software is commonly expected to assign the same interrupt
identity number to different MSI sources at different interrupt files,
without coordination across interrupt files. Thus the total number of
MSI sources that can be separately distinguished within a system is
potentially the product of the number of interrupt identities at a
single interrupt file times the total number of interrupt files in the
system, over all harts.</p>
</div>
<div class="paragraph">
<p>It is not necessarily the case that all interrupt files in a system are
the same size (implement the same number of interrupt identities). For a
given hart, the interrupt files for guest external interrupts must all
be the same size, but the interrupt files at machine level and at
supervisor level may differ in size from those of guest external
interrupts, and from each other. Likewise, the interrupt files of
different harts may be different sizes.</p>
</div>
<div class="paragraph">
<p>A platform might provide a means for software to configure the number of
interrupt files in an IMSIC and/or their sizes, such as by allowing a
smaller interrupt file at machine level to be traded for a larger one at
supervisor level, or vice versa, for example. Any such configurability
is outside the scope of this specification. It is recommended, however,
that only machine level be given the power to change the number and
sizes of interrupt files in an IMSIC.</p>
</div>
</div>
<div class="sect2">
<h3 id="MSIEncoding"><a class="anchor" href="#MSIEncoding"></a>3.2. MSI encoding</h3>
<div class="paragraph">
<p>Established standards (in particular, for PCI and PCI Express) dictate
that an individual message-signaled interrupt (MSI) from a device takes
the form of a naturally aligned 32-bit write by the device, with the
address and value both configured at the device (or device controller)
by software. Depending on the versions of the standards to which a
device or controller conforms, the address might be restricted to the
lower 4-GiB (32-bit) range, and the value written might be limited to a
16-bit range, with the upper 16 bits always being zeros.</p>
</div>
<div class="paragraph">
<p>When RISC-V harts have IMSICs, an MSI from a device is normally sent directly
to an individual hart that was selected by software to handle the
interrupt (presumably based on some interrupt affinity policy). An MSI
is directed to a specific privilege level, or to a specific virtual
hart, via the corresponding interrupt file that exists in the receiving
hart&#8217;s IMSIC. The MSI write address is the physical address of a
particular word-size register that is physically connected to the target
interrupt file. The MSI write data is simply the identity number of the
interrupt to be made pending in that interrupt file (becoming eventually
the minor identity for an external interrupt to the attached hart).</p>
</div>
<div class="paragraph">
<p>By configuring an MSI&#8217;s address and data at a device, system software
fully controls: (a) which hart receives a particular device interrupt,
(b) the target privilege level or virtual hart, and (c) the identity
number that represents the MSI in the target interrupt file. Elements a
and b are determined by which interrupt file is targeted by the MSI
address, while element c is communicated by the MSI data.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>As the maximum interrupt identity number an IMSIC can support is 2047, a
16-bit limit on MSI data values presents no problem.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When the H extension is implemented and a device is being
managed directly by a guest operating system, MSI addresses from the
device are initially guest physical addresses, as they are configured at
the device by the guest OS. These guest addresses must be translated by
an IOMMU, which gets configured by the hypervisor to redirect those MSIs
to the interrupt files for the correct guest external interrupts. For
more on this topic, see <a href="#IOMMU">Chapter 8</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="interrupt-priorities"><a class="anchor" href="#interrupt-priorities"></a>3.3. Interrupt priorities</h3>
<div class="paragraph">
<p>Within a single interrupt file, interrupt priorities are determined
directly from interrupt identity numbers. Lower identity numbers have
higher priority.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Because MSIs give software complete control over the assignment of
identity numbers in an interrupt file, software is free to select
identity numbers that reflect the relative priorities desired for
interrupts.</p>
</div>
<div class="paragraph">
<p>It is true that software could adjust interrupt priorities more
dynamically if interrupt files included an array of priority numbers to
assign to each interrupt identity. However, we believe that such
additional flexibility would not be utilized often enough to justify the
extra hardware expense. In fact, for many systems currently employing
MSIs, it is common practice for software to ignore interrupt priorities
entirely and act as though all interrupts had equal priority.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>An interrupt file&#8217;s lowest identity numbers have been given the highest
priorities, not the reverse order, because it is only for the
highest-priority interrupts that priority order may need to be carefully
managed, yet it is the low-numbered identities, 1Â through 63 (or perhaps
1 through 127), that are guaranteed to exist across all systems.
Consider, for example, that an interrupt file&#8217;s highest-priority
interruptâ€”presumably the most time-criticalâ€”is always identity number 1.
If priority order were reversed, the highest-priority interrupt would
have different identity numbers on different machines, depending on how
many identities are implemented by interrupt files. The ability for
software to assign fixed identity numbers to the highest-priority
interrupts is considered worth any discomfort that may be felt from
interrupt priorities being the reverse of the natural number order.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="reset-and-revealed-state"><a class="anchor" href="#reset-and-revealed-state"></a>3.4. Reset and revealed state</h3>
<div class="paragraph">
<p>Upon reset of an IMSIC, all the state of its interrupt files becomes
valid and consistent but otherwise UNSPECIFIED, except possibly for the <code>eidelivery</code> register of
machine-level and supervisor-level interrupt files, as specified in
<a href="#IMSIC-reg-eidelivery">Section 3.8.1</a>.</p>
</div>
<div class="paragraph">
<p>If an IMSIC contains a supervisor-level interrupt file and software at
the attached hart enables S-mode that was previously disabled (e.g. by
changing bit S of CSR <code>misa</code> from zero to one), all state of the
supervisor-level interrupt file is valid and consistent but otherwise UNSPECIFIED. Likewise, if an IMSIC contains guest interrupt files and software at the attached hart enables the H extension that was previously disabled (e.g. by changing bit H of <code>misa</code> from zero to one), all state of the IMSIC&#8217;s guest interrupt files is valid and consistent but otherwise UNSPECIFIED.</p>
</div>
</div>
<div class="sect2">
<h3 id="IMSIC-memRegion"><a class="anchor" href="#IMSIC-memRegion"></a>3.5. Memory region for an interrupt file</h3>
<div class="paragraph">
<p>Each interrupt file in an IMSIC has one or two memory-mapped 32-bit
registers for receiving MSI writes. These memory-mapped registers are
located within a naturally aligned 4-KiB region (a page) of physical
address space that exists for the interrupt file, i.e., one page per
interrupt file.</p>
</div>
<div class="paragraph">
<p>The layout of an interrupt-file&#8217;s memory region is:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">offset</th>
<th class="tableblock halign-left valign-top">size</th>
<th class="tableblock halign-left valign-top">register name</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>seteipnum_le</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x004</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>seteipnum_be</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>All other bytes in an interrupt file&#8217;s 4-KiB memory region are reserved
and must be implemented as read-only zeros.</p>
</div>
<div class="paragraph">
<p>Only naturally aligned 32-bit simple reads and writes are supported
within an interrupt file&#8217;s memory region. Writes to read-only bytes are
ignored. For other forms of accesses (other sizes, misaligned accesses,
or AMOs), an IMSIC implementation should preferably report an access
fault or bus error but must otherwise ignore the access.</p>
</div>
<div class="paragraph">
<p>If \(i\) is an implemented interrupt identity number, writing
valueÂ \(i\) in little-endian byte order to <code>seteipnum_le</code> (Set External Interrupt-Pending bit by Number, Little-Endian) causes the pending bit for interruptÂ \(i\) to be set to one. A write to <code>seteipnum_le</code> is ignored if the value written is not an implemented interrupt identity number in little-endian byte order.</p>
</div>
<div class="paragraph">
<p>For systems that support big-endian byte order, if \(i\) is an
implemented interrupt identity number, writing value \(i\) in
big-endian byte order to <code>seteipnum_be</code> (Set External Interrupt-Pending bit by Number, Big-Endian) causes the pending bit for interrupt \(i\) to be set to one. A write to <code>seteipnum_be</code> is ignored if the value written is not an implemented interrupt identity number in big-endian byte order. Systems that support only little-endian byte order may choose to ignore all
writes to <code>seteipnum_be</code>.</p>
</div>
<div class="paragraph">
<p>In most systems, <code>seteipnum_le</code> is the write port for MSIs directed to this interrupt file. For systems built mainly for big-endian byte order, <code>seteipnum_be</code> may serve as the write port for MSIs directed to this interrupt file from some devices.</p>
</div>
<div class="paragraph">
<p>A read of <code>seteipnum_le</code> or <code>seteipnum_be</code> returns zero in all cases.</p>
</div>
<div class="paragraph">
<p>When not ignored, writes to an interrupt file&#8217;s memory region are
guaranteed to be reflected in the interrupt file eventually, but not
necessarily immediately. For a single interrupt file, the effects of
multiple writes (stores) to its memory region, though arbitrarily
delayed, always occur in the same order as the <em>global memory order</em> of
the stores as defined by the RISC-V Unprivileged ISA.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In most circumstances, any delay between the completion of a write to an
interrupt file&#8217;s memory region and the effect of the write on the
interrupt file is indistinguishable from other delays in the memory
system. However, if a hart writes to a <code>seteipnum_le</code> or <code>seteipnum_be</code> register of its own IMSIC, then a delay between the completion of the store instruction and the consequent setting of an interrupt-pending bit in the interrupt file may be visible to the hart.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="IMSIC-systemMemRegions"><a class="anchor" href="#IMSIC-systemMemRegions"></a>3.6. Arrangement of the memory regions of multiple interrupt files</h3>
<div class="paragraph">
<p>Each interrupt file that an IMSIC implements has its own memory region
as described in the previous section, occupying exactly one 4-KiB page
of machine address space. When practical, the memory pages of the
machine-level interrupt files of all IMSICs should be located together
in one part of the address space, and the memory pages of all
supervisor-level and guest interrupt files should similarly be located
together in another part of the address space, according to the rules
below.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The main reason for separating the machine-level interrupt files from
the other interrupt files in the address space is so harts that
implement physical memory protection (PMP) can grant supervisor-level
access to all supervisor-level and guest interrupt files using only a
single PMP table entry. If the memory pages for machine-level interrupt
files are instead interleaved with those of lower-privilege interrupt
files, the number of PMP table entries needed for granting
supervisor-level access to all non-machine-level interrupt files could
equal the number of harts in the system.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If a machine&#8217;s construction dictates that harts be subdivided into
groups, with each group relegated to its own portion of the address
space, then the best that can be achieved is to locate together the
machine-level interrupt files of each group of harts separately, and
likewise locate together the supervisor-level and guest interrupt files
of each group of harts separately. This situation is further addressed
later below.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A system may divide harts into groups in the address space because each
group exists on a separate chip (or chiplet in a multi-chip module), and
weaving together the address spaces of the multiple chips is
impractical. In that case, granting supervisor-level access to all
non-machine-level interrupt files takes one PMP table entry per group.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For the purpose of locating the memory pages of interrupt files in the
address space, assume each hart (or each hart within a group) has a
unique hart number that may or may not be related to the unique hart
identifiers ("hart IDs") that the Privileged Architecture
assigns to harts. For convenient addressing, the memory pages of all
machine-level interrupt files (or all those of a single group of harts)
should be arranged so that the address of the machine-level interrupt
file for hart number \(h\) is given by the formula
\({A+h\times{2}^{C}}\) for some integer constants
\(A\) and \(C\). If the largest hart number is
\(h_{\rm max}\), let
\({k = \lceil\log_{2}(h_{\rm max}+{1})\rceil}\), the
number of bits needed to represent any hart number. Then the base
address \(A\) should be aligned to a
\({2}^{k+C}\) address boundary, so
\({A+h\times{2}^{C}}\) always equals
\(A\) | \({(h\times{2}^{C})}\), where the
vertical bar (|) represents bitwise logical OR.</p>
</div>
<div class="paragraph">
<p>The smallest that \(C\) can be is 12, with
\({2}^{C}\) being the size of one 4-KiB page. If
\({C &gt; 12}\), the start of the memory page for each
machine-level interrupt file is aligned not just to a 4-KiB page but to
a stricter \({2}^{C}\) address boundary. Within the
\({{2}^{k+C}}\)-size address range \(A\)
through \({A+{2}^{k+C}-{1}}\), every 4-KiB page that
is not occupied by a machine-level interrupt file should be filled with
32-bit words of read-only zeros, such that any read of an aligned word
returns zero and any write to an aligned word is ignored.</p>
</div>
<div class="paragraph">
<p>The memory pages of all supervisor-level interrupt files (or all those
of a single group of harts) should similarly be arranged so that the
address of the supervisor-level interrupt file for hart
number \(h\) is \({B+h\times{2}^{D}}\) for some
integer constants \(B\) and \(D\), with the base
address \(B\) being aligned to a \({2}^{k+D}\)
address boundary.</p>
</div>
<div class="paragraph">
<p>If an IMSIC implements guest interrupt files, the memory pages for the
IMSIC&#8217;s supervisor-level interrupt file and for its guest interrupt
files should be contiguous, starting with the supervisor-level interrupt
file at the lowest address and followed by the guest interrupt files,
ordered by guest interrupt number. Schematically, the memory pages
should be ordered contiguously as</p>
</div>
<div class="paragraph">
<p>S, \({G}_{1}$\), \({G}_{2}\),
\({G}_{3}\), â€¦</p>
</div>
<div class="paragraph">
<p>where S is the page for the supervisor-level interrupt file and each
\({G}_{i}\) is the page for the interrupt file of guest
interrupt number \(i\). Consequently, the smallest that
constant \(D\) can be is
\({\lceil\log_{\rm 2}({maximum GEILEN}+{1})\rceil}+12\),
recalling that GEILEN for each IMSIC is the number of guest interrupt
files the IMSIC implements.</p>
</div>
<div class="paragraph">
<p>Within the \({{2}^{k+D}}\)-size address range
\(B\) through \({B+{2}^{k+D}-{1}}\), every
4-KiB page that is not occupied by an interrupt file (supervisor-level
or guest) should be filled with 32-bit words of read-only zeros.</p>
</div>
<div class="paragraph">
<p>When a system divides harts into groups, each in its own separate
portion of the address space, the memory page addresses of interrupt
files should follow the formulas
\({g\times{2}^{E}}A{h\times{2}^{C}}\) for
machine-level interrupt files, and
\({g\times{2}^{E}}B{h\times{2}^{D}}\) for
supervisor-level interrupt files, with \(g\) being a <em>group
number</em>, \(h\) being a hart number relative to the group, and
\(E\) being another integer constant
\(\geq\) \({k+\max(C,D)}\) but usually much larger.
If the largest group number is \(g_{\rm max}\), let
\({j = \lceil\log_{2}(g_{\rm max}+{1})\rceil}\), the
number of bits needed to represent any group number. Besides being
multiples of \({2}^{k+C}\) and
\({2}^{k+D}\) respectively, \(A\) and
\(B\) should be chosen so</p>
</div>
<div class="paragraph">
<p>\(((2^j-1)\times{2}^{E})\) &amp; \(A \,=\, 0\) and \(\left(({2}^{j}-{1})\times{2}^{E}\right)\) &amp; \(B \,=\, 0\)</p>
</div>
<div class="paragraph">
<p>where an ampersand (&amp;) represents bitwise logical AND. This ensures that</p>
</div>
<div class="paragraph">
<p>\(g\times{2}^{E}+A+h\times{2}^{C}\) always equals
(\(g\times{2}^{E}\)) | \(A\) | (\(h\times{2}^{C}\)), and<br>
\(g\times{2}^{E}+B+h\times{2}^{D}\) always equals (\(g\times{2}^{E}\)) | \(B\) |
(\(h\times{2}^{D}\)).</p>
</div>
<div class="paragraph">
<p>Infilling with read-only-zero pages is expected only within each group,
not between separate groups. Specifically, if \(g\) is any
integer between 0 and \({{2}^{j}-1}\) inclusive, then
within the address ranges,</p>
</div>
<div class="paragraph">
<p>\(g\times2^E+A\) through
\(g\times2^E+A+2^{k+C}-1\), and<br>
\(g\times2^E+B\) through
\(g\times2^E+B+2^{k+D}-1\),</p>
</div>
<div class="paragraph">
<p>pages not occupied by an interrupt file should be read-only zeros.</p>
</div>
<div class="paragraph">
<p>See also <a href="#AdvPLIC-MSIAddrs">Section 4.9.1</a> for the
default algorithms an Advanced PLIC may use to determine the destination
addresses of outgoing MSIs, which should be the addresses of IMSIC
interrupt files.</p>
</div>
</div>
<div class="sect2">
<h3 id="csrs-for-external-interrupts-via-an-imsic"><a class="anchor" href="#csrs-for-external-interrupts-via-an-imsic"></a>3.7. CSRs for external interrupts via an IMSIC</h3>
<div class="paragraph">
<p>Software accesses a hart&#8217;s IMSIC primarily through the CSRs introduced
in <a href="#CSRs">Chapter 2</a>. There is a separate set of CSRs for each
implemented privilege level that can receive interrupts. The
machine-level CSRs interact with the IMSIC&#8217;s machine-level interrupt
file, while, if supervisor mode is implemented, the supervisor-level
CSRs interact with the IMSIC&#8217;s supervisor-level interrupt file. When an
IMSIC has guest interrupt files, the VS CSRs interact with a single
guest interrupt file, selected by the VGEIN field of CSR <code>hstatus</code>.</p>
</div>
<div class="paragraph">
<p>For machine level, the relevant CSRs are <code>miselect</code>, <code>mireg</code>, and <code>mtopei</code>. When supervisor mode is implemented, the set of supervisor-level CSRs matches those of machine level: <code>siselect</code>, <code>sireg</code>, and <code>stopei</code>. And when the H extension is implemented, there are three corresponding VS CSRs: <code>vsiselect</code>, <code>vsireg</code>, and <code>vstopei</code>.</p>
</div>
<div class="paragraph">
<p>As explained in <a href="#CSRs">Chapter 2</a>, registers <code>miselect</code> and <code>mireg</code> provide indirect access to additional machine-level registers. Likewise for supervisor-level <code>siselect</code> and <code>sireg</code>, and VS-level <code>vsiselect</code> and <code>vsireg</code> . In each case, a value of the <strong><em>*iselect</em></strong> <em>CSR</em> (<code>miselect</code>, <code>siselect</code> , or <code>vsiselect)</code>) in the range 0x70-0xFF selects a register of the
corresponding IMSIC interrupt file, either the machine-level interrupt
file (<code>miselect</code>), the supervisor-level interrupt file (<code>siselect</code>), or a guest interrupt file (<code>vsiselect</code>).</p>
</div>
<div class="paragraph">
<p>Interrupt files at each level act identically. For a given privilege
level, values of the <code>*iselect</code> CSR in the range <code>0x70-0xFF</code> select these registers of the corresponding interrupt file:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x70</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>eidelivery</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x72</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>eithreshold</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x80</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>eip0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x81</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>eip1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8230;&#8203;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8230;&#8203;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xBF</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>eip63</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xC0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>eie0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xC1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>eie1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8230;&#8203;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8230;&#8203;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xFF</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>eie63</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Register numbers 0x71 and 0x73-0x7F are reserved. When an <code><em>*iselect</em></code> <em>CSR</em>  has one of these values, reads from the matching <code><em>*ireg</em></code> <em>CSR</em> (<code>mireg</code>, <code>sireg</code>, or <code>vsireg</code>) return zero, and writes to the <code><em>*ireg</em></code> <em>CSR</em> are ignored. (For <code>vsiselect</code> and <code>vsireg</code>, all accesses depend on <code>hstatus</code>.VGEIN being the valid number of a guest interrupt file.)</p>
</div>
<div class="paragraph">
<p>Registers <code>eip0</code> through <code>eip63</code> contain the pending bits for all implemented interrupt identities, and are collectively called the <code><em>eip</em></code> <em>array</em>. Registers <code>eie0</code> through <code>eie63</code> contain the enable bits for the same interrupt identities, and are collectively called the <code><em>eie</em></code> <em>array</em>.</p>
</div>
<div class="paragraph">
<p>The indirectly accessed interrupt-file registers and CSRs <code>mtopei</code>, <code>stopei</code>, and <code>vstopei</code> are all documented in more detail in the next two sections.</p>
</div>
</div>
<div class="sect2">
<h3 id="indirectly-accessed-interrupt-file-registers"><a class="anchor" href="#indirectly-accessed-interrupt-file-registers"></a>3.8. Indirectly accessed interrupt-file registers</h3>
<div class="paragraph">
<p>This section describes the registers of an interrupt file that are
accessed indirectly through a <code><em>*iselect</em></code> <em>CSR</em> (<code>miselect</code>, <code>siselect</code>, or <code>vsiselect</code>) and its partner <code><em>*ireg</em></code> <em>CSR</em> (<code>mireg</code>, <code>sireg</code>, or <code>vsireg</code>). The width of these indirect accesses is always the current XLEN,
32 bits for RV32 code, or 64 bits for RV64 code.</p>
</div>
<div class="sect3">
<h4 id="IMSIC-reg-eidelivery"><a class="anchor" href="#IMSIC-reg-eidelivery"></a>3.8.1. External interrupt delivery enable register (<code>eidelivery</code>)</h4>
<div class="paragraph">
<p><code>eidelivery</code> is a <strong>WARL</strong> register that controls whether interrupts from this interrupt file are delivered from the IMSIC to the attached hart so they appear as a pending external interrupt in the hart&#8217;s <code>mip</code> or <code>hgeip</code> CSR. Register <code>eidelivery</code> may optionally also support the direct delivery of interrupts from a PLIC (Platform-Level Interrupt Controller) or APLIC (Advanced PLIC) to the attached hart. Three possible values are currently defined for <code>eidelivery</code>:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">0 =</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interrupt delivery is disabled</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">1 =</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interrupt delivery from the interrupt file is enabled</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">0x40000000 =</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interrupt delivery from a PLIC or APLIC is enabled (optional)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>If <code>eidelivery</code> supports value 0x40000000, then a specific PLIC or APLIC in the system may act as an alternate external interrupt controller for the attached hart at the same privilege level as this interrupt file. When <code>eidelivery</code> is 0x40000000, the interrupt file functions the same as though <code>eidelivery</code> is 0, and the PLIC or APLIC replaces the interrupt file in supplying pending external interrupts at this privilege level at the hart.</p>
</div>
<div class="paragraph">
<p>Guest interrupt files do not support value 0x40000000 for <code>eidelivery</code>.</p>
</div>
<div class="paragraph">
<p>Reset initializes <code>eidelivery</code> to 0x40000000 if that value is supported; otherwise, <code>eidelivery</code> has an UNSPECIFIED valid value (0 or 1) after reset.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>eidelivery</code> value 0x40000000 supports system software that is oblivious to IMSICs and assumes instead that the external interrupt controller is a PLIC or APLIC. Such software may exist either because it predates the existence of IMSICs or because bypassing IMSICs is believed to reduce programming effort.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>eidelivery</code> register affects only whether
an external interrupt appears in a hart&#8217;s <code>*ip</code> register
(MEI or SEI in <code>mip</code> or <code>sip</code>, or a bit in <code>hgeip</code>) and what
the source of such an interrupt may be (either the interrupt file
or a separate external interrupt controller such as an APLIC).
It has no effect on other state within the interrupt file,
or on any <code>*topei</code> CSR (<code>mtopei</code>, <code>stopei</code>, or <code>vstopei</code>).</p>
</div>
</div>
<div class="sect3">
<h4 id="external-interrupt-enable-threshold-register-eithreshold"><a class="anchor" href="#external-interrupt-enable-threshold-register-eithreshold"></a>3.8.2. External interrupt enable threshold register (<code>eithreshold</code>)</h4>
<div class="paragraph">
<p><code>eithreshold</code> is a <strong>WLRL</strong> register that determines the minimum interrupt priority (maximum interrupt identity number) allowing an interrupt to be signaled from this interrupt file to the attached hart. If \(N\) is the maximum implemented interrupt identity number for this interrupt file,
<code>eithreshold</code> must be capable of holding all values between 0 and \(N\),
inclusive.</p>
</div>
<div class="paragraph">
<p>When <code>eithreshold</code> is a nonzero value \(P\), interrupt identities
\(P\) and higher do not contribute to signaling interrupts, as
though those identities were not enabled, regardless of the settings of
their corresponding interrupt-enable bits in the <code>eie</code> array. When <code>eithreshold</code> is zero, all enabled interrupt identities contribute to signaling interrupts from
the interrupt file.</p>
</div>
</div>
<div class="sect3">
<h4 id="external-interrupt-pending-registers-eip0-eip63"><a class="anchor" href="#external-interrupt-pending-registers-eip0-eip63"></a>3.8.3. External interrupt-pending registers (<code>eip0</code>-<code>eip63</code>)</h4>
<div class="paragraph">
<p>When the current XLEN = 32, register <code>eip</code>\(k\) contains the
pending bits for interrupts with identity numbers
\(k\times{32}\) through
\({k\times{32} + {31}}\). For an implemented
interrupt identity \(i\) within that range, the pending bit
for interruptÂ \(i\) is bit \((i\bmod{32})\) of <code>eip</code>\(k\).</p>
</div>
<div class="paragraph">
<p>When the current XLEN = 64, the odd-numbered registers <code>eip1</code>, <code>eip3</code>, â€¦ <code>eip63</code> do not
exist. In that case, if the <code>*iselect</code> CSR is an odd value in the range 0x81â€“0xBF, an
attempt to access the matching <code>*ireg</code> CSR raises an illegal instruction
exception, unless done in VS-mode, in which case it raises a virtual
instruction exception. For even \(k\), register <code>eip</code>\(k\) contains the pending bits for interrupts with identity
numbers \(k\times{32}\) through
\({k\times{32} + {63}}\). For an implemented
interrupt identityÂ \(i\) within that range, the pending bit
for interruptÂ \(i\) is bit \((i\bmod{64})\) of <code>eip</code>\(k\).</p>
</div>
<div class="paragraph">
<p>Bit positions in a valid <code>eip</code>\(k\) register that don&#8217;t correspond
to a supported interrupt identity (such as bit 0 of <code>eip0</code>) are read-only
zeros.</p>
</div>
</div>
<div class="sect3">
<h4 id="external-interrupt-enable-registers-eie0-eie63"><a class="anchor" href="#external-interrupt-enable-registers-eie0-eie63"></a>3.8.4. External interrupt-enable registers (<code>eie0</code>-<code>eie63</code>)</h4>
<div class="paragraph">
<p>When the current XLEN = 32, register <code>eie</code>\(k\) contains the enable
bits for interrupts with identity numbers \(k\times{32}\)
through \({k\times{32} + {31}}\). For an implemented
interrupt identity \(i\) within that range, the enable bit for
interrupt \(i\) is bit (\(i\bmod{32}\)) of <code>eie</code>\(k\).</p>
</div>
<div class="paragraph">
<p>When the current XLEN = 64, the odd-numbered registers <code>eie1</code>, <code>eie3</code>, â€¦ <code>eie63</code> do not
exist. In that case, if the <code>*iselect</code> CSR is an odd value in the range <code>0xC1</code>â€“<code>0xFF</code>, an
attempt to access the matching <code>*ireg</code> CSR raises an illegal instruction
exception, unless done in VS-mode, in which case it raises a virtual
instruction exception. For evenÂ \(k\), register
<code>eie</code>\(k\) contains the enable bits for interrupts with identity
numbers \(k\times{32}\) through
\({k\times{32} + {63}}\). For an implemented
interrupt identityÂ \(i\) within that range, the enable bit for
interruptÂ \(i\) is bit (\(i\bmod{64}\)) of <code>eie</code>\(k\).</p>
</div>
<div class="paragraph">
<p>Bit positions in a valid <code>eie</code>\(k\) register that don&#8217;t correspond
to a supported interrupt identity (such as bit 0 of <code>eie0</code>) are read-only
zeros.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="top-external-interrupt-csrs-mtopei-stopei-vstopei"><a class="anchor" href="#top-external-interrupt-csrs-mtopei-stopei-vstopei"></a>3.9. Top external interrupt CSRs (<code>mtopei</code>, <code>stopei</code>, <code>vstopei</code>)</h3>
<div class="paragraph">
<p>CSR <code>mtopei</code> interacts directly with an IMSIC&#8217;s machine-level interrupt file. If
supervisor mode is implemented, CSR <code>stopei</code> interacts directly with the
supervisor-level interrupt file. And if the H extension is
implemented and field VGEIN of <code>hstatus</code> is the number of an implemented guest
interrupt file, <code>vstopei</code> interacts with the chosen guest interrupt file.</p>
</div>
<div class="paragraph">
<p>The value of a <code><em>*topei</em></code> <em>CSR</em> (<code>mtopei</code>, <code>stopei</code>, or <code>vstopei</code>) indicates the interrupt file&#8217;s current highest-priority pending-and-enabled interrupt that also exceeds the priority threshold specified by its <code>eithreshold</code> register if <code>eithreshold</code> is not zero. Interrupts with lower identity numbers have higher priorities.</p>
</div>
<div class="paragraph">
<p>A read of a <code>*topei</code> CSR returns zero either if no interrupt is both pending in the interrupt file&#8217;s <code>eip</code> array and enabled in its <code>eie</code> array, or if <code>eithreshold</code> is not zero and no pending-and-enabled interrupt has an identity number less than the value of <code>eithreshold</code>. Otherwise, the value returned from a read of <code>*topei</code> has this format:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">bits 26:16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interrupt identity</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">bits 10:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interrupt priority (same as identity)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>All other bit positions are zeros.</p>
</div>
<div class="paragraph">
<p>The interrupt identity reported in a <code>*topei</code> CSR is the minor identity for an
external interrupt at the hart.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The redundancy in the value read from a <code>*topei</code> CSR is consistent with the
Advanced PLIC, which returns both an interrupt identity number and its
priority in the same format as above, but with the two components being
independent of one another.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The value of a <code>*topei</code> CSR is not affected by an interrupt file&#8217;s
<code>eidelivery</code> register or by any of <code>mie</code>, <code>sie</code>, <code>hie</code>, <code>hgeie</code>, or <code>vsie</code>.</p>
</div>
<div class="paragraph">
<p>A write to a <code>*topei</code> CSR <em>claims</em> the reported interrupt identity by clearing
its pending bit in the interrupt file. The value written is ignored;
rather, the current readable value of the register determines which
interrupt-pending bit is cleared. Specifically, when a <code>*topei</code> CSR is written, if the register value has interrupt identity \(i\) in bits
26:16, then the interrupt file&#8217;s pending bit for interrupt \(i\) is cleared. When a <code>*topei</code> CSR&#8217;s value is zero, a write to the register has no effect.</p>
</div>
<div class="paragraph">
<p>If a read and write of a <code>*topei</code> CSR are done together by a single CSR
instruction (CSRRW, CSRRS, or CSRRC), the value returned by the read
indicates the pending bit that is cleared.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It is almost always a mistake to write to a <code>*topei</code> CSR without a simultaneous
read to learn which interrupt was claimed. Note especially, if a read of
a <code>*topei</code> register and a subsequent write to the register are done by two
separate CSR instructions, then a higher-priority interrupt may become
newly pending-and-enabled in the interrupt file between the two
instructions, causing the write to clear the pending bit of the new
interrupt and not the one reported by the read. Once the pending bit of
the new interrupt is cleared, the interrupt is lost.</p>
</div>
<div class="paragraph">
<p>If it is necessary first to read a <code>*topei</code> CSR and then subsequently claim the
interrupt as a separate step, the claim can be safely done by clearing
the pending bit in the <code>eip</code> array via <code>*siselect</code> and <code>*sireg</code>, instead of writing to <code>*topei</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="interrupt-delivery-and-handling"><a class="anchor" href="#interrupt-delivery-and-handling"></a>3.10. Interrupt delivery and handling</h3>
<div class="paragraph">
<p>An IMSIC&#8217;s interrupt files supply <em>external interrupt</em> signals to the
attached hart, one interrupt signal per interrupt file. The interrupt
signal from a machine-level interrupt file appears as bit MEIP in CSR <code>mip</code>,
and the interrupt signal from a supervisor-level interrupt file appears
as bit SEIP in <code>mip</code> and <code>sip</code>. Interrupt signals from any guest interrupt files appear as the active bits in hypervisor CSR <code>hgeip</code>.</p>
</div>
<div class="paragraph">
<p>When interrupt delivery is disabled by an interrupt file&#8217;s <code>eidelivery</code> register (<code>eidelivery</code> = 0), the interrupt signal from the interrupt file is held de-asserted (false). When interrupt delivery from an interrupt file is enabled (<code>eidelivery</code> = 1), its interrupt signal is asserted if and only if the interrupt file has a pending-and-enabled interrupt that also exceeds the priority threshold specified by <code>eithreshold</code>, if not zero.</p>
</div>
<div class="paragraph">
<p>Changes to the state of an interrupt file are guaranteed
to be reflected in the relevant interrupt-pending bit in CSR
<code>mip</code> or <code>hgeip</code> eventually, but not necessarily immediately.</p>
</div>
<div class="paragraph">
<p>A trap handler solely for external interrupts via an IMSIC could be
written roughly as follows:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">save processor registers</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>i</code>=read CSR <code>mtopei</code> or <code>stopei</code>, and write simultaneously to claim the interrupt</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>i</code>= <code>i&gt;&gt;16</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">call the interrupt handler for external interrupt <code>i</code> (minor identity)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">restore processor registers</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">return from trap</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The combined read and write of <code>mtopei</code> or <code>stopei</code> in the second step can be done by a single CSRRW machine instruction,</p>
</div>
<div class="paragraph">
<p><code>csrrw</code> <em>rd</em>, <code>mtopei/stopei</code>, <code>x0</code></p>
</div>
<div class="paragraph">
<p>where <em>rd</em> is the destination register for value <em>i</em>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="AdvPLIC"><a class="anchor" href="#AdvPLIC"></a>4. Advanced Platform-Level Interrupt Controller (APLIC)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In a RISC-V system, a Platform-Level Interrupt Controller (PLIC) handles
external interrupts that are signaled through wires rather than by MSIs.
When the RISC-V harts in a system do not have IMSICs, the harts themselves do
not support MSIs, and all external interrupts to such harts must pass
through a PLIC. But even in machines where harts have IMSICs and most
interrupts are communicated via MSIs, it is not unusual for some device
interrupts still to be signaled by dedicated wires. In particular, for
devices (or device controllers) that do not otherwise need to initiate
bus transactions in the system, the cost of supporting MSIs is
especially high, so wired interrupts are a frugal alternative. Wired
interrupts also continue to be universally supported by all current
computer platforms, unlike MSIs, making another reason for many
commodity devices or controllers to choose wired interrupts over MSIs,
unless conforming to a standard like PCI Express that dictates MSIs.</p>
</div>
<div class="paragraph">
<p>This chapter specifies an <em>Advanced PLIC</em> (APLIC) that is not backward
compatible with the earlier RISC-V PLIC. Full conformance to the Advanced
Interrupt Architecture requires the APLIC. However, a workable system
can be built substituting the older PLIC instead, assuming only wired
interrupts to harts, not MSIs.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>We intend eventually to provide a free example parameterized
implementation of an APLIC, written in portable SystemVerilog, that we
expect will be suitable for many RISC-V systems without modification.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A draft specification exists for a <em>Duo-PLIC</em> that is
software-configurable to act as either an original RISC-V PLIC or an APLIC.
However, at this time, it appears unlikely that RISC-V International will ever ratify the Duo-PLIC specification as a standard.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In a machine without IMSICs, every RISC-V hart accepts interrupts from exactly one PLIC or APLIC that is the <em>external interrupt controller</em> for that
hart. A hartâ€™s external interrupt controller (the PLIC or APLIC) signals
interrupts to the hart through a dedicated connection, usually a wire,
for each privilege level that the hart may receive interrupts. (Recall
<a href="#intrsWithoutIMSICs">Figure 1</a>). A
system without IMSICs will typically have only one PLIC or APLIC,
serving as the external interrupt controller for all RISC-V harts.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Because every RISC-V hart without an IMSIC has exactly one PLIC or APLIC as its
external interrupt controller, a system with multiple APLICs must
partition the harts into disjoint subsets, making each APLIC the
external interrupt controller for a separate subset of the harts. While
not prohibited, this arrangement is likely to be less efficient than
having all harts share a single APLIC.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>RISC-V harts that employ IMSICs as their external interrupt controllers can
receive external interrupts only in the form of MSIs. In that case, the
role of an APLIC is to convert wired interrupts into MSIs for harts.
(Recall <a href="#intrsWithIMSICs">Figure 2</a>.)
The APLIC is said to <em>forward</em> incoming wire-signaled interrupts to
harts by sending MSIs to the harts.</p>
</div>
<div class="paragraph">
<p>When harts have IMSICs to support MSIs, a system may easily contain
multiple APLICs for converting wired interrupts into MSIs, with each
APLIC forwarding interrupts from a different subset of devices. Multiple
APLICs are presumably more likely to arise when groups of devices are
physically distant from one another, perhaps even on separate chips
(including chiplets in a multi-chip module).</p>
</div>
<div class="sect2">
<h3 id="interrupt-sources-and-identities"><a class="anchor" href="#interrupt-sources-and-identities"></a>4.1. Interrupt sources and identities</h3>
<div class="paragraph">
<p>An individual APLIC supports a fixed number of <em>interrupt sources</em>,
corresponding exactly with the set of physical incoming interrupt wires
at the APLIC. Most often, each sourceâ€™s incoming wire is connected to
the output interrupt wire from a single device or device controller.
(For level-sensitive interrupts, the interrupt outputs of multiple
devices or controllers may be combined to drive the incoming wire of a
single interrupt source at an APLIC. An interrupt sourceâ€™s incoming wire
might also be simply tied high or low, if, for example, the source will
always be configured as Detached. See
<a href="#AdvPLIC-reg-sourcecfg">Section 4.5.2</a> for a description of <em>source
modes</em>.)</p>
</div>
<div class="paragraph">
<p>Each of an APLIC&#8217;s interrupt sources has a fixed unique <em>identity
number</em> in the range 1 to \(N\), where \(N\) is the
total number of sources at the APLIC. The number zero is not a valid
interrupt identity number at an APLIC. The maximum number of interrupt
sources an APLIC may support is 1023.</p>
</div>
<div class="paragraph">
<p>When an APLIC delivers interrupts directly to harts at a given privilege
level (rather than forwarding interrupts as MSIs), the APLIC is the
external interrupt controller for the harts at that privilege level, and
the interrupt identities at the APLIC become directly the <em>minor
identities</em> for external interrupts at the harts.</p>
</div>
<div class="paragraph">
<p>On the other hand, when an APLIC forwards interrupts by MSIs, software
configures a new interrupt identity number for the outgoing MSIs of each
source. Consequently, in this case, the source identity numbers at a
given APLIC only distinguish the incoming interrupts at the APLIC and
have no relevance outside the APLIC.</p>
</div>
</div>
<div class="sect2">
<h3 id="interrupt-domains"><a class="anchor" href="#interrupt-domains"></a>4.2. Interrupt domains</h3>
<div class="paragraph">
<p>An APLIC supports one or more <em>interrupt domains</em>, each associated with
a subset of RISC-V harts at one privilege level (machine or supervisor level).
The harts within an interrupt domain are those that the domain can
interrupt at the corresponding privilege level. Each domain has its own
memory-mapped control region in the machineâ€™s address space that appears
to control a complete, separate APLIC, though in fact all domain
interfaces together access a single combined interrupt controller.</p>
</div>
<div class="paragraph">
<p><a href="#AdvPLIC-ex-1Domain">Figure 3</a> through
<a href="#AdvPLIC-ex-3Domains">Figure 5</a> depict some possible hierarchies of
interrupt domains implemented by an APLIC in a RISC-V system.</p>
</div>
<div class="paragraph">
<p>The first figure represents a minimal system that has a single hart not
supporting supervisor mode, with a single interrupt domain for machine
level on that hart. The next figure, <a href="#AdvPLIC-ex-2Domains">Figure 4</a>,
shows a basic arrangement for a larger system designed for symmetric
multiprocessing (SMP), with multiple harts that all implement supervisor
mode. In such cases, the APLIC will usually provide a separate interrupt
domain for supervisor level, as the figure portrays. This
supervisor-level interrupt domain allows an operating system, running in
S-mode on the multiple harts, to have direct control over the interrupts
it receives, avoiding the need to call upon M-mode to exercise that
control.</p>
</div>
<div id="AdvPLIC-ex-1Domain" class="imageblock unresolved">
<div class="content">
<img src="AdvPLIC-ex-1Domain.png" alt="AdvPLIC ex 1Domain">
</div>
<div class="title">Figure 3. Example of a RISC-V system that has a single hart implementing only M-mode, with a single machine-level interrupt domain for that hart.</div>
</div>
<div class="paragraph">
<p>An APLIC&#8217;s interrupt domains are arranged in a tree hierarchy, with the
root domain always being at machine level. Incoming interrupt wires
arrive first at the root domain. Each domain may then selectively
delegate all or a subset of interrupt sources to its child domains in
the hierarchy. Within a given APLIC, interrupt source numbers are
invariant across all domains, so source identity number \(i\)
always refers to the same source in every domain, corresponding to
incoming wire number \(i\). For an interrupt domain below the
root, interrupt sources not delegated down to that domain appear to the
domain as being not implemented.</p>
</div>
<div class="paragraph">
<p><a href="#AdvPLIC-ex-3Domains">Figure 5</a> shows a hierarchy of three
interrupt domains, two at machine level and one at supervisor level. The
arrangement in the figure, when combined with PMP (physical memory
protection), allows machine-level software to isolate a selection of
interrupts exclusively for hart 0, beyond the reach of the four
application harts, even at machine level.</p>
</div>
<div id="AdvPLIC-ex-2Domains" class="imageblock unresolved">
<div class="content">
<img src="AdvPLIC-ex-2Domains.png" alt="AdvPLIC ex 2Domains">
</div>
<div class="title">Figure 4. An example system with four harts that implement M-mode and S-mode, with two APLIC interrupt domains, one each for machine and supervisor levels.</div>
</div>
<div id="AdvPLIC-ex-3Domains" class="imageblock unresolved">
<div class="content">
<img src="AdvPLIC-ex-3Domains.png" alt="AdvPLIC ex 3Domains">
</div>
<div class="title">Figure 5. A RISC-V system that extends the example of <a href="#AdvPLIC-ex-2Domains">Figure 4</a> with a fifth M-mode-only "manager" hart, with a separate machine-level interrupt domain above the other domains.</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In order for the harts within an interrupt domain to have direct control
over the interrupts from the domain, the harts must be cooperatively
controlled by software at the same privilege level. In particular, a
single operating system should control all of the harts associated with
a supervisor-level interrupt domain. In the examples of <a href="#AdvPLIC-ex-2Domains">Figure 4</a> and <a href="#AdvPLIC-ex-3Domains">Figure 5</a>, control
of the APLIC&#8217;s supervisor-level interrupt domain could not be safely
split among multiple independent OSes.</p>
</div>
<div class="paragraph">
<p>Given the domain hierarchies depicted in the figures, if it were
necessary to partition the application harts for multiple OSes,
machine-level software would need to prevent direct OS access to the
supervisor-level interrupt domain and instead provide SBI services for
controlling APLIC interrupts or, alternatively, emulate the control
interfaces of separate supervisor-level interrupt domains, one for each
OS. Note that such emulation might still make use of the APLIC&#8217;s
physical supervisor-level interrupt domain, but under the control of
machine-level software.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>An APLIC&#8217;s interrupt domain hierarchy satisfies these rules:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The root domain is at machine level.</p>
</li>
<li>
<p>The parent of any supervisor-level interrupt domain is a machine-level
domain that includes at least the same harts (but at machine level,
obviously). The parent domain may have a larger set of harts at machine
level.</p>
</li>
<li>
<p>For each interrupt domain, interrupts from the domain are signaled to
harts all by the same method, either by wire or by MSIs, not by a
mixture of methods among the harts.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When a RISC-V hart&#8217;s external interrupt controller is an APLIC, not an IMSIC,
the hart can be within only one interrupt domain of this APLIC at each
privilege level.</p>
</div>
<div class="paragraph">
<p>On the other hand, a hart that has an IMSIC for its external interrupt
controller may, at each privilege level, be in multiple APLIC interrupt
domains, even those of the same APLIC, and may potentially receive MSIs
from multiple different APLICs in the machine.</p>
</div>
<div class="paragraph">
<p>A platform might give software a way to choose between multiple
interrupt domain hierarchies for any given APLIC. Any such
configurability is outside the scope of this specification, but should
be available to machine level only.</p>
</div>
</div>
<div class="sect2">
<h3 id="hart-index-numbers"><a class="anchor" href="#hart-index-numbers"></a>4.3. Hart index numbers</h3>
<div class="paragraph">
<p>Within a given interrupt domain, each of the domainâ€™s harts has a unique
<em>index number</em> in the range 0 to \({{2}^{14}-{1}}\)
(= 16,383). The index number a domain associates with a hart may or may
not have any relationship to the unique hart identifier ("hart ID")
that the Privileged Architecture assigns to the hart. Two different
interrupt domains may employ a different mapping of index numbers to the
same set of harts. However, if any of an APLIC&#8217;s interrupt domains can
forward interrupts by MSI, then all machine-level domains of the APLIC
share a common mapping of index numbers to harts.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>For efficiency, implementations should prefer small integers for hart
index numbers.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="overview-of-interrupt-control-for-a-single-domain"><a class="anchor" href="#overview-of-interrupt-control-for-a-single-domain"></a>4.4. Overview of interrupt control for a single domain</h3>
<div class="paragraph">
<p>Each interrupt domain implemented by an APLIC has its own separate
physical control interface that is memory-mapped in the machineâ€™s
address space, allowing access to each domain to be easily regulated by
both PMP (physical memory protection) and page-based address
translation. The control interfaces of all interrupt domains have a
common structure. In most respects, every domain appears to software as
though it were a root domain, without visibility of the domains above it
in the hierarchy.</p>
</div>
<div class="paragraph">
<p>An individual interrupt domain has the following components for each
interrupt source at the APLIC:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Source configuration. This determines whether the specific source is
active in the domain and, if so, how the incoming wire is to be
interpreted, such as level-sensitive or edge-sensitive. For a source
that is inactive in the domain, source configuration controls any
delegation to a child domain.</p>
</li>
<li>
<p>Interrupt-pending and interrupt-enable bits. For an inactive source,
these two bits are read-only zeros. Otherwise, the pending bit records
an interrupt that arrived and has not yet been signaled or forwarded,
while the enable bit determines whether interrupts from this source
should currently be delivered, or should remain pending.</p>
</li>
<li>
<p>Target selection. For an active source, target selection determines
the hart to receive the interrupt and either the interrupt&#8217;s priority or
the new interrupt identity when forwarding as an MSI.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For interrupt domains that deliver interrupts directly to harts rather
than forwarding by MSIs, the domain has a final set of components for
controlling interrupt delivery to harts, one instance per hart in the
domain.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Although an APLIC with multiple interrupt domains may appear to
duplicate the per-source state listed above (source configuration,
etc.) by a factor equal to the number of domains, in fact, APLIC
implementations can exploit the fact that each source is ultimately
active in only one domain. In all domains to which a specific interrupt
source has not been delegated, the state associated with the source
appears as read-only zeros, requiring no physical register bits.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="AdvPLIC-domainControlRegion"><a class="anchor" href="#AdvPLIC-domainControlRegion"></a>4.5. Memory-mapped control region for an interrupt domain</h3>
<div class="paragraph">
<p>For each interrupt domain that an APLIC supports, there is a dedicated
memory-mapped control region for managing interrupts in that domain.
This control region is a multiple of 4 KiB in size and aligned to a
4-KiB address boundary. The smallest valid control region is 16 KiB. An
interrupt domain&#8217;s control region is populated by a set of 32-bit
registers. The first 16 KiB contains the registers listed in
<a href="#TableAdvPLIC-domainControlRegion">Table 6</a>.</p>
</div>
<table id="TableAdvPLIC-domainControlRegion" class="tableblock frame-none grid-none fit-content center">
<caption class="title">Table 6. The registers of the first 16 KiB of an interrupt domain&#8217;s memory-mapped control region.</caption>
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">offset</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">size</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">register name</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x0000</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>domaincfg</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x0004</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sourcecfg[1]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x0008</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sourcecfg[2]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">â€¦</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">â€¦</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x0FFC</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sourcecfg[1023]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1BC0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mmsiaddrcfg</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(machine-level interrupt domains only)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1BC4</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mmsiaddrcfgh</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">â€</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1BC8</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>smsiaddrcfg</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">â€</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1BCC</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>smsiaddrcfgh</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">â€</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1C00</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>setip[0]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1C04</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>setip[1]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">â€¦</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">â€¦</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1C7C</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>setip[31]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1CDC</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>setipnum</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1D00</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>in_clrip[0]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1D04</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>in_clrip[1]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">â€¦</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">â€¦</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1D7C</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>in_clrip[31]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1DDC</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>clripnum</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1E00</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>setie[0]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1E04</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>setie[1]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">â€¦</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">â€¦</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1E7C</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>setie[31]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1EDC</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>setienum</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1F00</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>clrie[0]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1F04</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>clrie[1]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">â€¦</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">â€¦</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1F7C</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>clrie[31]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1FDC</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>clrienum</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x2000</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>setipnum_le</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x2004</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>setipnum_be</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x3000</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>genmsi</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x3004</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>target[1]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x3008</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>target[2]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">â€¦</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">â€¦</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x3FFC</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>target[1023]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Starting at offset <code>0x4000</code>, an interrupt domain&#8217;s control region may optionally
have an array of <em>interrupt delivery control</em> (IDC) structures, one for
each potential hart index number in the range 0 to some maximum that is
at least as large as the maximum hart index number for the interrupt
domain. IDC structures are used only when the domain is configured to
deliver interrupts directly to harts instead of being forwarded by MSIs.
An interrupt domain that supports only interrupt forwarding by MSIs and
not the direct delivery of interrupts by the APLIC does not need IDC
structures in its control region.</p>
</div>
<div class="paragraph">
<p>The first IDC structure, if any, is for the hart with index number 0;
the second is for the hart with index number 1; and so forth. Each IDC
structure is 32 bytes and has these defined registers:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">offset</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">size</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">register name</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x00</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>idelivery</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x04</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iforce</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x08</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ithreshold</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x18</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>topi</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>ox1C</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>claimi</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>IDC structures are packed contiguously, 32 bytes per structure, so the
offset from the beginning of an interrupt domain&#8217;s control region to its
second IDC structure (hart index 1), if it exists, is <code>0x4020</code>; the offset to
the third IDC structure (hart index 2), if it exists, is <code>0x4040</code>; etc.</p>
</div>
<div class="paragraph">
<p>The array of IDC structures may include some for <em>potential</em> hart index
numbers that are not <em>actual</em> hart index numbers in the domain. For
example, the first IDC structure is always for hart index 0, but 0 is
not necessarily a valid index number for any hart in the domain. For
each IDC structure in the array that does not correspond to a valid hart
index number in the domain, the IDC structure&#8217;s registers may (or may
not) be all read-only zeros.</p>
</div>
<div class="paragraph">
<p>Aside from the registers in
<a href="#TableAdvPLIC-domainControlRegion">Table 6</a>
and those listed above for IDC structures, all other bytes in an
interrupt domain&#8217;s control region are reserved and are implemented as
read-only zeros.</p>
</div>
<div class="paragraph">
<p>Only naturally aligned 32-bit simple reads and writes are supported
within an interrupt domain&#8217;s control region. Writes to read-only bytes
are ignored. For other forms of accesses (other sizes, misaligned
accesses, or AMOs), implementations should preferably report an access
fault or bus error but must otherwise ignore the access.</p>
</div>
<div class="paragraph">
<p>The registers of the first 16 KiB of an interrupt domain&#8217;s control
region (all but the IDC structures) are documented individually below.
IDC structures are documented later, in
<a href="#AdvPLIC-directMode">Section 4.8</a>, "Interrupt delivery directly by
the APLIC."</p>
</div>
<div class="sect3">
<h4 id="AdvPLIC-reg-domaincfg"><a class="anchor" href="#AdvPLIC-reg-domaincfg"></a>4.5.1. Domain configuration (<code>domaincfg</code>)</h4>
<div class="paragraph">
<p>The <code>domaincfg</code> register has this format:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 31:24</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">read-only 0x80</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bit 8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bit 7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">read-only 0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bit 2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DM (<strong>WARL</strong>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bit 0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BE (<strong>WARL</strong>)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>All other register bits are reserved and read as zeros.</p>
</div>
<div class="paragraph">
<p>Bit IE (Interrupt Enable) is a global enable for all active interrupt
sources at this interrupt domain. Only when IE = 1 are
pending-and-enabled interrupts actually signaled or forwarded to harts.</p>
</div>
<div class="paragraph">
<p>The value of bit IE affects only whether interrupts are delivered to harts.
It has no effect on any other APLIC state, including
the interrupt-enable and interrupt-pending bits of interrupt sources
and IDC registers <code>idelivery</code>, <code>topi</code>, and <code>claimi</code>.</p>
</div>
<div class="paragraph">
<p>Field DM (Delivery Mode) is <strong>WARL</strong> and determines how this interrupt domain
delivers interrupts to harts. The two possible values for DM are:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">0 =</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">direct delivery mode</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">1 =</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MSI delivery mode</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>In <em>direct delivery mode</em>, interrupts are prioritized and signaled
directly to harts by the APLIC itself. In <em>MSI delivery mode</em>,
interrupts are forwarded by the APLIC as MSIs to harts, presumably for
further handling by IMSICs at those harts. A given APLIC implementation
may support either or both of these delivery modes for each interrupt
domain.</p>
</div>
<div class="paragraph">
<p>If the interrupt domain&#8217;s harts have IMSICs, then unless the relevant
interrupt files of those IMSICs support value <code>0x40000000</code> for register <code>eidelivery</code>, setting DM
to zero (direct delivery mode) will have the same effect as setting IE
to zero. See <a href="#IMSIC-reg-eidelivery">Section 3.8.1</a>
and <a href="#AdvPLIC-directMode-intrDelivery">Section 4.8.2</a>.</p>
</div>
<div class="paragraph">
<p>BE (Big-Endian) is a <strong>WARL</strong> field that determines the byte order for most
registers in the interrupt domain&#8217;s memory-mapped control region. If
BE = 0, byte order is little-endian, and if BE = 1, it is big-endian.
For RISC-V systems that support only little-endian, BE may be read-only zero,
and for those that support only big-endian, BE may be read-only one. For
bi-endian systems, BE is writable.</p>
</div>
<div class="paragraph">
<p>Field BE affects the byte order of accesses to the <code>domaincfg</code> register itself, just
as for other registers in the interrupt domainâ€™s control region. To deal
with this fact, the read-only value in <code>domaincfgâ€™s</code> most-significant byte, bits
31:24, serves two purposes. First, for any read of <code>domaincfg</code>, the register&#8217;s correct byte order is easily determined from the four-byte value
obtained: When interpreted in the correct byte order, bit 31 is one, and
in the wrong order, bit 31 is zero. Second, if the value of BE is
uncertain (prior to software initializing the interrupt domain,
presumably), an 8-bit valueÂ \(x\) can be safely written to <code>domaincfg</code> by writing (\(x\)&lt;&lt;24)|\(x\), where &lt;&lt;24 represents
shifting left by 24 bits, and the vertical bar (|) represents bitwise
logical OR. After <code>domaincfg</code> is written once, the value of BE should then be known,
so subsequent writes should not need to repeat the same trick.</p>
</div>
<div class="paragraph">
<p>At system reset, all writable bits in <code>domaincfg</code> are initialized to zero,
including IE. If an implementation supports additional forms of reset
for the APLIC, it is implementation-defined (or possibly
platform-defined) how these other resets may affect <code>domaincfg</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="AdvPLIC-reg-sourcecfg"><a class="anchor" href="#AdvPLIC-reg-sourcecfg"></a>4.5.2. Source configurations (<code>sourcecfg[1]â€“sourcecfg[1023]</code>)</h4>
<div class="paragraph">
<p>For each possible interrupt source \(i\), register <code>sourcecfg[\(i\)]</code> controls
the <em>source mode</em> for source \(i\) in this interrupt domain as
well as any delegation of the source to a child domain. When
source \(i\) is not implemented, or appears in this domain not
to be implemented, <code>sourcecfg[\(i\)]</code> is read-only zero. If sourceÂ \(i\) was not
delegated to this domain and is then changed (at the parent domain) to
become delegated to this domain, <code>sourcecfg[\(i\)]</code> remains zero until successfully written with a nonzero value.</p>
</div>
<div class="paragraph">
<p>Bit 10 of <code>sourcecfg[\(i\)]</code> is a 1-bit field called D (Delegate). If D = 1,
sourceÂ \(i\) is delegated to a child domain, and if DÂ =Â 0, it
is not delegated to a child domain. Interpretation of the rest of <code>sourcecfg[\(i\)]</code> depends on field D.</p>
</div>
<div class="paragraph">
<p>When interrupt source \(i\) is delegated to a child domain, <code>sourcecfg[\(i\)]</code> has this format:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bit 10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">D, =1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 9:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Child Index (<strong>WLRL</strong>)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>All other register bits are reserved and read as zeros.</p>
</div>
<div class="paragraph">
<p>Child Index is a <strong>WLRL</strong> field that specifies the interrupt domain to which this
source is delegated. For an interrupt domain with \(C\) child
domains, this field must be able to hold integer values in the range 0
to \({C-{1}}\). Each interrupt domain has a fixed mapping
from these index numbers to child domains.</p>
</div>
<div class="paragraph">
<p>If an interrupt domain has no children in the domain hierarchy, bit D
cannot be set to one in any <code>sourcecfg</code> register for that domain. For such a leaf
domain, attempting to write a <code>sourcecfg</code> register with a value that has bit 10 = 1 causes the entire register to be set to zero instead.</p>
</div>
<div class="paragraph">
<p>When interrupt source \(i\) is not delegated to a child
domain, <code>sourcecfg[\(i\)]</code> has this format:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bit 10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">D, =0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 2:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SM (<strong>WARL</strong>)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>All other register bits are reserved and read as zeros.</p>
</div>
<div class="paragraph">
<p>The SM (Source Mode) field is <strong>WARL</strong> and controls whether the interrupt source
is active in this domain, and if so, what values or transitions on the
incoming wire are interpreted as interrupts. The values allowed for SM
and their meanings are listed in
<a href="#TableAdvPLIC-sourcecfg-SM">Table 7</a>. Inactive
(zero) is always supported for field SM. Implementations are free to
choose, independently for each interrupt source, what other values are
supported for SM.</p>
</div>
<table id="TableAdvPLIC-sourcecfg-SM" class="tableblock frame-all grid-none fit-content center">
<caption class="title">Table 7. Encoding of the SM (Source Mode) field of a sourcecfg register when bit D = 0</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Value</th>
<th class="tableblock halign-center valign-top">Name</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Inactive</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inactive in this domain (and not delegated)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Detached</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Active, detached from the source wire</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">2â€“3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">â€”</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Reserved</em></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Edge1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Active, edge-sensitive; interrupt asserted on rising edge</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Edge0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Active, edge-sensitive; interrupt asserted on falling edge</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Level1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Active, level-sensitive; interrupt asserted when high</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Level0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Active, level-sensitive; interrupt asserted when low</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>An interrupt source is inactive in the interrupt domain if either the
source is delegated to a child domain (D = 1) or it is not delegated
(D = 0) and SM is Inactive. Whenever interrupt sourceÂ \(i\) is
inactive in an interrupt domain, the corresponding interrupt-pending and
interrupt-enable bits within the domain are read-only zeros, and
register <code>target[\(i\)]</code> is also read-only zero. If source \(i\) is changed
from inactive to an active mode, the interrupt source&#8217;s pending and
enable bits remain zeros, unless set automatically for a reason
specified later in this section or in
<a href="#AdvPLIC-pendingBits">Section 4.7</a>, and the defined subfields of <code>target[\(i\)]</code> obtain UNSPECIFIED values.</p>
</div>
<div class="paragraph">
<p>When a source is configured as Detached, its wire input is ignored;
however, the interrupt-pending bit may still be set by a write to a <code>setip</code> or <code>setipnum</code> register. (This mode can be useful for receiving MSIs, for example.)</p>
</div>
<div class="paragraph">
<p>An edge-sensitive source can be configured to recognize an incoming
interrupt on either a rising edge (low-to-high transition) or a falling
edge (high-to-low transition). When configured for a falling edge (mode
Edge0), the source is said to be <em>inverted</em>.</p>
</div>
<div class="paragraph">
<p>A level-sensitive source can be configured to interpret either a high
level (1) or a low level (0) on the wire as the assertion of an
interrupt. When configured for a low level (mode Level0), the source is
said to be <em>inverted</em>.</p>
</div>
<div class="paragraph">
<p>For an interrupt source that is configured as edge-sensitive or
level-sensitive, define</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><em>rectified input value</em> = (incoming wire value) XOR (source is
inverted).</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>For a source that is inactive or Detached, the <em>rectified input value</em>
is zero.</p>
</div>
<div class="paragraph">
<p>Any write to a <code>sourcecfg</code> register might (or might not) cause the corresponding interrupt-pending bit to be set to one if the rectified input value is high (= 1) under the new source mode. A write to a <code>sourcecfg</code> register will not by itself cause a pending bit to be cleared except when the source is made inactive. (But see <a href="#AdvPLIC-pendingBits">Section 4.7</a>.)</p>
</div>
</div>
<div class="sect3">
<h4 id="AdvPLIC-reg-mmsiaddrcfg"><a class="anchor" href="#AdvPLIC-reg-mmsiaddrcfg"></a>4.5.3. Machine MSI address configuration (<code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code>)</h4>
<div class="paragraph">
<p>For machine-level interrupt domains, registers <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code> may optionally provide parameters used to determine the addresses to write outgoing MSIs.</p>
</div>
<div class="paragraph">
<p>If no interrupt domain of the APLIC supports MSI delivery mode (<code>domaincfg</code>.DM is read-only zero for all domains), these two registers are not implemented for any domain. Otherwise, they are implemented for the root domain, and
may or may not be implemented for other machine-level domains. For
domains not at machine level, they are never implemented. When a domain
does not implement <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code>, the eight bytes at their locations are simply read-only zeros like other reserved bytes.</p>
</div>
<div class="paragraph">
<p>Registers <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code> are potentially writable only for the root domain. For all
other machine-level domains that implement them, they are read-only.</p>
</div>
<div class="paragraph">
<p>When implemented, <code>mmsiaddrcfg</code> has this format:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 31:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Low Base PPN (<strong>WARL</strong>)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>and <code>mmsiaddrcfgh</code> has this format:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bit 31</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">L</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 28:24</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HHXS (<strong>WARL</strong>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 22:20</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LHXS (<strong>WARL</strong>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 18:16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HHXW (<strong>WARL</strong>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 15:12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LHXW (<strong>WARL</strong>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 11:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">High Base PPN (<strong>WARL</strong>)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>All other bits of <code>mmsiaddrcfgh</code> are reserved and read as zeros.</p>
</div>
<div class="paragraph">
<p>Fields High Base PPN from <code>mmsiaddrcfgh</code> and Low Base PPN from <code>mmsiaddrcfg</code> concatenate to form a
44-bit Base PPN (Physical Page Number). The use of this value and fields
HHXS (High Hart Index Shift), LHXS (Low Hart Index Shift), HHXW (High
Hart Index Width), and LHXW (Low Hart Index Width) for determining
target addresses for MSIs is described later, in
<a href="#AdvPLIC-MSIAddrs">Section 4.9.1</a>.</p>
</div>
<div class="paragraph">
<p>When <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code> are writable (root domain only), all fields other than L are <strong>WARL</strong>.
An implementation is free to choose what values are supported.
Typically, some bits are writable while others are read-only constants.
In the extreme, the values of all fields may be entirely constant, fixed
by the implementation.</p>
</div>
<div class="paragraph">
<p>If bit L in <code>mmsiaddrcfgh</code> is set to one, <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code> are <em>locked</em>, and writes to the registers
are ignored, making the registers effectively read-only. When L = 1, the
other fields in <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code> may optionally all read as zeros. In that case, if
these other fields were given nonzero values when L was first set in the
root domain, their values are retained internally by the APLIC but
become no longer visible by reading <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code>.</p>
</div>
<div class="paragraph">
<p>Setting <code>mmsiaddrcfgh</code>.L to one also locks registers <code>smsiaddrcfg</code> and <code>smsiaddrcfgh</code> described in the next
subsection, if those registers are implemented as well.</p>
</div>
<div class="paragraph">
<p>For the root domain, L is initialized at system reset to either zero or
one, whichever is deemed appropriate for the specific APLIC
implementation. If reset initializes L to one, either the other fields
are hardwired by the APLIC to constants, or the APLIC has a different
means, outside of this standard, for determining the addresses of
outgoing MSI writes. In the latter case, the other fields in <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code> may all
read as zeros, so registers <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code> have only read-only values zero and <code>0x80000000</code>
respectively. Any time <code>mmsiaddrcfg</code> or <code>mmsiaddrcfgh</code> has a different value (not zero or <code>0x80000000</code>
respectively), the addresses for outgoing MSI writes directed to machine
level must be derivable from the visible values of these registers, as
specified in <a href="#AdvPLIC-MSIAddrs">Section 4.9.1</a>.</p>
</div>
<div class="paragraph">
<p>For machine-level domains that are not the root domain, if these
registers are implemented, bit L is always one, and the other fields
either are read-only copies of <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code> from the root domain, or are all zeros.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Giving software the ability to arbitrarily determine the addresses to
which MSIs are sent, even if allowed only for machine level, permits
bypassing physical memory protection (PMP). For APLICs that support MSI
delivery mode, it is recommended, if feasible, that the APLIC internally
hardwire the physical addresses for all target IMSICs, putting those
addresses beyond the reach of software to change. However, not all APLIC
implementations will be able to follow that recommendation.</p>
</div>
<div class="paragraph">
<p>It is expected that most systems will arrange the physical addresses of
target IMSICs in a simple linear correspondence with hart index numbers.
(See <a href="#IMSIC-systemMemRegions">Section 3.6</a>.)
Registers <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code> (along with <code>smsiaddrcfg</code> and <code>smsiaddrcfgh</code> from the next subsection) allow
sufficiently trusted machine-level software, early after system reset,
to configure the pattern of physical addresses for target IMSICs and
then lock this configuration against subsequent tampering.</p>
</div>
<div class="paragraph">
<p>APLICs that actually hardwire the IMSIC addresses internally can
implement these registers simply as read-only with values zero and <code>0x80000000</code>. Or,
if the IMSIC addresses must be configured by software but the formula is
too complex for registers <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code> to handle, again the registers can be
implemented simply as read-only with values zero and <code>0x80000000</code>, and a separate, custom mechanism supplied for configuring the IMSIC addresses.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If an APLIC supports additional forms of reset besides system reset, it
is implementation-defined (or possibly platform-defined) how these other
resets may affect <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code> (as well as <code>smsiaddrcfg</code> and <code>smsiaddrcfgh</code>) in the root domain. However, it
must not be possible for insufficiently privileged software to use a
localized reset to unlock these registers by changing bit L back to
zero. For this reason, it is likely that only a complete system reset
affects these registers, and any other resets do not.</p>
</div>
</div>
<div class="sect3">
<h4 id="AdvPLIC-reg-smsiaddrcfg"><a class="anchor" href="#AdvPLIC-reg-smsiaddrcfg"></a>4.5.4. Supervisor MSI address configuration (<code>smsiaddrcfg</code> and <code>smsiaddrcfgh</code>)</h4>
<div class="paragraph">
<p>For machine-level interrupt domains, registers <code>smsiaddrcfg</code> and <code>smsiaddrcfgh</code> may optionally
provide parameters used by supervisor-level domains to determine the
addresses to write outgoing MSIs.</p>
</div>
<div class="paragraph">
<p>Registers <code>smsiaddrcfg</code> and <code>smsiaddrcfgh</code> are implemented by a domain if the domain implements <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code>
and the APLIC has at least one supervisor-level interrupt domain. If the
registers are not implemented, the eight bytes at their locations are
simply read-only zeros like other reserved bytes.</p>
</div>
<div class="paragraph">
<p>Like <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code>, registers <code>smsiaddrcfg</code> and <code>smsiaddrcfgh</code> are potentially writable only for the root
domain. For all other machine-level domains that implement them, they
are read-only.</p>
</div>
<div class="paragraph">
<p>When implemented, <code>smsiaddrcfg</code> has this format:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 31:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Low Base PPN (<strong>WARL</strong>)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>and <code>smsiaddrcfgh</code> has this format:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 22:20</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LHXS (<strong>WARL</strong>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 11:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">High Base PPN (<strong>WARL</strong>)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>All other bits of <code>smsiaddrcfgh</code> are reserved and read as zeros.</p>
</div>
<div class="paragraph">
<p>Fields High Base PPN from <code>smsiaddrcfgh</code> and Low Base PPN from <code>smsiaddrcfg</code> concatenate to form a
44-bit Base PPN (Physical Page Number). The use of this value and field
LHXS (Low Hart Index Shift) for determining target addresses for MSIs is
described later, in <a href="#AdvPLIC-MSIAddrs">Section 4.9.1</a>.</p>
</div>
<div class="paragraph">
<p>When <code>smsiaddrcfg</code> and <code>smsiaddrcfgh</code> are writable (root domain only), all fields are <strong>WARL</strong>. An
implementation is free to choose what values are supported, just as for <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code>.</p>
</div>
<div class="paragraph">
<p>If register <code>mmsiaddrcfgh</code> of the domain has bit L set to one, then <code>smsiaddrcfg</code> and <code>smsiaddrcfgh</code> are <em>locked</em> as
read-only alongside <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code>. When <code>mmsiaddrcfgh.L</code> = 1, if the readable values of <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code> are
zero and <code>0x80000000</code> respectivelyâ€”because their other fields are hiddenâ€”then <code>smsiaddrcfg</code> and <code>smsiaddrcfgh</code> are hidden also and read as zeros.</p>
</div>
<div class="paragraph">
<p>For the root domain only, if <code>mmsiaddrcfgh.L</code> = 1 and the MSI-address-configuration
fields are hidden (so <code>mmsiaddrcfgh</code> reads as <code>0x80000000</code> and registers <code>mmsiaddrcfg</code>, <code>smsiaddrcfg</code>, and <code>smsiaddrcfgh</code> all read as zeros),
then whatever values <code>smsiaddrcfg</code> and <code>smsiaddrcfgh</code> had when <code>mmsiaddrcfgh</code>.L was first set are retained
internally by the APLIC, though those values are no longer visible by
reading the registers. Alternatively, if system reset initializes <code>mmsiaddrcfgh.L</code> = 1
in the root domain, and if all MSI-address-configuration fields never
appear as anything other than zeros, then the APLIC implementation has
some other, possibly nonstandard, means for determining the addresses of
outgoing MSIs, as discussed in the previous subsection,
<a href="#AdvPLIC-reg-mmsiaddrcfg">Section 4.5.3</a>.</p>
</div>
<div class="paragraph">
<p>Any time <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code> are not read-only zero and <code>0x80000000</code> respectively, the addresses for
outgoing MSI writes directed to supervisor level must be derivable from
the visible values of registers <code>mmsiaddrcfgh</code>, <code>smsiaddrcfg</code>, and <code>smsiaddrcfgh</code>, as specified in
<a href="#AdvPLIC-MSIAddrs">Section 4.9.1</a>.</p>
</div>
<div class="paragraph">
<p>For machine-level domains that are not the root domain, if <code>smsiaddrcfg</code> and <code>smsiaddrcfgh</code> are
implemented and are not read-only zeros, then they are read-only copies
of the same registers from the root domain.</p>
</div>
</div>
<div class="sect3">
<h4 id="set-interrupt-pending-bits-setip0-setip31"><a class="anchor" href="#set-interrupt-pending-bits-setip0-setip31"></a>4.5.5. Set interrupt-pending bits (<code>setip[0]</code>-<code>setip[31]</code>)</h4>
<div class="paragraph">
<p>Reading or writing <code>setip[\(k\)]</code> register reads or potentially modifies the pending
bits for interrupt sources \(k\times{32}\) through
\(k\times{32}+{31}\). For an implemented interrupt
source \(i\) within that range, the pending bit for
source \(i\) corresponds with register bit
(\(i\bmod{32}\)).</p>
</div>
<div class="paragraph">
<p>A read of a <code>setip</code> register returns the pending bits of the corresponding
interrupt sources. Bit positions in the result value that do not
correspond to an implemented interrupt source (such as bit 0 of <code>setip[0]</code>) are zeros.</p>
</div>
<div class="paragraph">
<p>On a write to a <code>setip</code> register, for each bit that is one in the 32-bit value
written, if that bit position corresponds to an active interrupt source,
the interrupt-pending bit for that source is set to one if possible. See
<a href="#AdvPLIC-pendingBits">Section 4.7</a> for exactly when a pending bit may
be set by writing to a <code>setip</code> register.</p>
</div>
</div>
<div class="sect3">
<h4 id="set-interrupt-pending-bit-by-number-setipnum"><a class="anchor" href="#set-interrupt-pending-bit-by-number-setipnum"></a>4.5.6. Set interrupt-pending bit by number (<code>setipnum</code>)</h4>
<div class="paragraph">
<p>If \(i\) is an active interrupt source number in the domain,
writing 32-bit valueÂ \(i\) to register <code>setipnum</code> causes the pending bit
for sourceÂ \(i\) to be set to one if possible. See
<a href="#AdvPLIC-pendingBits">Section 4.7</a> for exactly when a pending bit may
be set by writing to <code>setipnum</code>.</p>
</div>
<div class="paragraph">
<p>A write to <code>setipnum</code> is ignored if the value written is not an active interrupt
source number in the domain. A read of <code>setipnum</code> always returns zero.</p>
</div>
</div>
<div class="sect3">
<h4 id="rectified-inputs-clear-interrupt-pending-bits-in_clrip0-in_clrip31"><a class="anchor" href="#rectified-inputs-clear-interrupt-pending-bits-in_clrip0-in_clrip31"></a>4.5.7. Rectified inputs, clear interrupt-pending bits (<code>in_clrip[0]</code>-<code>in_clrip[31]</code>)</h4>
<div class="paragraph">
<p>Reading register <code>in_clrip[\(k\)]</code> returns the rectified input (<a href="#AdvPLIC-reg-sourcecfg">Section 4.5.2</a>) for interrupt sources
\(k\times{32}\) through
\({k\times{32}+{31}}\), while writing <code>in_clrip[\(k\)]</code> potentially
modifies the pending bits for the same sources. For an implemented
interrupt source \(i\) within the specified range,
source \(i\) corresponds with register bit
(\(i\bmod{32}\)).</p>
</div>
<div class="paragraph">
<p>A read of an <code>in_clrip</code> register returns the rectified input values of the
corresponding interrupt sources. Bit positions in the result value that
do not correspond to an implemented interrupt source (such as bit 0 of <code>in_clrip[0]</code>) are zeros.</p>
</div>
<div class="paragraph">
<p>On a write to an <code>in_clrip</code> register, for each bit that is one in the 32-bit value written, if that bit position corresponds to an active interrupt source, the interrupt-pending bit for that source is cleared if possible. See
<a href="#AdvPLIC-pendingBits">Section 4.7</a> for exactly when a pending bit may
be cleared by writing to an <code>in_clrip</code> register.</p>
</div>
</div>
<div class="sect3">
<h4 id="clear-interrupt-pending-bit-by-number-clripnum"><a class="anchor" href="#clear-interrupt-pending-bit-by-number-clripnum"></a>4.5.8. Clear interrupt-pending bit by number (<code>clripnum</code>)</h4>
<div class="paragraph">
<p>If \(i\) is an active interrupt source number in the domain,
writing 32-bit value \(i\) to register <code>clripnum</code> causes the pending bit
for source \(i\) to be cleared if possible. See
<a href="#AdvPLIC-pendingBits">Section 4.7</a> for exactly when a pending bit may
be cleared by writing to <code>clripnum</code>.</p>
</div>
<div class="paragraph">
<p>A write to <code>clripnum</code> is ignored if the value written is not an active interrupt
source number in the domain. A read of <code>clripnum</code> always returns zero.</p>
</div>
</div>
<div class="sect3">
<h4 id="set-interrupt-enable-bits-setie0-setie31"><a class="anchor" href="#set-interrupt-enable-bits-setie0-setie31"></a>4.5.9. Set interrupt-enable bits (<code>setie[0]</code>-<code>setie[31]</code>)</h4>
<div class="paragraph">
<p>Reading or writing register <code>setie[\(k\)]</code> reads or potentially modifies the enable
bits for interrupt sources \(k\times{32}\) through
\({k\times{32}+{31}}\). For an implemented interrupt
source \(i\) within that range, the enable bit for
source \(i\) corresponds with register bit
\(i\bmod{32}\).</p>
</div>
<div class="paragraph">
<p>A read of a <code>setie</code> register returns the enable bits of the corresponding
interrupt sources. Bit positions in the result value that do not
correspond to an implemented interrupt source (such as bit 0 of <code>setie[0]</code>) are zeros.</p>
</div>
<div class="paragraph">
<p>On a write to a <code>setie</code> register, for each bit that is one in the 32-bit value
written, if that bit position corresponds to an active interrupt source,
the interrupt-enable bit for that source is set to one.</p>
</div>
</div>
<div class="sect3">
<h4 id="set-interrupt-enable-bit-by-number-setienum"><a class="anchor" href="#set-interrupt-enable-bit-by-number-setienum"></a>4.5.10. Set interrupt-enable bit by number (<code>setienum</code>)</h4>
<div class="paragraph">
<p>If \(i\) is an active interrupt source number in the domain,
writing 32-bit value \(i\) to register <code>setienum</code> causes the enable bit for source \(i\) to be set to one.</p>
</div>
<div class="paragraph">
<p>A write to <code>setienum</code> is ignored if the value written is not an active interrupt source number in the domain. A read of <code>setienum</code> always returns zero.</p>
</div>
</div>
<div class="sect3">
<h4 id="clear-interrupt-enable-bits-clrie0-clrie31"><a class="anchor" href="#clear-interrupt-enable-bits-clrie0-clrie31"></a>4.5.11. Clear interrupt-enable bits (<code>clrie[0]</code>-<code>clrie[31]</code>)</h4>
<div class="paragraph">
<p>Writing register <code>clrie[\(k\)]</code> potentially modifies the enable bits for interrupt sources \(k\times{32}\) through
\({k\times{32}+{31}}\). For an implemented interrupt
source \(i\) within that range, the enable bit for
source \(i\) corresponds with register bit
\(i\bmod{32}\).</p>
</div>
<div class="paragraph">
<p>On a write to a <code>clrie</code> register, for each bit that is one in the 32-bit value written, the interrupt-enable bit for that source is cleared.</p>
</div>
<div class="paragraph">
<p>A read of a <code>clrie</code> register always returns zero.</p>
</div>
</div>
<div class="sect3">
<h4 id="clear-interrupt-enable-bit-by-number-clrienum"><a class="anchor" href="#clear-interrupt-enable-bit-by-number-clrienum"></a>4.5.12. Clear interrupt-enable bit by number (<code>clrienum</code>)</h4>
<div class="paragraph">
<p>If \(i\) is an active interrupt source number in the domain,
writing 32-bit value \(i\) to register <code>clrienum</code> causes the enable bit for source \(i\) to be cleared.</p>
</div>
<div class="paragraph">
<p>A write to <code>clrienum</code> is ignored if the value written is not an active interrupt source number in the domain. A read of <code>clrienum</code> always returns zero.</p>
</div>
</div>
<div class="sect3">
<h4 id="set-interrupt-pending-bit-by-number-little-endian-setipnum_le"><a class="anchor" href="#set-interrupt-pending-bit-by-number-little-endian-setipnum_le"></a>4.5.13. Set interrupt-pending bit by number, little-endian (<code>setipnum_le</code>)</h4>
<div class="paragraph">
<p>Register <code>setipnum_le</code> acts identically to <code>setipnum</code> except that byte order is always little-endian, as though field BE (Big-Endian) of register <code>domaincfg</code> is zero.</p>
</div>
<div class="paragraph">
<p>For systems that are big-endian-only, with <code>domaincfg</code>.BE hardwired to one, <code>setipnum_le</code> need not be implemented, in which case the four bytes at this offset are simply read-only zeros like other reserved bytes.</p>
</div>
<div class="paragraph">
<p><code>setipnum_le</code> may be used as a write port for MSIs.</p>
</div>
</div>
<div class="sect3">
<h4 id="set-interrupt-pending-bit-by-number-big-endian-setipnum_be"><a class="anchor" href="#set-interrupt-pending-bit-by-number-big-endian-setipnum_be"></a>4.5.14. Set interrupt-pending bit by number, big-endian (<code>setipnum_be</code>)</h4>
<div class="paragraph">
<p>Register <code>setipnum_be</code> acts identically to <code>setipnum</code> except that byte order is always big-endian, as though field BE (Big-Endian) of register <code>domaincfg</code> is one.</p>
</div>
<div class="paragraph">
<p>For systems that are little-endian-only, with <code>domaincfg</code>.BE hardwired to zero, <code>setipnum_be</code> need not be implemented, in which case the four bytes at this offset are simply read-only zeros like other reserved bytes.</p>
</div>
<div class="paragraph">
<p>For systems built mainly for big-endian byte order, <code>setipnum_be</code> may be useful as a write port for MSIs from some devices.</p>
</div>
</div>
<div class="sect3">
<h4 id="AdvPLIC-reg-genmsi"><a class="anchor" href="#AdvPLIC-reg-genmsi"></a>4.5.15. Generate MSI (<code>genmsi</code>)</h4>
<div class="paragraph">
<p>When the interrupt domain is configured in MSI delivery mode (<code>domaincfg</code>.DM = 1), register <code>genmsi</code> can be used to cause an <em>extempore</em> MSI to be sent from the
APLIC to a hart. The main purpose for this function is to assist in
establishing a temporary known ordering between a hart&#8217;s writes to the
APLIC&#8217;s registers and the transmission of MSIs from the APLIC to the
hart, as explained later in <a href="#AdvPLIC-MSISync">Section 4.9.3</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>For other purposes, sending an MSI to a hart is usually better done by
writing directly to the hart&#8217;s IMSIC, rather than employing an APLIC as
an intermediary. Use of the <code>genmsi</code> register should be minimized to avoid it
becoming a bottleneck.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Register <code>genmsi</code> has this format:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 31:18</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hart Index (<strong>WLRL</strong>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Busy (read-only)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 10:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">EIID (<strong>WARL</strong>)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>All other register bits are reserved and read as zeros.</p>
</div>
<div class="paragraph">
<p>The Busy bit is ordinarily zero (false), but a write to <code>genmsi</code> causes Busy to become one (true), indicating an extempore MSI is pending. The Hart
Index field specifies the destination hart, and EIID (External Interrupt
Identity) specifies the data value for the MSI. Fields Hart Index and
EIID have the same formats and behavior as in a <code>target</code> register, documented in the next subsection, <a href="#AdvPLIC-reg-target">Section 4.5.16</a>. For a
machine-level interrupt domain, an extempore MSI is sent to the
destination hart at machine level, and for a supervisor-level interrupt
domain, an extempore MSI is sent to the destination hart at supervisor
level.</p>
</div>
<div class="paragraph">
<p>A pending extempore MSI should be sent by the APLIC with minimal delay.
Once it has left the APLIC and the APLIC is able to accept a new write
to <code>genmsi</code> for another extempore MSI, Busy reverts to false. All MSIs previously sent from this APLIC to the same hart must be visible at the hart&#8217;s IMSIC before the extempore MSI becomes visible at the hart&#8217;s IMSIC.</p>
</div>
<div class="paragraph">
<p>While Busy is true, writes to <code>genmsi</code> are ignored.</p>
</div>
<div class="paragraph">
<p>Extempore MSIs are not affected by the IE bit of the domain&#8217;s <code>domaincfg</code> register. An extempore MSI is sent even if <code>domaincfg</code>.IE = 0.</p>
</div>
<div class="paragraph">
<p>When the interrupt domain is configured in direct delivery mode (<code>domaincfg</code>.DM = 0), register <code>genmsi</code> is read-only zero.</p>
</div>
</div>
<div class="sect3">
<h4 id="AdvPLIC-reg-target"><a class="anchor" href="#AdvPLIC-reg-target"></a>4.5.16. Interrupt targets (<code>target[1]-target[1023]</code>)</h4>
<div class="paragraph">
<p>If interrupt source \(i\) is inactive in this domain, register <code>target[\(i\)]</code> is read-only zero. If source \(i\) is active, <code>target[\(i\)]</code> determines the
hart to which interrupts from the source are signaled or forwarded. The
exact interpretation of <code>target[\(i\)]</code> depends on the delivery mode configured by field DM of register <code>domaincfg</code>.</p>
</div>
<div class="paragraph">
<p>If <code>domaincfg</code>.DM is changed, the <code>target</code> registers for all active interrupt sources within the domain obtain UNSPECIFIED values in all fields defined for the new delivery mode.</p>
</div>
<div class="sect4">
<h5 id="active-source-direct-delivery-mode"><a class="anchor" href="#active-source-direct-delivery-mode"></a>4.5.16.1. Active source, direct delivery mode</h5>
<div class="paragraph">
<p>For an active interrupt source \(i\), if the domain is
configured in direct delivery mode (<code>domaincfg</code>.DM = 0), then register <code>target[\(i\)]</code> has this format:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 31:18</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hart Index (<strong>WLRL</strong>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 7:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPRIO (<strong>WARL</strong>)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>All other register bits are reserved and read as zeros.</p>
</div>
<div class="paragraph">
<p>Hart Index is a <strong>WLRL</strong> field that specifies the hart to which interrupts from
this source will be delivered.</p>
</div>
<div class="paragraph">
<p>Field IPRIO (Interrupt Priority) specifies the <em>priority number</em> for the
interrupt source. This field is a <strong>WARL</strong> unsigned integer of <em>IPRIOLEN</em> bits,
where IPRIOLEN is a constant parameter for the given APLIC, in the range
of 1 to 8. Only values 1 through
\({2}^{\textrm{IPRIOLEN}} - {1}\) are allowed for
IPRIO, not zero. A write to a <code>target</code> register sets IPRIO equal to bits
\(({{IPRIOLEN} - {1}})\):0 of the 32-bit value
written, unless those bits are all zeros, in which case the priority
number is set to 1 instead. (If IPRIOLEN = 1, these rules cause IPRIO to
be effectively read-only with value 1.)</p>
</div>
<div class="paragraph">
<p>Smaller priority numbers convey higher priority. When interrupt sources
have equal priority number, the source with the lowest identity number
has the highest priority.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Interrupt priorities are encoded as integers, with smaller numbers
denoting higher priority, to match the encoding of priorities by IMSICs.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="active-source-msi-delivery-mode"><a class="anchor" href="#active-source-msi-delivery-mode"></a>4.5.16.2. Active source, MSI delivery mode</h5>
<div class="paragraph">
<p>For an active interrupt source \(i\), if the domain is
configured in MSI delivery mode (<code>domaincfg</code>.DM = 1), then register <code>target[\(i\)]</code> has this format:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 31:18</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hart Index (<strong>WLRL</strong>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 17:12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Guest Index (<strong>WLRL</strong>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 10:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">EIID (<strong>WARL</strong>)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Bit 11 is reserved and reads as zero.</p>
</div>
<div class="paragraph">
<p>The Hart Index field specifies the hart to which interrupts from this
source will be forwarded.</p>
</div>
<div class="paragraph">
<p>If the interrupt domain is at supervisor level and the domain&#8217;s harts
implement the H extension, then Guest Index is a <strong>WLRL</strong> field that must be able to hold all integer values in the range 0 through GEILEN. (Parameter <em>GEILEN</em> is defined by the H extension.) Otherwise, field Guest Index is read-only zero. For a supervisor-level interrupt domain, a nonzero Guest
Index is the number of the target hart&#8217;s guest interrupt file to which
MSIs will be sent. When Guest Index is zero, MSIs from a
supervisor-level domain are forwarded to the target hart at supervisor
level. For a machine-level domain, Guest Index is read-only zero, and
MSIs are forwarded to a target hart always at machine level.</p>
</div>
<div class="paragraph">
<p>Together, fields Hart Index and Guest Index of register <code>target[\(i\)]</code> determine the
address for MSIs forwarded for interrupt source \(i\). The
remaining field EIID (External Interrupt Identity) specifies the data
value for those MSIs, eventually becoming the minor identity for an
external interrupt at the target hart.</p>
</div>
<div class="paragraph">
<p>If the interrupt domain&#8217;s harts have IMSIC interrupt files that
implement \(N\) distinct interrupt identities
(<a href="#IMSIC-intrFilesAndIdents">Section 3.1</a>),
then EIID is a \(k\)-bit unsigned integer field, where
\(\lceil\log_{2}N\rceil \leq k \leq {11}\). EIID is thus
able to hold at least values 0 through \(N\). A write to a <code>target</code>
register sets the \(k\) implemented bits of EIID equal to the
least-significant \(k\) bits of the 32-bit value written.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="reset"><a class="anchor" href="#reset"></a>4.6. Reset</h3>
<div class="paragraph">
<p>Upon reset of an APLIC, all its state becomes valid and consistent but
otherwise UNSPECIFIED, except for:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the domaincfg register of each interrupt domain (<a href="#AdvPLIC-reg-domaincfg">Section 4.5.1</a>);</p>
</li>
<li>
<p>possibly the MSI address configuration registers of machine-level interrupt domains (<a href="#AdvPLIC-reg-mmsiaddrcfg">Section 4.5.3</a> and <a href="#AdvPLIC-reg-smsiaddrcfg">Section 4.5.4</a>); and</p>
</li>
<li>
<p>the Busy bit of each interrupt domain&#8217;s <code>genmsi</code> register, if it exists (<a href="#AdvPLIC-reg-genmsi">Section 4.5.15</a>).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="AdvPLIC-pendingBits"><a class="anchor" href="#AdvPLIC-pendingBits"></a>4.7. Precise effects on interrupt-pending bits</h3>
<div class="paragraph">
<p>An attempt to set or clear an interrupt source&#8217;s pending bit by writing
to a register in the interrupt domain&#8217;s control region may or may not be
successful, depending on the corresponding source mode, the interrupt
domain&#8217;s delivery mode, and the state of the source&#8217;s rectified input
value (defined in <a href="#AdvPLIC-reg-sourcecfg">Section 4.5.2</a>). The
following enumerates all the circumstances when a pending bit is set or
cleared for a given source mode.</p>
</div>
<div class="paragraph">
<p>If the source mode is Detached:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The pending bit is set to one only by a relevant write to a <code>setip</code> or <code>setipnum</code> register.</p>
</li>
<li>
<p>The pending bit is cleared when the interrupt is claimed at the APLIC
or forwarded by MSI, or by a relevant write to an <code>in_clrip</code> register or to <code>clripnum</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the source mode is Edge1 or Edge0:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The pending bit is set to one by a low-to-high transition in the
rectified input value, or by a relevant write to a <code>setip</code> or <code>setipnum</code> register.</p>
</li>
<li>
<p>The pending bit is cleared when the interrupt is claimed at the APLIC
or forwarded by MSI, or by a relevant write to an <code>in_clrip</code> register or to <code>clripnum</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the source mode is Level1 or Level0 and the interrupt domain is
configured in direct delivery mode (<code>domaincfg</code>.DM = 0):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The pending bit is set to one whenever the rectified input value is
high. The pending bit cannot be set by a write to a <code>setip</code> or <code>setipnum</code> register.</p>
</li>
<li>
<p>The pending bit is cleared whenever the rectified input value is low.
The pending bit is not cleared by a claim of the interrupt at the APLIC,
nor can it be cleared by a write to an <code>in_clrip</code> register or to <code>clripnum</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the source mode is Level1 or Level0 and the interrupt domain is
configured in MSI delivery mode (<code>domaincfg</code>.DM = 1):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The pending bit is set to one by a low-to-high transition in the
rectified input value. The pending bit may also be set by a relevant
write to a <code>setip</code> or <code>setipnum</code> register when the rectified input value is high, but not when the rectified input value is low.</p>
</li>
<li>
<p>The pending bit is cleared whenever the rectified input value is low,
when the interrupt is forwarded by MSI, or by a relevant write to an <code>in_clrip</code> register or to <code>clripnum</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When an interrupt domain is in direct delivery mode, the pending bit for
a level-sensitive source is always just a copy of the rectified input
value. Even in MSI delivery mode, the pending bit for a level-sensitive
source is never set (= 1) when the rectified input value is low.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In addition to the rules above, a write to a <code>sourcecfg</code> register can cause the
sourceâ€™s interrupt-pending bit to be set to one, as specified in
<a href="#AdvPLIC-reg-sourcecfg">Section 4.5.2</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="AdvPLIC-directMode"><a class="anchor" href="#AdvPLIC-directMode"></a>4.8. Interrupt delivery directly by the APLIC</h3>
<div class="paragraph">
<p>When an interrupt domain is in direct delivery mode (<code>domaincfg</code>.DM = 0),
interrupts are delivered from the APLIC to harts by a unique signal to
each hart, usually a dedicated wire. In this case, the domain&#8217;s
memory-mapped control region contains at the end an array of interrupt
delivery control (IDC) structures, one IDC structure per potential hart
index. The first IDC structure is for the domain&#8217;s hart with index 0;
the second is for the hart with index 1; etc.</p>
</div>
<div class="sect3">
<h4 id="AdvPLIC-IDC"><a class="anchor" href="#AdvPLIC-IDC"></a>4.8.1. Interrupt delivery control (IDC) structure</h4>
<div class="paragraph">
<p>Each IDC structure is 32 bytes (naturally aligned to a 32-byte address
boundary) and has these defined registers:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">offset</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">size</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">register name</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x00</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>idelivery</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ox04</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iforce</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x08</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ithreshold</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x18</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>topi</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x1C</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>claimi</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>If the IDC structure is for a hart index number that is not valid for
any actual hart in the interrupt domain, then these registers may
optionally be all read-only zeros. Otherwise, the registers are
documented individually below.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A particular APLIC might be built to support up to some maximum number
of harts without complete knowledge of the set of hart index numbers the
system will employ in each interrupt domain. In that case, for the hart
index numbers that are unused, the APLIC may have IDC structures that
are functional within the APLIC (not read-only zeros) but simply left
unconnected to any physical harts.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="interrupt-delivery-enable-idelivery"><a class="anchor" href="#interrupt-delivery-enable-idelivery"></a>4.8.1.1. Interrupt delivery enable (<code>idelivery</code>)</h5>
<div class="paragraph">
<p><code>idelivery</code> is a <strong>WARL</strong> register that controls whether interrupts that are targeted to the corresponding hart are delivered to the hart so they appear as a pending interrupt in the hart&#8217;s <code>mip</code> CSR. Only two values are currently defined for <code>idelivery</code>:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">0 =</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">interrupt delivery is disabled</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">1 =</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">interrupt delivery is enabled</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The <code>idelivery</code> register affects only whether
interrupts are delivered to the relevant hart.
It has no effect on any other APLIC state,
including IDC registers <code>topi</code> and <code>claimi</code>.</p>
</div>
<div class="paragraph">
<p>If an IDC structure is for a nonexistent hart (i.e., corresponding to a
hart index number that is not valid for any actual hart in the interrupt
domain), setting <code>idelivery</code> to 1 does not deliver interrupts to any hart.</p>
</div>
</div>
<div class="sect4">
<h5 id="interrupt-force-iforce"><a class="anchor" href="#interrupt-force-iforce"></a>4.8.1.2. Interrupt force (<code>iforce</code>)</h5>
<div class="paragraph">
<p><code>iforce</code> is a <strong>WARL</strong> register useful for testing. Only values 0 and 1 are allowed. Setting <code>iforce</code> = 1 forces an interrupt to be asserted to the corresponding hart whenever both the IE field of <code>domaincfg</code> is one and interrupt delivery is enabled to the hart by the <code>idelivery</code> register. When <code>topi</code> is zero, this creates a <em>spurious external interrupt</em> for the hart.</p>
</div>
<div class="paragraph">
<p>When a read of register <code>claimi</code> returns an interrupt identity of zero
(indicating a spurious interrupt), <code>iforce</code> is automatically cleared to zero.</p>
</div>
</div>
<div class="sect4">
<h5 id="interrupt-enable-threshold-ithreshold"><a class="anchor" href="#interrupt-enable-threshold-ithreshold"></a>4.8.1.3. Interrupt enable threshold (<code>ithreshold</code>)</h5>
<div class="paragraph">
<p><code>ithreshold</code> is a <strong>WLRL</strong> register that determines the minimum interrupt priority (maximum priority number) for an interrupt to be signaled to the corresponding hart. Register <code>ithreshold</code> implements exactly IPRIOLEN bits, and thus is capable of
holding all priority numbers from 0 to
\({{2}^{\textrm{IPRIOLEN}} - {1}}\).</p>
</div>
<div class="paragraph">
<p>When <code>ithreshold</code> is a nonzero value \(P\), interrupt sources with priority
numbers \(P\) and higher do not contribute to signaling
interrupts to the hart, as though those sources were not enabled,
regardless of the settings of their interrupt-enable bits. When <code>ithreshold</code> is zero, all enabled interrupt sources can contribute to signaling interrupts to the hart.</p>
</div>
</div>
<div class="sect4">
<h5 id="top-interrupt-topi"><a class="anchor" href="#top-interrupt-topi"></a>4.8.1.4. Top interrupt (<code>topi</code>)</h5>
<div class="paragraph">
<p><code>topi</code> is a read-only register whose value indicates the current
highest-priority pending-and-enabled interrupt targeted to this hart
that also exceeds the priority threshold specified by <code>ithreshold</code>, if not zero.</p>
</div>
<div class="paragraph">
<p>A read of <code>topi</code> returns zero either if no interrupt that is targeted to this
hart is both pending and enabled, or if <code>ithreshold</code> is not zero and no
pending-and-enabled interrupt targeted to this hart has a priority
number less than the value of <code>ithreshold</code>. Otherwise, the value returned from a read of <code>topi</code> has this format:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">bits 25:16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interrupt identity (source number)</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">bits 7:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interrupt priority</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>All other bit positions are zeros.</p>
</div>
<div class="paragraph">
<p>The interrupt identity reported in <code>topi</code> is the minor identity for an external interrupt at the target hart.</p>
</div>
<div class="paragraph">
<p>The value of <code>topi</code> is not affected by <code>domaincfg</code>.IE or by <code>idelivery</code>.</p>
</div>
<div class="paragraph">
<p>Writes to <code>topi</code> are ignored.</p>
</div>
</div>
<div class="sect4">
<h5 id="claim-top-interrupt-claimi"><a class="anchor" href="#claim-top-interrupt-claimi"></a>4.8.1.5. Claim top interrupt (<code>claimi</code>)</h5>
<div class="paragraph">
<p>Register <code>claimi</code> has the same value as <code>topi</code>. When this value is not zero, reading <code>claimi</code> has the simultaneous side effect of clearing the pending bit for the reported interrupt identity, if possible. See
<a href="#AdvPLIC-pendingBits">Section 4.7</a> for exactly when the pending bit
is cleared by a read of <code>claimi</code>.</p>
</div>
<div class="paragraph">
<p>A read from <code>claimi</code> that returns a value of zero has the simultaneous side
effect of setting the <code>iforce</code> register to zero.</p>
</div>
<div class="paragraph">
<p>Writes to <code>claimi</code> are ignored.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="AdvPLIC-directMode-intrDelivery"><a class="anchor" href="#AdvPLIC-directMode-intrDelivery"></a>4.8.2. Interrupt delivery and handling</h4>
<div class="paragraph">
<p>When an interrupt domain is configured so the APLIC delivers interrupts
directly to harts (field DM of <code>domaincfg</code> is zero), the APLIC supplies the
<em>external interrupt</em> signals, at the domainâ€™s privilege level, for all
harts of the domain, so long as one of the following is true: (a) the
harts do not have IMSICs, or (b) the <code>eidelivery</code> registers of the relevant IMSIC
interrupt files are set to <code>0x40000000</code> (<a href="#IMSIC-reg-eidelivery">Section 3.8.1</a>). For a
machine-level domain, the interrupt signals from the APLIC appear as bit
MEIP (Machine External Interrupt-Pending) in each hart&#8217;s <code>mip</code> CSR. For a
supervisor-level domain, the interrupt signals appear as bit SEIP
(Supervisor External Interrupt-Pending) in each hart&#8217;s <code>mip</code> and <code>sip</code> CSRs. Each
interrupt signal may be arbitrarily delayed traveling from the APLIC to
the proper hart.</p>
</div>
<div class="paragraph">
<p>At the APLIC, each interrupt signal to a hart is derived from the IE
field of register <code>domaincfg</code> and the current state of the hart&#8217;s IDC structure in
the memory-mapped control region for the domain. If either <code>domaincfg</code>.IE = 0 or
interrupt delivery to the hart is disabled by the <code>idelivery</code> register (<code>idelivery</code> = 0), the
interrupt signal is held de-asserted. When <code>domaincfg</code>.IE = 1 and interrupt
delivery is enabled (<code>idelivery</code> = 1), the interrupt signal is asserted whenever either register <code>iforce</code> or <code>topi</code> is not zero.</p>
</div>
<div class="paragraph">
<p>Due to likely delay in the communication between an APLIC and a hart, it
may happen that an external interrupt trap is taken, yet no interrupt is
pending and enabled for the hart when a read of the hart&#8217;s <code>claimi</code> register
actually occurs. In such a circumstance, the interrupt identity reported
by the claim will be zero, resulting in an apparent <em>spurious interrupt</em>
from the APLIC. Portable software must be prepared for the possibility
of spurious interrupts at the APLIC, which can safely be ignored and
should be rare. For testing purposes, a spurious interrupt can be
triggered for a hart by setting an IDC structure&#8217;s <code>iforce</code> register to 1.</p>
</div>
<div class="paragraph">
<p>A trap handler solely for external interrupts via an APLIC could be
written roughly as follows:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">save processor registers</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">i = read register <code>claimi</code> from the hart&#8217;s IDC structure at the APLIC</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">i = i&gt;&gt;16</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">call the interrupt handler for external interrupt \(i\) (minor identity)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">restore processor registers</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">return from trap</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>To account for spurious interrupts, this pseudocode assumes there is an
interrupt handler for "external interrupt 0" which does nothing.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="interrupt-forwarding-by-msis"><a class="anchor" href="#interrupt-forwarding-by-msis"></a>4.9. Interrupt forwarding by MSIs</h3>
<div class="paragraph">
<p>In MSI delivery mode (<code>domaincfg</code>.DM = 1), an interrupt domain forwards interrupts to target harts by MSIs.</p>
</div>
<div class="paragraph">
<p>An MSI is sent for a specific source only when the source&#8217;s
corresponding pending and enable bits are both one and the IE field of
register <code>domaincfg</code> is also one. If and when an MSI is sent, the source&#8217;s interrupt pending bit is cleared.</p>
</div>
<div class="sect3">
<h4 id="AdvPLIC-MSIAddrs"><a class="anchor" href="#AdvPLIC-MSIAddrs"></a>4.9.1. Addresses and data for outgoing MSIs</h4>
<div class="paragraph">
<p>To forward interrupts by MSIs, an APLIC must know the MSI target address
for each hart. For any given system, these addresses are fixed and
should be hardwired into the APLIC if possible. However, some APLIC
implementations may require that software supply the MSI target
addresses. In that case, the root domain&#8217;s registers <code>mmsiaddrcfg</code>, <code>mmsiaddrcfgh</code>, <code>smsiaddrcfg</code>, and <code>smsiaddrcfgh</code> (<a href="#AdvPLIC-reg-mmsiaddrcfg">Section 4.5.3</a>
and <a href="#AdvPLIC-reg-smsiaddrcfg">Section 4.5.4</a>) may be used to configure the
MSI addresses for all interrupt domains. Alternatively MSI addresses may
be configured by some custom means outside this standard. If MSI target
addresses must be configured by software, this should be done only from
a suitably privileged execution mode, typically just once, early after
system reset.</p>
</div>
<div class="paragraph">
<p>For a machine-level interrupt domain, if MSI target addresses are
determined by <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code>, then the address for an outgoing MSI for interrupt
source \(i\) is computed from those registers and from the
Hart Index field of register <code>target[\(i\)]</code> as follows:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">g = (Hart Index&gt;&gt;LHXW) &amp; (2<sup>HHXW</sup> - 1)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">h = Hart Index &amp; (2<sup>LHXW</sup> -1)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MSI address = ( Base PPN | (g&lt;&lt;(HHXS+12)) | (h&lt;&lt;LHXS) )&lt;&lt;12</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Here, \(&lt;&lt;k$\) and \(&gt;&gt;k$\) represent shifting left
and right by \(k\) bits, an ampersand (&amp;) represents bitwise
logical AND, and a vertical bar (|) represents bitwise logical OR.
Assuming the recommendations of <a href="#IMSIC-systemMemRegions">Section 3.6</a> are
followed for the arrangement of IMSIC interrupt files in the machine&#8217;s
address space, value \(g\) is intended to be the number of a
hart group (always zero if HHXW = 0), while \(h\) is the
number of the target hart within that group. Represented in the terms of
<a href="#IMSIC-systemMemRegions">Section 3.6</a>, HHXW = \(j\), LHXW = \(k\), HHXS = \({E-24}\), LHXS = \({C-12}\), and Base PPN = \(A\)&gt;&gt;12.</p>
</div>
<div class="paragraph">
<p>For a supervisor-level domain, if MSI target addresses are determined by
the root domain&#8217;s configuration registers (<code>smsiaddrcfg</code> and others), then to
construct the address for an outgoing MSI for interrupt
source \(i\), the Hart Index from register <code>target[\(i\)]</code> must first be
converted into the index number that machine-level domains use for the
same hart. (These numbers are often the same, but they may not be.) The
address for the MSI is then computed using this machine-level hart index
together with the Base PPN and LHXS values from <code>smsiaddrcfg</code> and <code>smsiaddrcfgh</code>, the other fields
(HHXW, LHXW, and HHXS) from <code>mmsiaddrcfgh</code>, and the Guest Index from <code>target[\(i\)]</code>, as follows:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">g = (machine-level hart index&gt;&gt;LHXW) &amp; (2<sup>HHXW</sup> - 1)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">h = machine-level hart index &amp; (2<sup>LHXW</sup> - 1)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MSI address = (Base PPN | (g&lt;&lt;(HHXS + 12)) | (h&lt;&lt;LHXS) | Guest Index)&lt;&lt;12</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Represented in the terms of
<a href="#IMSIC-systemMemRegions">Section 3.6</a>, HHXW = \(j\), LHXW = \(k\), HHXS = \({E-24}\), LHXS = \({D-12}\), and Base PPN = \(B\)&gt;&gt;12.</p>
</div>
<div class="paragraph">
<p>The data for an outgoing MSI write is taken from the EIID field of <code>target[\(i\)]</code>, zero-extended to 32 bits. An MSI&#8217;s 32-bit data is always written in
little-endian byte order, regardless of the BE field of the domain&#8217;s <code>domaincfg</code>
register.</p>
</div>
</div>
<div class="sect3">
<h4 id="special-consideration-for-level-sensitive-interrupt-sources"><a class="anchor" href="#special-consideration-for-level-sensitive-interrupt-sources"></a>4.9.2. Special consideration for level-sensitive interrupt sources</h4>
<div class="paragraph">
<p>As soon as a level-sensitive interrupt is forwarded by MSI, the APLIC
clears the pending bit for the interrupt source and then ignores the
source until its incoming signal has been de-asserted. Clearing the
pending bit when an MSI is sent is obviously necessary to avoid a
constant stream of repeated MSIs from the APLIC to the target hart for
the same interrupt. However, after an interrupt service routine has
addressed a cause found for the interrupt, the incoming interrupt wire
might remain asserted at the APLIC for another reason, despite that the
interrupt&#8217;s pending bit at the APLIC was cleared and will remain so
without intervention from software. If the interrupt service routine
then exits without further action, a continued interrupt from this
source might never receive attention.</p>
</div>
<div class="paragraph">
<p>To avoid dropping interrupts in this way, the interrupt service routine
for a level-sensitive interrupt may do one of the following before
exiting:</p>
</div>
<div class="paragraph">
<p>The first option is to test whether the interrupt wire into the APLIC is
still asserted, by reading the appropriate <code>in_clrip</code> register at the APLIC. If the
incoming interrupt is still asserted, the body of the interrupt service
routine may be repeated to find and address an additional interrupt
cause before the source wire is tested again. Once the incoming wire is
observed not asserted, the interrupt service routine may safely exit, as
any new interrupt assertion will cause the pending bit to become set and
a new MSI sent to the hart.</p>
</div>
<div class="paragraph">
<p>A second option is for the interrupt service routine to write the
APLIC&#8217;s source identity number for the interrupt to the domain&#8217;s <code>setipnum</code>
register just before exiting. This will cause the interrupt&#8217;s pending
bit to be set to one again if the source is still asserting an
interrupt, but not if the source is not asserting an interrupt.</p>
</div>
</div>
<div class="sect3">
<h4 id="AdvPLIC-MSISync"><a class="anchor" href="#AdvPLIC-MSISync"></a>4.9.3. Synchronizing interactions between a hart and the APLIC</h4>
<div class="paragraph">
<p>When an APLIC sends an MSI to a hart, there is an unspecified travel
delay before the MSI is observed at the hart&#8217;s IMSIC. Consequently,
after an APLIC&#8217;s configuration is changed by writing to an APLIC
register, harts may continue to see MSIs arrive from the APLIC from the
time before the write, for an unspecified amount of time.</p>
</div>
<div class="paragraph">
<p>It is sometimes necessary to know when no more of these late MSIs can
arrive. For example, if a hart will be turned off ("powered down"),
all interrupts directed to it must be redirected to other harts, which
may involve reconfiguring one or more APLICs. Even after the APLICs are
reconfigured, the hart still cannot be safely turned off until it is
known no more MSIs are destined for it.</p>
</div>
<div class="paragraph">
<p>The <code>genmsi</code> register (<a href="#AdvPLIC-reg-genmsi">Section 4.5.15</a>) exists to allow
software to determine when all earlier MSIs have arrived at a hart. To
use <code>genmsi</code> for this purpose, software can dedicate one external interrupt
identity at each hart&#8217;s IMSIC interrupt file solely for APLIC
synchronization. Assuming there are multiple harts, an APLIC&#8217;s <code>genmsi</code> register
should also be protected by a standard mutual-exclusion lock. The
following sequence can then be used to synchronize between an APLIC and
a specific hart:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>At the hart&#8217;s IMSIC, clear the pending bit for the specific minor
interrupt identity \(i\) used exclusively for APLIC
synchronization.</p>
</li>
<li>
<p>Acquire the shared lock for the APLIC&#8217;s <code>genmsi</code> register.</p>
</li>
<li>
<p>Write <code>genmsi</code> to generate an MSI to the hart with interrupt
identity \(i\).</p>
</li>
<li>
<p>Repeatedly read <code>genmsi</code> until bit Busy is false.</p>
</li>
<li>
<p>Release the lock for <code>genmsi</code>.</p>
</li>
<li>
<p>Repeatedly read the pending bit for minor interrupt identity
\(i\) at the hart&#8217;s IMSIC until it is found set.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The loops of steps 4 and 6 are expected normally to succeed very
quickly, often on the first or second attempt. When this sequence is
complete, all earlier MSIs from the APLIC must also have arrived at the
hart&#8217;s IMSIC.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="MSLevel"><a class="anchor" href="#MSLevel"></a>5. Interrupts for Machine and Supervisor Levels</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The RISC-V Privileged Architecture defines several major identities in the
range 0-15 for interrupts at a hart, including machine-level and
supervisor-level external interrupts (numbers 11 and 9), machine- and
supervisor-level timer interrupts (7 and 5), and machine- and
supervisor-level software interrupts (3 and 1). Beyond these major
labels, the <em>external</em> interrupts at each privilege level are given
secondary, minor identities by an external interrupt controller such as
an APLIC or IMSIC, distinguishing interrupts from different devices or
causes. These minor identities for external interrupts were covered in
<a href="#IMSIC">Chapter 3</a> and <a href="#AdvPLIC">Chapter 4</a> specifying the IMSIC and APLIC components.</p>
</div>
<div class="paragraph">
<p>The Advanced Interrupt Architecture reserves another 24 major interrupt
identities for additional <em>local interrupts</em> that arise within or in
close proximity to the hart, often for reporting errors. A mechanism is
also defined that allows software to selectively delegate both local and
custom interrupts to the next less-privileged level, or in some cases to
inject entirely virtual interrupts into a less-privileged level.</p>
</div>
<div class="paragraph">
<p>Lastly, an optional facility lets software assign priorities to major
interrupts (such as the timer and software interrupts, and any local
interrupts) such that they may mix with the priorities set for external
interrupts by a PLIC, APLIC, or IMSIC.</p>
</div>
<div class="sect2">
<h3 id="majorIntrs"><a class="anchor" href="#majorIntrs"></a>5.1. Defined major interrupts and default priorities</h3>
<div class="paragraph">
<p><a href="#TablemajorIntrs">Table 8</a> lists all the major interrupts
currently defined for RISC-V harts that conform to this Advanced Interrupt
Architecture (AIA). Besides the major interrupts specified by the
RISC-V Privileged Architecture, the AIA adds interrupt numbers 35 and 43 as
local interrupts for low- and high-priority <em>RAS events</em>.</p>
</div>
<table id="TablemajorIntrs" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 8. The standard major interrupt codes, listed in default priority order</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Default priority order</th>
<th class="tableblock halign-left valign-top">Major interrupt numbers</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top" rowspan="3"><p class="tableblock">Highest<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
Lowest</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">43</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Local interrupt: high-priority RAS event</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">11, 3, 7<br>
9, 1, 5<br>
12<br>
10, 2, 6<br>
13</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Machine interrupts: external, software, timer<br>
Supervisor interrupts: external, software, timer<br>
Supervisor guest external interrupt<br>
VS interrupts: external, software, timer<br>
Local interrupt: counter overflow</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">35</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Local interrupt: low-priority RAS event</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The default priority order in <a href="#TablemajorIntrs">Table 8</a> is applicable only
when multiple major interrupts would trap to the same privilege mode.
Interrupt traps to a more-privileged mode always have
priority over traps to a less-privileged mode.</p>
</div>
<table id="TablemajorIntrCategories" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 9. Categorization of current and future major interrupts.</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Major interrupt numbers</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Category</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0-12<br>
13-15</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Not Local interrupts<br>
Local interrupts</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Assigned by the<br>
Privileged Architecture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">16-23<br>
24-31<br>
32-47<br>
&#8805; 48</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Local interrupts<br>
<em>Designated for custom use</em><br>
Local interrupts<br>
<em>Designated for custom use</em></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Of the major interrupts controlled by the base Privileged Architecture
(numbers 0-15), the AIA categorizes the counter overflow interrupt
(code 13) as a <em>local interrupt</em>. It is assumed furthermore that any
future definitions for reserved interrupt numbers 14 and 15 will also be
local interrupts. Besides the two RAS interrupts, the AIA additionally
reserves major interrupt numbers in the ranges 16-23 and 32-47 for
standard local interrupts that other RISC-V extensions may define. The
remaining major interrupts allocated to the Privileged Architecture,
numbers 0-12, are categorized as not local interrupts. Taken altogether,
<a href="#TablemajorIntrCategories">Table 9</a> summarizes the AIA&#8217;s categorization of all major interrupt identities.</p>
</div>
<div class="paragraph">
<p><em>RAS</em> is an abbreviation for <em>Reliability, Availability, and
Serviceability</em>. Typically a RAS event corresponds to the detection of
corrupted data (e.g. as a result of a soft or hard error) and/or the use
of such data. The high-priority RAS event local interrupt may, for
example, signal an occurrence of an urgent uncorrected error that needs
action from a RAS error handler to contain the error and, if possible,
to recover from it. The low-priority RAS event local interrupt may, for
example, be triggered by non-urgent deferred or corrected errors.</p>
</div>
<div class="paragraph">
<p>The AIA does not itself require that detected RAS events trigger one of
the two local interrupts defined for this purpose. Systems are free to
report any or all RAS events another way, such as by external interrupts
routed through an APLIC or IMSIC, or by custom interrupts.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In all likelihood, the method for reporting a particular RAS event will
depend on where in the system the event is detected. The AIA defines
local interrupt numbers for RAS events so systems have a standard way to
report such events when detected locally at a hart, without depending
solely on external or custom interrupts.</p>
</div>
<div class="paragraph">
<p>As always, platform standards may further constrain how a system reports
events, whether RAS events or other.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>For the standard local interrupts not defined by the base RISC-V Privileged
Architecture (numbers 16-23 and 32-47), the current plan is to assign
default priorities in the order shown in this table:</p>
</div>
<table class="tableblock frame-all grid-all fit-content center">
<colgroup>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top" rowspan="3"><p class="tableblock">Highest<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
Lowest</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">47, 23, 46, 45, 22, 44,<br>
43, 21, 42, 41, 20, 40</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">11, 3, 7<br>
9, 1, 5<br>
12<br>
10, 2, 6<br>
13</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Machine interrupts: external, software, timer<br>
Supervisor interrupts: external, software, timer<br>
Supervisor guest external interrupt<br>
VS interrupts: external, software, timer<br>
Counter overflow interrupt</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">39, 19, 38, 37, 18, 36,<br>
35, 17, 34, 33, 16, 32</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Among interrupts 16-23, a higher interrupt number conveys higher default
priority, and likewise for interrupts 32-47. These two groups are
interleaved together in the complete order, and the Privileged
Architecture&#8217;s standard interrupts, 0-15, are inserted into the middle
of the sequence. This proposed default priority order is arranged so
that interrupts 0-31 can potentially be an adequate subset on their own
for 32-bit RISC-V systems.</p>
</div>
<div class="paragraph">
<p>In actuality, future RISC-V extensions may or may not stick to this plan for
the default priority order of interrupts they define.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In addition to the existing major interrupts of
<a href="#TablemajorIntrs">Table 8</a>, the following local interrupts
are tentatively proposed, listed in order of decreasing default
priority:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">23</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bus or system error</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">45</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Per-core high-power or over-temperature event</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">17</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Debug/trace interrupt</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>These local interrupts are expected to be specified by other RISC-V extensions.
Be aware, this list is not final and may change as the relevant
extensions are developed and ratified.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If a future version of the RISC-V Privileged Architecture defines interrupt 0,
the Advanced Interrupt Architecture needs it to have a default priority
lower than certain external interrupts. See <a href="#mtopi">Section 5.2.2</a>
and <a href="#stopi">Section 5.4.2</a> on CSRs <code>mtopi</code> and <code>stopi</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Interrupt numbers 24-31 and 48 and higher are all designated for custom
use. If a hart implements any custom interrupts, their positions in the
default priority order must be documented for the hart.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>While many of the standard registers such as <code>mip</code> and <code>mie</code> have space for major
interrupts only in the range 0-63, custom interrupts with numbers 64 and
above are conceivable with added custom support. CSRs <code>mtopi</code>
(<a href="#mtopi">Section 5.2.2</a>) and <code>stopi</code> (<a href="#stopi">Section 5.4.2</a>) allow for
major interrupt numbers potentially as large as 4095.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When a hart supports the arbitrary configuration of interrupt priorities
by software (described in later sections), the default priority order
still remains relevant for breaking ties when two interrupt sources are
assigned the same priority number.</p>
</div>
</div>
<div class="sect2">
<h3 id="interrupts-at-machine-level"><a class="anchor" href="#interrupts-at-machine-level"></a>5.2. Interrupts at machine level</h3>
<div class="paragraph">
<p>For whichever standard local interrupts are implemented, the
corresponding bits in CSRs <code>mip</code> and <code>mie</code>  must be writable, and the corresponding
bits in <code>mideleg</code> (if that CSR exists because supervisor mode is implemented) must
each either be writable or be hardwired to zero. An occurrence of a
local interrupt event causes the interrupt-pending bit in <code>mip</code> to be set to
one. This bit then remains set until cleared by software.</p>
</div>
<div class="paragraph">
<p>As established by the base RISC-V Privileged Architecture, an interrupt traps to
M-mode whenever all of the following are true: (a) either the current
privilege mode is M-mode and machine-level interrupts are enabled by the
MIE bit of <code>mstatus</code>, or the current privilege mode has less privilege than
M-mode; (b) matching bits in <code>mip</code> and <code>mie</code> are both one; and (c) if <code>mideleg</code> exists, the corresponding bit in <code>mideleg</code> is zero.</p>
</div>
<div class="paragraph">
<p>When multiple interrupt causes are ready to trigger simultaneously, the
interrupt taken first is determined by priority order, which may be the
default order specified in the previous section <a href="#majorIntrs">Section 5.1</a>, or may be a modified order configured by software.</p>
</div>
<div class="sect3">
<h4 id="intrPrios-M"><a class="anchor" href="#intrPrios-M"></a>5.2.1. Configuring priorities of major interrupts at machine level</h4>
<div class="paragraph">
<p>The machine-level priorities for major interrupts 0-63 may be configured
by a set of registers accessed through the <code>miselect</code> and <code>mireg</code> CSRs introduced in
<a href="#CSRs">Chapter 2</a>. When XLEN = 32, sixteen of these registers are defined, listed below with their <code>miselect</code> addresses:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x30</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iprio0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x31</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iprio1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x3F</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iprio15</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Each register controls the priorities of four interrupts, with one 8-bit
byte per interrupt. For a number \(k\) in the range 0-15,
register <code>iprio</code>\(k\) controls the priorities of interrupts
\(k\times{4}\) through
\({k\times{4}+{3}}\), formatted as follows:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bits 7:0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Priority number for interrupt \(k\times{4}\)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bits 15:8</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Priority number for interrupt \(k\times{4}+{1}\)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bits 23:16</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Priority number for interrupt \(k\times{4}+{2}\)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bits 31:24</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Priority number for interrupt \(k\times{4}+{3}\)</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>When XLEN = 64, only the even-numbered registers exist:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x30</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iprio0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x32</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iprio2</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x3E</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iprio14</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Each register controls the priorities of eight interrupts. For
even \(k\) in the range 0-14, register <code>iprio</code>\(k\)
controls the priorities of interrupts \(k\times{4}\)
through \({k\times{4}+{7}}\), formatted as follows:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bits 7:0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Priority number for interrupt \(k\times{4}\)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bits 15:8</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Priority number for interrupt \(k\times{4}+{1}\)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bits 23:16</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Priority number for interrupt \(k\times{4}+{2}\)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bits 31:24</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Priority number for interrupt \(k\times{4}+{3}\)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bits 39:32</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Priority number for interrupt \(k\times{4}+{4}\)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bits 47:40</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Priority number for interrupt \(k\times{4}+{5}\)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bits 55:48</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Priority number for interrupt \(k\times{4}+{6}\)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bits 63:56</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Priority number for interrupt \(k\times{4}+{7}\)</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>When XLEN = 64 and <code>miselect</code> is an odd value in the range <code>0x31</code>-<code>0x3F</code>, attempting to access <code>mireg</code> raises an illegal instruction exception.</p>
</div>
<div class="paragraph">
<p>The valid registers <code>iprio0</code>-<code>iprio15</code> are known collectively as the <code><em>iprio</em></code> <em>array</em> for machine level.</p>
</div>
<div class="paragraph">
<p>The width of priority numbers for external interrupts is <em>IPRIOLEN</em>.
This parameter is affected by the main external interrupt controller for
the hart, whether a PLIC, APLIC, or IMSIC.</p>
</div>
<div class="paragraph">
<p>For an APLIC, IPRIOLEN is in the range 1-8 as specified in <a href="#AdvPLIC">Chapter 4</a> on the APLIC.</p>
</div>
<div class="paragraph">
<p>For an IMSIC, IPRIOLEN is 6, 7, or 8. IPRIOLEN may be 6 only if the
number of external interrupt identities implemented by the IMSIC is 63.
IPRIOLEN may be 7 only if the number of external interrupt identities
implemented by the IMSIC is no more than 127. IPRIOLEN may be 8 for any
IMSIC, regardless of the number of external interrupt identities
implemented.</p>
</div>
<div class="paragraph">
<p>Each byte of a valid <code>iprio</code>\(k\) register is either a read-only zero
or a <strong>WARL</strong> unsigned integer field implementing exactly IPRIOLEN bits. For a
given interrupt number, if the corresponding bit in <code>mie</code> is read-only zero,
then the interrupt&#8217;s priority number in the <code>iprio</code> array must be read-only zero
as well. The priority number for a machine-level external interrupt
(bits 31:24 of register <code>iprio2</code>) must also be read-only zero. Aside from these
two restrictions, implementations may freely choose which priority
number fields are settable and which are read-only zeros. If all bytes
in the <code>iprio</code> array are read-only zeros, priorities can be configured only for
external interrupts, not for any other interrupts.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Platform standards may require that priorities be configurable for
certain interrupt causes.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>iprio</code> array accessed via <code>miselect</code> and <code>mireg</code> affects the prioritization of interrupts only when they trap to M-mode. When an interruptâ€™s priority number in the
array is zero (either read-only zero or set to zero), its priority is
the default order from <a href="#majorIntrs">Section 5.1</a>. Setting an
interrupt&#8217;s priority number instead to a nonzero value \(p\)
gives that interrupt nominally the same priority as a machine-level
external interrupt with priority number \(p\). For a major
interrupt that defaults to a higher priority than machine external
interrupts, setting its priority number to a nonzero value <em>lowers</em> its
priority. For a major interrupt that defaults to a lower priority than
machine external interrupts, setting its priority number to a nonzero
value <em>raises</em> its priority. When two interrupt causes have been
assigned the same nominal priority, ties are broken by the default
priority order. <a href="#TableintrPrios-M">Table 10</a> summarizes the effect of priority numbers on interrupt priority.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When a hart has an IMSIC supporting more than 255 minor identities for
external interrupts, the only non-default priorities that can be
configured for other interrupts are those corresponding to external
interrupt identities 1-255, not those of identities 256 or higher.</p>
</div>
</td>
</tr>
</table>
</div>
<table id="TableintrPrios-M" class="tableblock frame-all grid-all stretch center">
<caption class="title">Table 10. Effect of the machine-level iprio array on the priorities of interrupts taken in M-mode. For interrupts with the same priority number, the default order of <a href="#majorIntrs">Section 5.1</a> prevails.</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top"></th>
<th class="tableblock halign-center valign-top">Interrupts with default priority above machine external interrupts</th>
<th class="tableblock halign-center valign-top">Machine external interrupts</th>
<th class="tableblock halign-center valign-top">Interrupts with default priority below machine external interrupts</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Priority<br>
order</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Priority number in machine-level <code>iprio</code> array</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Priority number from interrupt controller (APLIC or IMSIC)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Priority number in machine-level <code>iprio</code> array</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Highest</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<br>
2<br>
&#8230;&#8203;<br>
254<br>
255</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<br>
2<br>
&#8230;&#8203;<br>
254<br>
255</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<br>
2<br>
&#8230;&#8203;<br>
254<br>
255</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">256 and above (IMSIC only)</p></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Lowest</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Implementing the priority configurability of this section requires that
a RISC-V hart&#8217;s external interrupt controller communicate to the hart not only
the existence of a pending-and-enabled external interrupt but also the
interrupt&#8217;s priority number. Typically this implies that the width of
the connection for signaling an external interrupt to the hart is not
just a single wire as usual but now \({IPRIOLEN} + 1$\)
wires.</p>
</div>
<div class="paragraph">
<p>It is expected that many systems will forego priority configurability of
major interrupts and simply have the array be all read-only zeros.
Systems that need this priority configurability can try to arrange for
each hart&#8217;s external interrupt controller to be relatively close to the
hart, by, for example, limiting the system to at most a few small cores
connected to an APLIC, or alternatively by giving every hart its own
IMSIC.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If supported, setting the priority number for supervisor-level external
interrupts (bits 15:8 of <code>iprio2</code>) to a nonzero value \(p\) has the
effect of giving the entire category of supervisor external interrupts
nominally the same priority as a machine external interrupt with
priority number \(p\). But note that this applies only to the
case when supervisor external interrupts trap to M-mode.</p>
</div>
<div class="paragraph">
<p>(Because supervisor guest external interrupts and VS-level external
interrupts are required to be delegated to supervisor level when the
H extension is implemented, the machine-level priority numbers
for these interrupts are always ignored and should be read-only zeros.)</p>
</div>
<div class="paragraph">
<p>If the system has an original PLIC for backward compatibility with older
software, reset should initialize the machine-level <code>iprio</code> array to all zeros.</p>
</div>
</div>
<div class="sect3">
<h4 id="mtopi"><a class="anchor" href="#mtopi"></a>5.2.2. Machine top interrupt CSR (<code>mtopi</code>)</h4>
<div class="paragraph">
<p>Machine-level CSR <code>mtopi</code> is read-only with width MXLEN. A read of <code>mtopi</code> returns
information about the highest-priority pending-and-enabled interrupt for
machine level, in this format:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bits 27:16</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IID</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bits 7:0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IPRIO</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>All other bits of <code>mtopi</code> are reserved and read as zeros.</p>
</div>
<div class="paragraph">
<p>The value of <code>mtopi</code> is zero unless there is an interrupt pending in <code>mip</code> and enabled
in <code>mie</code> that is not delegated to a less-privileged level. When there is a
pending-and-enabled major interrupt for machine level, field IID
(Interrupt Identity) is the major identity number of the
highest-priority interrupt, and field IPRIO indicates its priority.</p>
</div>
<div class="paragraph">
<p>If all bytes of the machine-level <code>iprio</code> array are read-only zeros, a
simplified implementation of field IPRIO is allowed in which its value
is always 1 whenever <code>mtopi</code> is not zero.</p>
</div>
<div class="paragraph">
<p>Otherwise, when <code>mtopi</code> is not zero, if the priority number for the reported
interrupt is in the range 1 to 255, IPRIO is simply that number. If the
interrupt&#8217;s priority number is zero or greater than 255, IPRIO is set to
either 0 or 255 as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the interrupt&#8217;s priority number is greater than 255, then IPRIO is
255 (lowest representable priority).</p>
</li>
<li>
<p>If the interrupt&#8217;s priority number is zero and interrupt number IID
has a default priority higher than a machine external interrupt, then
IPRIO isÂ 0 (highest priority).</p>
</li>
<li>
<p>If the interrupt&#8217;s priority number is zero and interrupt number IID
has a default priority lower than a machine external interrupt, then
IPRIO is 255 (lowest representable priority).</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>To ensure that <code>mtopi</code> is never zero when an interrupt is pending and enabled
for machine level, if major interrupt 0 can trap to M-mode, it must have
a default priority lower than a machine external interrupt.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The value of <code>mtopi</code> is not affected by the global interrupt enable MIE in CSR <code>mstatus</code>.</p>
</div>
<div class="paragraph">
<p>The RISC-V Privileged Architecture ensures that, when the value of <code>mtopi</code> is not zero,
a trap is taken to M-mode for the interrupt indicated by field IID if
either the current privilege mode is M and <code>mstatus</code>.MIE is one, or the current
privilege mode has less privilege than M-mode. The trap itself does not
cause the value of <code>mtopi</code> to change.</p>
</div>
<div class="paragraph">
<p>The following pseudocode shows how a machine-level trap handler might
read <code>mtopi</code> to avoid redundant restoring and saving of processor registers when
an interrupt arrives during the handling of another trap (either a
synchronous exception or an earlier interrupt):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">save processor registers
i = read CSR mcause
if (i &gt;= 0) {
    handle synchronous exception i
    restore mstatus if necessary
}
if (mstatus.MPIE == 1) {
    loop {
        i = read CSR mtopi
        if (i == 0) exit loop
        i = i&gt;&gt;16
        call the interrupt handler for major interrupt i
    }
}
restore processor registers
return from trap</code></pre>
</div>
</div>
<div class="paragraph">
<p>(This example can be further optimized, but with an increase in complexity.)</p>
</div>
<div class="paragraph">
<p>In order for this algorithm to function correctly, <code>mstatus</code>.MPIE must
be set to 1 before executing an MRET that changes the privilege mode.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Assuming <code>mstatus</code> is saved and restored by trap handlers at entry
and exit as is common, it is sufficient to set <code>mstatus</code>.MPIE = 1
only once, before the first use of MRET that changes privilege mode.
After an MRET, a trap back to M-mode will restore <code>mstatus</code>.MPIE = 1;
and if the trap handler preserves <code>mstatus</code>, it will
still be true before the next MRET that ends the handler.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="virtIntrs-S"><a class="anchor" href="#virtIntrs-S"></a>5.3. Interrupt filtering and virtual interrupts for supervisor level</h3>
<div class="paragraph">
<p>When supervisor mode is implemented, the Advanced Interrupt Architecture
adds a facility for software filtering of interrupts and for virtual
interrupts, making use of new CSRs <code>mvien</code> (Machine Virtual Interrupt Enables)
and <code>mvip</code> (Machine Virtual Interrupt-Pending bits). <em>Interrupt filtering</em>
permits a supervisor-level interrupt (SEI or SSI) or local or custom
interrupt to trap to M-mode and then be selectively delegated by
software to supervisor level, even while the corresponding bit in <code>mideleg</code>
remains zero. The same hardware may also, under the right circumstances,
allow machine level to assert <em>virtual interrupts</em> to supervisor level
that have no connection to any real interrupt events.</p>
</div>
<div class="paragraph">
<p>Just as with CSRs <code>mip</code>, <code>mie</code>, and <code>mideleg</code>, each bit of registers <code>mvien</code> and <code>mvip</code> corresponds with an interrupt number in the range 0-63. When a bit in <code>mideleg</code> is zero and the matching bit in <code>mvien</code> is one, then the same bit position in <code>sip</code> is an alias
for the corresponding bit in <code>mvip</code>. A bit in <code>sip</code> is read-only zero when the
corresponding bits in <code>mideleg</code> and <code>mvien</code> are both zero. The combined effects of <code>mideleg</code> and <code>mvien</code> on <code>sip</code> and <code>sie</code> are summarized in
<a href="#TableintrFilteringForS">Table 11</a>.</p>
</div>
<table id="TableintrFilteringForS" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 11. The effects of <code>mideleg</code> and <code>mvien</code> on <code>sip</code> and <code>sie</code> (except for the H extension&#8217;s VS-level interrupts, which appear in <code>hip</code> and <code>hie</code> instead of <code>sip</code> and <code>sie</code>). A bit in <code>mvien</code> can be set to 1 only for major interrupts 1, 9, and 13-63. For interrupts 0-12, some aliases of <code>mip</code> bits in <code>sip</code> may be read-only copies, as specified by the base Privileged Architecture.</caption>
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">mideleg[\(n\)]</th>
<th class="tableblock halign-center valign-top">mvien[\(n\)]</th>
<th class="tableblock halign-center valign-top">sip[\(n\)]</th>
<th class="tableblock halign-center valign-top">sie[\(n\)]</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Read-only 0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Read-only 0</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Alias of <code>mvip</code>[\(n\)]</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Writable</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Alias of <code>mip</code>[\(n\)]</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Alias of <code>mie</code>[\(n\)]</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The name of CSR <code>mvien</code> is not <code>"mvie"</code> because the function of this register is
more analogous to <code>mcounteren</code> than to <code>mie</code>. The bits of <code>mvien</code> control whether the virtual interrupt-pending bits in register <code>mvip</code> are active and visible at supervisor
level. This is different than how the usual interrupt-enable bits (such
as in <code>mie</code>) mask pending interrupts.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A bit in <code>sie</code> is writable if and only if the corresponding bit is set in
either <code>mideleg</code> or <code>mvien</code>. When an interrupt is delegated by <code>mideleg</code>, the writable bit in <code>sie</code> is an alias of the corresponding bit in <code>mie</code>; else it is an independent
writable bit. As usual, bits that are not writable in <code>sie</code> must be read-only
zeros.</p>
</div>
<div class="paragraph">
<p>If a bit of <code>mideleg</code> is zero and the corresponding bit in <code>mvien</code> is changed from zero to one, then the value of the matching bit in <code>sie</code> becomes UNSPECIFIED. Likewise, if a bit of <code>mvien</code> is one and the corresponding bit in <code>mideleg</code> is changed from one to zero, the value of the matching bit in <code>sie</code> again becomes UNSPECIFIED.</p>
</div>
<div class="paragraph">
<p>For interrupt numbers 13-63, implementations may freely choose which
bits of <code>mvien</code> are writable and which bits are read-only zero or one. If such a
bit in <code>mvien</code> is read-only zero (preventing the virtual interrupt from being
enabled), the same bit should be read-only zero in <code>mvip</code>. All other bits for
interrupts 13-63 must be writable in <code>mvip</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Platform standards or other extensions may require that bits of <code>mvien</code> for
certain interrupt causes be writable, or be read-only zero or one.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The bits of <code>mvien</code> for supervisor software interrupts (code 1) and supervisor
external interrupts (code 9) are each either writable or read-only zero;
they cannot be read-only ones. The other bits of <code>mvien</code> for interrupts 0-12 are
reserved and must be read-only zeros.</p>
</div>
<div class="paragraph">
<p>It is strongly recommended that bit 9 of <code>mvien</code> be writable. Furthermore, if
bit 1 (SSIP) of <code>mip</code> can be set automatically by an interrupt controller and
not just by explicit writes to <code>mip</code> or <code>sip</code>, it is strongly recommended that
bit 1 of <code>mvien</code> also be writable.</p>
</div>
<div class="paragraph">
<p>When bit 1 of <code>mvien</code> is zero, bit 1 of <code>mvip</code> is an alias of the same bit (SSIP) of <code>mip</code>. But when bit 1 of <code>mvien</code> is one, bit 1 of <code>mvip</code> is a separate writable bit
independent of <code>mip</code>.SSIP. When the value of bit 1 of <code>mvien</code> is changed from zero to
one, the value of bit 1 of <code>mvip</code> becomes UNSPECIFIED.</p>
</div>
<div class="paragraph">
<p>Bit 5 of <code>mvip</code> is an alias of the same bit (STIP) in <code>mip</code> when that bit is writable
in <code>mip</code>. When STIP is not writable in <code>mip</code> (such as when <code>menvcfg</code>.STCE = 1), bit 5 of <code>mvip</code> is read-only zero.</p>
</div>
<div class="paragraph">
<p>When bit 9 of <code>mvien</code> is zero, bit 9 of <code>mvip</code> is an alias of the software-writable
bit 9 of <code>mip</code> (SEIP). But when bit 9 of <code>mvien</code> is one, bit 9 of <code>mvip</code> is a writable bit independent of <code>mip</code>.SEIP. Unlike for bit 1, changing the value of bit 9 of <code>mvien</code>
does not affect the value of bit 9 of <code>mvip</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The base Privileged Architecture specifies unusual read/write behavior
for what it calls the software-writable SEIP bit of register <code>mip</code>.
When bit 9 of <code>mvien</code> is zero, bit 9 of <code>mvip</code> makes the software-writable SEIP bit of <code>mip</code> directly accessible by itself.
Furthermore, as explained below, setting bit 9 of <code>mvien</code> to one
separates the software-writable SEIP bit from <code>mip</code> entirely,
so it is then just a writable bit in <code>mvip</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Except for bits 1, 5, and 9 as specified above, the bits of <code>mvip</code> in the range
12:0 are reserved and must be read-only zeros.</p>
</div>
<div class="paragraph">
<p>The value of bit 9 of <code>mvien</code> has some additional consequences for supervisor
external interrupts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When bit 9 of <code>mvien</code> is zero, the software-writable SEIP bit (bit 9 of <code>mvip</code>)
interacts with reads and writes of <code>mip</code> in the way specified by the base RISC-V
Privileged Architecture. In particular, for most purposes, the value of
bit 9 of <code>mvip</code> is logically ORed into the readable value of <code>mip</code>.SEIP. But when
bit 9 of <code>mvien</code> is one, bit SEIP in <code>mip</code> is read-only and does not include the value
of bit 9 of <code>mvip</code>. Rather, the value of <code>mip</code>.SEIP is simply the supervisor
external interrupt signal from the hart&#8217;s external interrupt controller
(APLIC or IMSIC).</p>
</li>
<li>
<p>If the hart has an IMSIC, then when bit 9 of <code>mvien</code> is one, attempts from
S-mode to explicitly access the supervisor-level interrupt file raise an
illegal instruction exception. The exception is raised for attempts to
access CSR <code>stopei</code>, or to access <code>sireg</code> when <code>siselect</code> has a value in the range <code>0x70</code>-<code>0xFF</code>. Accesses to guest interrupt files (through <code>vstopei</code> or <code>viselect</code>+<code>vsireg</code>) are not affected.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When the H extension is implemented, if a bit is zero in the
same position in both <code>mideleg</code> and <code>mvien</code>, then that bit is read-only zero in <code>hideleg</code> (in addition to being read-only zero in <code>sip</code>, <code>sie</code>, <code>hip</code>, and <code>hie</code>). But if a bit for one of interrupts 13-63 is a one in either <code>mideleg</code> or <code>mvien</code>, then the same bit in <code>hideleg</code> may be writable or may be read-only zero, depending on the implementation. No bits in <code>hideleg</code> are ever read-only ones. The H extension further constrains bits 12:0 of <code>hideleg</code>.</p>
</div>
<div class="paragraph">
<p>When supervisor mode is implemented, the minimal required implementation of <code>mvien</code> and <code>mvip</code> has all bits being read-only zeros except for <code>mvip</code> bits 1 and 9, and sometimes bit 5, each of which is an alias of an existing writable bit in <code>mip</code>. (Although, as noted, it is strongly recommended that bit 9 of <code>mvien</code> also be writable.) When supervisor mode is not implemented, registers <code>mvien</code> and <code>mvip</code> do not exist.</p>
</div>
</div>
<div class="sect2">
<h3 id="intrs-S"><a class="anchor" href="#intrs-S"></a>5.4. Interrupts at supervisor level</h3>
<div class="paragraph">
<p>If a standard local interrupt becomes pending (= 1) in <code>sip</code>, the bit in <code>sip</code> is
writable and will remain set until cleared by software.</p>
</div>
<div class="paragraph">
<p>Just as for machine level, the taking of interrupt traps at supervisor level remains essentially the same as specified by the base RISC-V Privileged Architecture. An interrupt traps into S-mode (or HS-mode) whenever all of the following are true: (a) either the current privilege mode is S-mode and supervisor-level interrupts are enabled by the SIE bit of <code>sstatus</code>, or the current privilege mode has less privilege than S-mode; (b) matching bits in <code>sip</code> and <code>sie</code> are both one, or, if the H extension is implemented, matching bits in <code>hip</code> and <code>hie</code> are both one; and (c) if the H extension is implemented, the corresponding bit in <code>hideleg</code> is zero.</p>
</div>
<div class="sect3">
<h4 id="intrPrios-S"><a class="anchor" href="#intrPrios-S"></a>5.4.1. Configuring priorities of major interrupts at supervisor level</h4>
<div class="paragraph">
<p>Supervisor-level priorities for major interrupts 0-63 are optionally configurable in an array of supervisor-level <code>iprio</code>\(k\) registers accessed through  <code>siselect</code> and <code>sireg</code>. This array has the same structure when XLEN = 32 or 64 as does the machine-level <code>iprio</code> array. To summarize, when XLEN = 32, there are sixteen 32-bit registers with these <code>siselect</code> addresses:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x30</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iprio0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x31</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iprio1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x3F</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iprio15</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Each register controls the priorities of four interrupts, one 8-bit byte per interrupt. When XLEN = 64, only the even-numbered registers exist:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x30</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iprio0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x32</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iprio2</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>&#8230;&#8203;</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x3E</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iprio14</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Each register controls the priorities of eight interrupts. If XLEN = 64 and <code>siselect</code> is an odd value in the range <code>0x31</code>-<code>0x3F</code>, attempting to access <code>sireg</code> raises an illegal instruction exception.</p>
</div>
<div class="paragraph">
<p>The valid registers <code>iprio0</code>-<code>iprio15</code> are known collectively as the <code><em>iprio</em></code> <em>array</em> for supervisor level. Each byte of a valid <code>iprio</code>\(k\) register is either a read-only zero or a <strong>WARL</strong> unsigned integer field implementing exactly IPRIOLEN bits.</p>
</div>
<div class="paragraph">
<p>For a given interrupt number, if the corresponding bit is not writable
either in <code>sie</code> or, if the H extension is implemented, in <code>hie</code>,
then the interrupt&#8217;s priority number in the supervisor-level <code>iprio</code> array must be read-only zero as well. The priority number for a supervisor-level external interrupt (bits 15:8 of <code>iprio2</code>) must also be read-only zero. Aside from these two restrictions, implementations may freely choose which priority number fields are settable and which are read-only zeros.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>As always, platform standards may require that priorities be
configurable for certain interrupt causes.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It is expected that many higher-end systems will not support the ability
to configure the priorities of major interrupts at supervisor level as
described in this section. Linux in particular is not designed to take
advantage of such facilities if provided. The <code>iprio</code> array must be accessible
but may simply be all read-only zeros.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The supervisor-level <code>iprio</code> array accessed via <code>siselect</code> and <code>sireg</code> affects the prioritization of interrupts only when they trap to S-mode. When an interrupt&#8217;s priority number in the array is zero (either read-only zero or set to zero), its priority is the default order from <a href="#majorIntrs">Section 5.1</a>. Setting an interrupt&#8217;s priority number instead to a nonzero value \(p\) gives that interrupt nominally the same priority as a supervisor-level external interrupt with priority number \(p\). For an interrupt that defaults to a higher priority than supervisor external interrupts, setting its priority number to a nonzero value lowers its priority. For an interrupt that defaults to a lower priority than supervisor external interrupts, setting its priority number to a nonzero value raises its priority. When two interrupt causes have been assigned the same nominal priority, ties are broken by the default priority order. <a href="#TableintrPrios-S">Table 12</a> summarizes the effect of priority numbers on interrupt priority.</p>
</div>
<div class="paragraph">
<p>If supported, setting the priority number for VS-level external interrupts (bits 23:16 of <code>iprio2</code>) to a nonzero value \(p\) has the effect of giving the entire category of VS external interrupts nominally  the same priority as a supervisor external interrupt with priority number \(p\), when VS external interrupts trap to S-mode.</p>
</div>
<table id="TableintrPrios-S" class="tableblock frame-all grid-all stretch center">
<caption class="title">Table 12. Effect of the supervisor-level iprio array on the priorities of interrupts taken in S-mode. For interrupts with the same priority number, the default order of <a href="#majorIntrs">Section 5.1</a> prevails.</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top"></th>
<th class="tableblock halign-center valign-top">Interrupts with default priority above supervisor external interrupts</th>
<th class="tableblock halign-center valign-top">Supervisor external interrupts</th>
<th class="tableblock halign-center valign-top">Interrupts with default priority below supervisor external  interrupts</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Priority<br>
order</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Priority number in supervisor-level <code>iprio</code> array</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Priority number from interrupt controller (APLIC or IMSIC)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Priority number in supervisor-level <code>iprio</code> array</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Highest</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<br>
2<br>
&#8230;&#8203;<br>
254<br>
255</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<br>
2<br>
&#8230;&#8203;<br>
254<br>
255</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<br>
2<br>
&#8230;&#8203;<br>
254<br>
255</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">256 and above (IMSIC only)</p></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Lowest</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>If bit 9 for a supervisor external interrupt (SEI) is one
in <code>mideleg</code> or <code>mvien</code> and in <code>mvip</code>, causing <code>sip</code>.SEIP to be one,
but there is no supervisor-level interrupt from the hart&#8217;s external
interrupt controller (APLIC or IMSIC), then a priority number for
the SEI is not supplied by the external interrupt controller as usual.
In that case, the SEI is assigned a priority number of 256.</p>
</div>
<div class="paragraph">
<p>If the system has an original PLIC for backward compatibility with older software, reset should initialize the supervisor-level <code>iprio</code> array to all zeros.</p>
</div>
</div>
<div class="sect3">
<h4 id="stopi"><a class="anchor" href="#stopi"></a>5.4.2. Supervisor top interrupt CSR (<code>stopi</code>)</h4>
<div class="paragraph">
<p>Supervisor-level CSR <code>stopi</code> is read-only with width SXLEN. A read of <code>stopi</code> returns information about the highest-priority pending-and-enabled interrupt for
supervisor level, in this format:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bits 27:16</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IID</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bits 7:0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IPRIO</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>All other bits of <code>stopi</code> are reserved and read as zeros.</p>
</div>
<div class="paragraph">
<p>The value of <code>stopi</code> is zero unless: (a) there is an interrupt that is both pending in <code>sip</code> and enabled in <code>sie</code>, or, if the H extension is implemented, both pending in <code>hip</code> and enabled in <code>hie</code>; and (b) the interrupt is not delegated to a less-privileged level (by <code>hideleg</code>, if the H extension is implemented). When there is a pending-and-enabled major interrupt for supervisor level, field IID is the major identity number of the highest-priority interrupt, and field IPRIO indicates its
priority.</p>
</div>
<div class="paragraph">
<p>If all bytes of the supervisor-level <code>iprio</code> array are read-only zeros, a simplified implementation of field IPRIO is allowed in which its value is always 1 whenever <code>stopi</code> is not zero.</p>
</div>
<div class="paragraph">
<p>Otherwise, when <code>stopi</code> is not zero, if the priority number for the reported interrupt is in the range 1 to 255, IPRIO is simply that number. If the interrupt&#8217;s priority number is zero or greater than 255, IPRIO is set to either 0 or 255 as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the interrupt&#8217;s priority number is greater than 255, then IPRIO is 255 (lowest representable priority).</p>
</li>
<li>
<p>If the interrupt&#8217;s priority number is zero and interrupt number IID has a default priority higher than a supervisor external interrupt, then IPRIO is 0 (highest priority).</p>
</li>
<li>
<p>If the interrupt&#8217;s priority number is zero and interrupt number IID has a default priority lower than a supervisor external interrupt, then IPRIO is 255 (lowest representable priority).</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>To ensure that <code>stopi</code> is never zero when an interrupt is pending and enabled for supervisor level, if major interrupt 0 can trap to S-mode, it must have a default priority lower than a supervisor external interrupt.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The value of <code>stopi</code> is not affected by the global interrupt enable SIE in CSR <code>sstatus</code>.</p>
</div>
<div class="paragraph">
<p>The RISC-V Privileged Architecture ensures that, when the value of <code>stopi</code> is not zero, a trap is taken to S-mode for the interrupt indicated by field IID if either the current privilege mode is S and <code>sstatus</code>.SIE is one, or the current privilege mode has less privilege than S-mode. The trap itself does not cause the value of <code>stopi</code> to change.</p>
</div>
<div class="paragraph">
<p>The following pseudocode shows how a supervisor-level trap handler might
read <code>stopi</code> to avoid redundant restoring and saving of processor registers when
an interrupt arrives during the handling of another trap (either a
synchronous exception or an earlier interrupt):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">save processor registers
i = read CSR scause
if (i &gt;= 0) {
    handle synchronous exception i
    restore sstatus if necessary
}
if (sstatus.SPIE == 1) {
    loop {
        i = read CSR stopi
        if (i == 0) exit loop
        i = i&gt;&gt;16
        call the interrupt handler for major interrupt i
    }
}
restore processor registers
return from trap</code></pre>
</div>
</div>
<div class="paragraph">
<p>(This example can be further optimized, but with an increase in complexity.)</p>
</div>
<div class="paragraph">
<p>In order for this algorithm to function correctly, <code>sstatus</code>.SPIE must
be set to 1 before executing an SRET that changes the privilege mode.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Assuming <code>sstatus</code> is saved and restored by trap handlers at entry
and exit as is common, it is sufficient to set <code>sstatus</code>.SPIE = 1
only once, before the first use of SRET that changes privilege mode.
After an SRET, a trap back to S-mode will restore <code>sstatus</code>.SPIE = 1;
and if the trap handler preserves <code>sstatus</code>, it will
still be true before the next SRET that ends the handler.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="wfi-wait-for-interrupt-instruction"><a class="anchor" href="#wfi-wait-for-interrupt-instruction"></a>5.5. WFI (Wait for Interrupt) instruction</h3>
<div class="paragraph">
<p>The RISC-V Privileged Architecture specifies that instruction WFI (Wait for Interrupt) may suspend execution at a hart until an interrupt is pending for the hart. The Advanced Interrupt Architecture (AIA) redefines when execution must resume following a WFI.</p>
</div>
<div class="paragraph">
<p>According to the base RISC-V Privileged Architecture, instruction execution must resume from a WFI whenever any interrupt is both pending and enabled in CSRs <code>mip</code> and <code>mie</code>, ignoring any delegation indicated by <code>mideleg</code>. With the AIA, this succinct rule is no longer appropriate, due to the mechanisms the AIA adds for virtual interrupts. Instead, execution must resume from a WFI whenever an interrupt is pending at any privilege level (regardless of whether the interrupt privilege level is higher or lower than the hart&#8217;s current privilege mode).</p>
</div>
<div class="paragraph">
<p>An interrupt is pending at machine level if register <code>mtopi</code> is not zero. If S-mode is implemented, an interrupt is pending at supervisor level if <code>stopi</code> is not zero. And if the H extension is implemented, an interrupt is pending at VS level if <code>vstopi</code> (<a href="#vstopi">Section 6.3.3</a>) is not zero.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The AIA&#8217;s rule for WFI gives the same behavior as the base Privileged Architectureâ€™s rule when <code>mvien</code> = 0 and, if the H extension is implemented, also <code>hvien</code> = 0 and <code>hvictl</code>.VTI = 0, thus disabling all virtual interrupts not visible in <code>mip</code>. (The AIA&#8217;s hypervisor registers are covered in the next chapter, "Interrupts for Virtual Machines (VS Level)".)</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="VSLevel"><a class="anchor" href="#VSLevel"></a>6. Interrupts for Virtual Machines (VS Level)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When the H extension is implemented, a hart&#8217;s set of possible
privilege modes includes the <em>virtual supervisor</em> (VS) and <em>virtual
user</em> (VU) modes for hosting virtual harts. The Advanced Interrupt
Architecture adds to the H extension new interrupt facilities
aligned with those described earlier for supervisor-level interrupts.</p>
</div>
<div class="paragraph">
<p>As introduced in <a href="#CSRs">Chapter 2</a>, several hypervisor and VS
CSRs are added: <code>hvien</code>, <code>hvictl</code>, <code>hviprio1</code>, <code>hviprio2</code>, <code>vsiselect</code>, <code>vsireg</code>, <code>vstopei</code>, and <code>vstopi</code>. (And for RV32, the following
high-half CSRs are also added: <code>hidelegh</code>, <code>hvienh</code>, <code>hviph</code>, <code>hviprio1h</code>, <code>hviprio2h</code>, <code>vsiph</code> and <code>vsieh</code>.) As always, when
executing in VS-mode or VU-mode, the VS CSRs substitute for the
corresponding supervisor CSRs.</p>
</div>
<div class="paragraph">
<p>To give software that runs in a virtual machine the appearance of
executing on a real machine that implements the Advanced Interrupt
Architecture at supervisor level, responsibility is shared between
hypervisor software and the hardware facilities described in this
chapter. While some behaviors can be handled directly by hardware,
others require significant emulation by the hypervisor, sometimes with
hardware assistance.</p>
</div>
<div class="sect2">
<h3 id="vs-level-external-interrupts-with-a-guest-interrupt-file"><a class="anchor" href="#vs-level-external-interrupts-with-a-guest-interrupt-file"></a>6.1. VS-level external interrupts with a guest interrupt file</h3>
<div class="paragraph">
<p>When a hart implements the H extension, it is recommended that
the hart also have an IMSIC with guest interrupt files. Assuming guest
interrupt files are available, each can be assigned to a virtual hart at
the physical hart to act as the supervisor-level interrupt file for that
virtual hart. If there are \(N\) guest interrupt files, then
\(N\) virtual harts at that physical hart may each have a
physical guest interrupt file to serve as its (virtual) supervisor-level
interrupt file. The guest interrupt file for the current virtual hart is
always indicated by the VGEIN field of CSR <code>hstatus</code>. When VGEIN is not the valid
number of a guest interrupt file, the current virtual hart has no guest
interrupt file to act as its supervisor-level interrupt file.</p>
</div>
<div class="paragraph">
<p>When <code>hstatus</code>.VGEIN is the valid number of a guest interrupt file, values of <code>vsiselect</code> in
the range <code>0x70</code>-<code>0xFF</code> select registers of this guest interrupt file, just as
values of <code>siselect</code> in the same range select registers of the IMSIC&#8217;s true
supervisor-level interrupt file. The registers of an interrupt file that
are accessed indirectly through <code>vsiselect</code> and <code>vsireg</code> are documented in
<a href="#IMSIC">Chapter 3</a> on the IMSIC, along with IMSIC-only CSR <code>vstopei</code>.
Because all IMSIC interrupt files act identically, the guest interrupt
file that a virtual hart accesses through CSRs <code>siselect</code>, <code>sireg</code>, and <code>stopei</code> is
indistinguishable from a true supervisor-level interrupt file as seen
from S-mode (or HS-mode).</p>
</div>
<div class="paragraph">
<p>In addition to an IMSIC at each hart, a virtual machine may also need to
see a PLIC or APLIC. However, unlike an IMSIC&#8217;s ability to provide
physical guest interrupt files for virtual harts, a PLIC or APLIC must
be emulated for a virtual machine by the hypervisor.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The Advanced Interrupt Architecture does not currently include hardware
assistance for virtualizing an APLIC. For small numbers of harts, such
hardware would be substantially larger than that required to implement
guest interrupt files for an IMSIC. It is assumed that most
high-performance I/O can be done through devices that can send MSIs
directly to guest interrupt files (such as devices attached through a
PCI Express interconnect). For the types of devices whose interrupts
must go through a (virtual) APLIC, the overhead cost of emulating the
APLIC is expected to be less significant.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When a virtual hart appears to have an IMSIC because a guest interrupt
file is assigned to it, all external interrupts, real or emulated,
destined for the virtual hart must go through this perceived IMSIC. A
hypervisor can easily inject an emulated external interrupt into the
guest interrupt file selected by <code>hstatus</code>.VGEIN by setting a bit in the
interrupt-pending array indirectly accessed through <code>vsiselect</code> and <code>vsireg</code>. When a virtual
hart has a guest interrupt file, a hypervisor is not normally expected
to set bit VSEIP in CSR <code>hvip</code>.</p>
</div>
<div class="paragraph">
<p>In the special case that an emulated APLIC for a virtual machine has a
wired interrupt source that equates to an actual interrupt source of a
real APLIC, if software running in this virtual machine configures its
virtual APLIC to forward interrupts from that source as MSIs to a
specific virtual hart, the hypervisor can configure the real APLIC to
forward the actual interrupts directly as MSIs to the virtual hartâ€™s
guest interrupt file. In this way, although the hypervisor must trap and
emulate the virtual machineâ€™s memory accesses that configure the
forwarding of interrupts at the virtual APLIC, the interrupts themselves
can be converted automatically into real MSIs for the guest interrupt
file, without the hypervisor being invoked for each arriving interrupt.</p>
</div>
<div class="sect3">
<h4 id="direct-control-of-a-device-by-a-guest-os"><a class="anchor" href="#direct-control-of-a-device-by-a-guest-os"></a>6.1.1. Direct control of a device by a guest OS</h4>
<div class="paragraph">
<p>To ensure proper support for interrupts, two conditions must be met
before a hypervisor may allow a guest OS running in a virtual machine to
directly control a physical device that sends MSIs: First, each virtual
hart must have a guest interrupt file assigned to it, giving each its
own apparent IMSIC within the virtual machine. Second, interrupts from
the device must be signaled by wire through an APLIC that can translate
these interrupts into MSIs, or the system must have an IOMMU that can
translate the addresses of MSI memory writes made by the device itself.</p>
</div>
<div class="paragraph">
<p>If a guest OS directly controls a device capable of sending MSIs, it
will naturally configure MSIs at the device with the guest physical
addresses the OS sees for the IMSICs of its virtual harts, not knowing
that these addresses are only virtual. When the device performs a memory
write for an MSI, the destination address of this write must be
translated by the IOMMU from the guest physical address assigned by the
guest OS into the true physical address of the target guest interrupt
file, using a translation table supplied by the hypervisor.</p>
</div>
<div class="paragraph">
<p>By design, the translation an IOMMU must do for device MSIs is
fundamentally no different than the address translation the IOMMU
already must perform for other memory accesses from the same device,
converting guest physical addresses into true physical addresses.
Because each virtual hart is assigned a dedicated, physical guest
interrupt file that is indistinguishable from a true supervisor-level
interrupt file, no translation is needed for the data of an MSI write,
which specifies the interrupt&#8217;s identity number in the target interrupt
file.</p>
</div>
</div>
<div class="sect3">
<h4 id="virtHartMigration"><a class="anchor" href="#virtHartMigration"></a>6.1.2. Migrating a virtual hart to a different guest interrupt file</h4>
<div class="paragraph">
<p>When it is necessary to move a virtual hart from one physical hart to
another, if the virtual hart uses a guest interrupt file, the specific
guest interrupt file assigned to it must change from the one in use at
the old physical hart to a different one at the new physical hart.
Because each guest interrupt file is physically tied to a single
physical hart, a virtual hart cannot bring its guest interrupt file with
it when it moves.</p>
</div>
<div class="paragraph">
<p>The process of migrating a virtual hart from one guest interrupt file to
another is more complex than moving most other state held by the virtual
hart. After the destination guest interrupt file has been chosen at the
new physical hart, the following steps are recommended:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>At the old interrupt file, save to memory the values of registers <code>eidelivery</code> and
<code>eithreshold</code>, and set <code>eidelivery</code> = 0.</p>
</li>
<li>
<p>At the new interrupt file, set <code>eidelivery</code> = 0, and zero all implemented
interrupt-pending bits (the <code>eip</code> array).</p>
</li>
<li>
<p>Modify the relevant translation tables at all IOMMUs so that MSIs for
this virtual interrupt file are now sent to the new physical interrupt
file. Likewise, if any interrupts at an APLIC are forwarded by MSIs to
the old interrupt file, reconfigure the APLIC to send them to the new
interrupt file. As needed, synchronize with all IOMMUs and APLICs to
ensure that no straggler MSIs will arrive at the old interrupt file
after this step. Synchronizing with an APLIC can be accomplished using
the algorithm of <a href="#AdvPLIC-MSISync">Section 4.9.3</a>.</p>
</li>
<li>
<p>At the old interrupt file, dump to memory all implemented
interrupt-pending and interrupt-enable bits (the <code>eip</code> and <code>eie</code> arrays). After this
step is done, the old interrupt file is no longer in use.</p>
</li>
<li>
<p>At the new interrupt file, logically OR the interrupt-pending bits
that were saved in step 4 into the new interrupt file, using instruction
CSRS to write to the <code>eip</code> array. Also, load the interrupt-enable bits that
were saved in step 4 into the <code>eie</code> array.</p>
</li>
<li>
<p>At the new interrupt file, load registers <code>eithreshold</code> and <code>eidelivery</code> with the values that
were saved in step 1.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Resuming execution of the virtual hart at the new physical hart is not
recommended until the entire interrupt file has been fully migrated.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Resuming execution of the virtual hart before the interrupt file is
fully migrated could allow software running in the virtual machine to
see multiple MSIs arriving from a single device in an order that should
not happen. While this would rarely matter in practice, it runs the risk
of wedging a device driver that depends (perhaps inadvertently) on a
valid ordering of events.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="vs-level-external-interrupts-without-a-guest-interrupt-file"><a class="anchor" href="#vs-level-external-interrupts-without-a-guest-interrupt-file"></a>6.2. VS-level external interrupts without a guest interrupt file</h3>
<div class="paragraph">
<p>Although it is recommended that harts implementing the hypervisor
extension also have IMSICs with guest interrupt files, this is not a
requirement. Even assuming guest interrupt files exist, it may happen
that there are more virtual harts at a physical hart than guest
interrupt files, leaving some virtual harts without one. In either case,
a hypervisor must emulate an external interrupt controller for a virtual
hart without the benefit of a guest interrupt file allocated to the
virtual hart.</p>
</div>
<div class="paragraph">
<p>When emulating an external interrupt controller for a virtual hart, if
configurable interrupt priority is not supported for the virtual hart
other than for external interrupts, then external interrupts may be
asserted to VS level simply by setting bit VSEIP in <code>hvip</code>, as defined by the
H extension. However, to emulate both an external interrupt
controller and priority configurability for non-external interrupts, a
hypervisor must make use of CSR <code>hvictl</code> (Hypervisor Virtual Interrupt Control),
described later in the next section.</p>
</div>
</div>
<div class="sect2">
<h3 id="interrupts-at-vs-level"><a class="anchor" href="#interrupts-at-vs-level"></a>6.3. Interrupts at VS level</h3>
<div class="sect3">
<h4 id="configuring-priorities-of-major-interrupts-at-vs-level"><a class="anchor" href="#configuring-priorities-of-major-interrupts-at-vs-level"></a>6.3.1. Configuring priorities of major interrupts at VS level</h4>
<div class="paragraph">
<p>Like for supervisor level, the Advanced Interrupt Architecture
optionally allows major VS-level interrupts to be configured by software
to intermix in priority with VS-level external interrupts. As documented
in <a href="#intrs-S">Section 5.4</a>, interrupt priorities for
supervisor level are configured by the <code>iprio</code> array accessed indirectly through
CSRs <code>siselect</code> and <code>sireg</code>. The <code>siselect</code> addresses for the <code>iprio</code> array registers are <code>0x30</code>-<code>0x3F</code>.</p>
</div>
<div class="paragraph">
<p>VS level has its own <code>vsiselect</code> and <code>vsireg</code>, but unlike supervisor level, there are no
registers at <code>vsiselect</code> addresses <code>0x30</code>-<code>0x3F</code>. When <code>vsiselect</code> has a value in the range <code>0x30</code>-<code>0x3F</code>, an attempt
from VS-mode to access <code>sireg</code> (really <code>vsireg</code>) causes a virtual instruction exception.
To give a virtual hart the illusion of an array of <code>iprio</code> registers accessed
through <code>siselect</code> and <code>sireg</code>, a hypervisor must emulate the VS-level <code>iprio</code> array when accesses
to <code>sireg</code> from VS-mode cause virtual instruction traps.</p>
</div>
<div class="paragraph">
<p>Instead of a physical VS-level <code>iprio</code> array, a separate hardware mechanism is
provided for configuring the priorities of a subset of interrupts for VS
level, using hypervisor CSRs <code>hviprio1</code> and <code>hviprio2</code>. The subset of major interrupt numbers
whose priority may be configured in hardware are these:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Supervisor software interrupt</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Supervisor timer interrupt</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Counter overflow interrupt</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">14-23</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Reserved for standard local interrupts</em></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>For interrupts directed to VS level, software-configurable priorities
are not supported in hardware for standard local interrupts in the range
32-48.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>For custom interrupts, priority configurability may be supported in
hardware by custom CSRs, expanding upon <code>hviprio1</code> and <code>hviprio2</code> for standard interrupts.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Registers <code>hviprio1</code> and <code>hviprio2</code> have these formats:</p>
</div>
<div class="paragraph">
<p><code>hviprio1</code>:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 7:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Reserved for priority number for interrupt 0; reads as
zero</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 15:8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Priority number for interrupt 1, supervisor software
interrupt<br></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 23:16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Reserved for priority number for interrupt 4; reads as
zero</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 31:24</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Priority number for interrupt 5, supervisor timer
interrupt</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 39:32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Reserved for priority number for interrupt 8; reads as
zero</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 47:40</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Priority number for interrupt 13, counter overflow
interrupt</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 55:48</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Priority number for interrupt 14</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 63:56</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Priority number for interrupt 15</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><code>hviprio2</code>:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 7:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Priority number for interrupt 16</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 15:8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Priority number for interrupt 17</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 23:16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Priority number for interrupt 18</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 31:24</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Priority number for interrupt 19</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 39:32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Priority number for interrupt 20</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 47:40</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Priority number for interrupt 21</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 55:48</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Priority number for interrupt 22</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 63:56</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Priority number for interrupt 23</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Each priority number in <code>hviprio1</code> and <code>hviprio2</code> is a <strong>WARL</strong> unsigned integer field that is either
read-only zero or implements a minimum of IPRIOLEN bits or 6 bits,
whichever is larger, and preferably all 8 bits. Implementations may
freely choose which priority number fields are read-only zeros, but all
other fields must implement the same number of integer bits. A minimal
implementation of these CSRs has them both be read-only zeros.</p>
</div>
<div class="paragraph">
<p>A hypervisor can choose to employ registers <code>hviprio1</code> and <code>hviprio2</code> when emulating the
(virtual) supervisor-level <code>iprio</code> array accessed indirectly through <code>siselect</code> and <code>sireg</code> (really
<code>vsiselect</code> and <code>vsireg</code>) for a virtual hart. For interrupts not in the subset supported by
<code>hviprio1</code> and <code>hviprio2</code>, the priority number bytes in the emulated <code>iprio</code> array can be read-only
zeros.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Providing hardware support for configurable priority for only a subset
of major interrupts at VS level is a compromise. The utility of being
able to control interrupt priorities at VS level is arguably illusory
when all traps to M-mode and HS-modeâ€”both interrupts and synchronous
exceptionsâ€”have absolute priority, and when each virtual hart may also
be competing for resources against other virtual harts well beyond its
control. Nevertheless, priority configurability has been made possible
for the most likely subset of interrupts, while minimizing the number of
added CSRs that must be swapped on a virtual hart switch.</p>
</div>
<div class="paragraph">
<p>Major interrupts outside the priority-configurable subset can still be
directed to VS level, but their priority will simply be the default
order defined in <a href="#majorIntrs">Section 5.1</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If a hypervisor really must emulate configurability of priority for
interrupts beyond the subset supported by <code>hviprio1</code> and <code>hviprio2</code>, it can do so with extra
effort by setting bit VTI of CSR <code>hvictl</code>, described in the next subsection.</p>
</div>
</div>
<div class="sect3">
<h4 id="virtual-interrupts-for-vs-level"><a class="anchor" href="#virtual-interrupts-for-vs-level"></a>6.3.2. Virtual interrupts for VS level</h4>
<div class="paragraph">
<p>Assuming a virtual hart does not need configurable priority for major
interrupts beyond the subset supported in hardware by <code>hviprio1</code> and <code>hviprio2</code>, a hypervisor
can assert interrupts to the virtual hart using CSRs <code>hvien</code> (Hypervisor
Virtual-Interrupt-Enable) and <code>hvip</code> (Hypervisor Virtual-Interrupt-Pending
bits). These CSRs affect interrupts for VS level much the same way that <code>mvien</code>
and <code>mvip</code> do for supervisor level, as explained in
<a href="#virtIntrs-S">Section 5.3</a>.</p>
</div>
<div class="paragraph">
<p>Each bit of registers <code>hvien</code> and <code>hvip</code> corresponds with an interrupt number in the
range 0-63. Bits 12:0 of <code>hvien</code> are reserved and must be read-only zeros, while
bits 12:0 of <code>hvip</code> are defined by the H extension. Specifically,
bits 10, 6, and 2 of <code>hvip</code> are writable bits that correspond to VS-level
external interrupts (VSEIP), VS-level timer interrupts (VSTIP), and
VS-level software interrupts (VSSIP), respectively.</p>
</div>
<div class="paragraph">
<p>The following applies only to the CSR bits for interrupt numbers 13-63:
When a bit in <code>hideleg</code> is one, then the same bit position in <code>vsip</code> is an alias for the
corresponding bit in <code>sip</code>. Else, when a bit in <code>hideleg</code> is zero and the matching bit
in <code>hvien</code> is one, the same bit position in <code>vsip</code> is an alias for the corresponding
bit in <code>hvip</code>. A bit in <code>vsip</code> is read-only zero when the corresponding bits in <code>hideleg</code> and <code>hvien</code>
are both zero. The combined effects of <code>hideleg</code> and <code>hvien</code> on <code>vsip</code> and <code>vsie</code> are summarized in <a href="#intrFilteringForVS">Table 13</a>.</p>
</div>
<table id="intrFilteringForVS" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 13. The effects of <code>hideleg</code> and <code>hvien</code> on <code>vsip</code> and <code>vsie</code> for major interrupts 13-63.</caption>
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top"><code>hideleg</code>[\(n\)]</th>
<th class="tableblock halign-center valign-top"><code>hvien</code>[\(n\)]</th>
<th class="tableblock halign-center valign-top"><code>vsip</code>[\(n\)]</th>
<th class="tableblock halign-center valign-top"><code>vsie</code>[\(n\)]</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Read-only 0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Read-only 0</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Alias of <code>hvip</code>[\(n\)]</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Writable</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Alias of <code>sip</code>[\(n\)]</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Alias of <code>sie</code>[\(n\)]</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>For interrupt numbers 13-63, a bit in <code>vsie</code> is writable if and only if the
corresponding bit is set in either <code>hideleg</code> or <code>hvien</code>. When an interrupt is delegated
by <code>hideleg</code>, the writable bit in <code>vsie</code> is an alias of the corresponding bit in <code>sie</code>; else
it is an independent writable bit. The H extension specifies
when bits 12:0 of <code>vsie</code> are aliases of bits in <code>hie</code>. As usual, bits that are not
writable in <code>vsie</code> must be read-only zeros.</p>
</div>
<div class="paragraph">
<p>If a bit of <code>hideleg</code> is zero and the corresponding bit in <code>hvien</code> is changed from zero to
one, then the value of the matching bit in <code>vsie</code> becomes UNSPECIFIED. Likewise, if a bit
of <code>hvien</code> is one and the corresponding bit in <code>hideleg</code> is changed from one to zero, the
value of the matching bit in <code>vsie</code> again becomes UNSPECIFIED.</p>
</div>
<div class="paragraph">
<p>For interrupt numbers 13-63, implementations may freely choose which
bits of <code>hvien</code> are writable and which bits are read-only zero or one. If such a
bit in <code>hvien</code> is read-only zero (preventing the virtual interrupt from being
enabled), the same bit should be read-only zero in <code>hvip</code>. All other bits for
interrupts 13-63 must be writable in <code>hvip</code>.</p>
</div>
<div class="paragraph">
<p>CSR <code>hvictl</code> (Hypervisor Virtual Interrupt Control) provides further flexibility
for injecting interrupts into VS level in situations not fully supported
by the facilities described thus far, but only with more active
involvement of the hypervisor. A hypervisor must use <code>hvictl</code> for any of the
following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>asserting for VS level a major interrupt not supported by <code>hvien</code> and <code>hvip</code>;</p>
</li>
<li>
<p>implementing configurability of priorities at VS level for major
interrupts beyond those supported by <code>hviprio1</code> and <code>hviprio2</code>; or</p>
</li>
<li>
<p>emulating an external interrupt controller for a virtual hart without
the use of an IMSICâ€™s guest interrupt file, while also supporting
configurable priorities both for external interrupts and for major
interrupts to the virtual hart.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Among the possible uses, <code>hvictl</code> is needed for a hypervisor
to fully emulate HS-mode in VS-mode, which is a requirement for
the hosting of nested hypervisors without paravirtualization.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The format of <code>hvictl</code> is:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bit 30</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VTI</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 27:16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IID (<strong>WARL</strong>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bit 9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DPR</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bit 8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPRIOM</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 7:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPRIO</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>All other bits of <code>hvictl</code> are reserved and read as zeros.</p>
</div>
<div class="paragraph">
<p>When bit VTI (Virtual Trap Interrupt control) = 1, attempts from VS-mode
to explicitly access CSRs <code>sip</code> and <code>sie</code> (or, for RV32 only, <code>siph</code> and <code>sieh</code>) cause a virtual
instruction exception. Furthermore, for any given CSR, if there is some
circumstance in which a write to the register may cause a bit of <code>vsip</code> to
change from one to zero, excluding bit 9 for external interrupts (SEIP),
then when VTI = 1, a virtual instruction exception is raised also for
any attempt by the guest to write this register. Both the value being
written to the CSR and the value of <code>vsip</code> (before or after) are ignored for
determining whether to raise the exception. (Hence a write would not
actually need to change a bit of <code>vsip</code> from one to zero for the exception to
be raised.) In particular, if register <code>vstimecmp</code> is implemented (from extension
Sstc), then attempts from VS-mode to write to <code>stimecmp</code> (or, for RV32 only, <code>stimecmph</code>)
cause a virtual instruction exception when VTI = 1.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>For the standard local interrupts (major identities 13-23 and 32-47),
and for software interrupts (SSI), the corresponding interrupt-pending
bits in <code>vsip</code> are defined as "sticky," meaning a guest can clear them only
by writing directly to <code>sip</code> (really <code>vsip</code>). Among the standard-defined interrupts,
that leaves only timer interrupts (STI), which can potentially be
cleared in <code>vsip</code> by writing a new value to <code>vstimecmp</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>All <code>hvictl</code> fields together can affect the value of CSR <code>vstopi</code> (Virtual Supervisor Top
Interrupt) and therefore the interrupt identity reported in <code>vscause</code> when an
interrupt traps to VS-mode. IID is a <strong>WARL</strong> unsigned integer field with at
least 6 implemented bits, while IPRIO is always the full 8 bits. If
\(k\) bits are implemented for IID, then all values 0 through
\({2}^{k}-{1}\) are supported, and a write to <code>hvictl</code> sets
IID equal to bits (\({15}+k\)):16 of the value written.</p>
</div>
<div class="paragraph">
<p>For a virtual interrupt specified for VS level by <code>hvictl</code>, if VTI = 1 and
\({IID} \neq {9}\), field DPR (Default Priority
Rank) determines the interruptâ€™s presumed default priority order
relative to a (virtual) supervisor external interrupt (SEI), major
identityÂ 9, as follows:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0 = interrupt has higher default priority than an SEI</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1 = interrupt has lower default priority than an SEI</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>When <code>hvictl</code>.IID = 9, DPR is ignored.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Register <code>hvictl</code> has no effect on any of <code>mip</code>, <code>sip</code>, <code>hip</code>, or <code>vsip</code>;
it affects only <code>vstopi</code> and the trapping of some instructions.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="vstopi"><a class="anchor" href="#vstopi"></a>6.3.3. Virtual supervisor top interrupt CSR (<code>vstopi</code>)</h4>
<div class="paragraph">
<p>Read-only CSR <code>vstopi</code> is VSXLEN bits wide and has the same format as <code>stopi</code>:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">bits 27:16 IID</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">bits 7:0   IPRIO</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><code>vstopi</code> returns information about the highest-priority interrupt for VS level,
found from among these candidates (prefixed by + signs):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>if bit 9 is one in both <code>vsip</code> and <code>vsie</code>, <code>hstatus</code>.VGEIN is the valid number of a guest
interrupt file, and <code>vstopei</code> is not zero:</p>
<div class="ulist">
<ul>
<li>
<p>+ a supervisor external interrupt (code 9) with the priority number indicated by <code>vstopei</code>;</p>
</li>
</ul>
</div>
</li>
<li>
<p>if bit 9 is one in both <code>vsip</code> and <code>vsie</code>, <code>hstatus</code>.VGEIN = 0, and <code>hvictl</code> fields IID = 9 and
\({IPRIO} \neq {0}\):</p>
<div class="ulist">
<ul>
<li>
<p>+ a supervisor external interrupt (code 9) with priority number <code>hvictl</code>.IPRIO;</p>
</li>
</ul>
</div>
</li>
<li>
<p>if bit 9 is one in both <code>vsip</code> and <code>vsie</code>, and neither of the first two cases
applies:</p>
<div class="ulist">
<ul>
<li>
<p>+ a supervisor external interrupt (code 9) with priority number 256;</p>
</li>
</ul>
</div>
</li>
<li>
<p>if <code>hvictl</code>.VTI = 0:</p>
<div class="ulist">
<ul>
<li>
<p>+ the highest-priority pending-and-enabled major interrupt indicated by <code>vsip</code> and <code>vsie</code>
other than a supervisor external interrupt (code 9), using the priority numbers assigned
by <code>hviprio1</code> and <code>hviprio2</code>;</p>
</li>
</ul>
</div>
</li>
<li>
<p>if <code>hvictl</code> fields VTI = 1 and \({IID} \neq {9}\):</p>
<div class="ulist">
<ul>
<li>
<p>+ the major interrupt specified by <code>hvictl</code> fields IID, DPR, and IPRIO.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the list above, all "supervisor" external interrupts are virtual,
directed to VS level, having major codeÂ 9 at VS level.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The list of candidate interrupts can be reduced to two finalists
relatively easily by observing that the first three list items are
mutually exclusive of one another, and the remaining two items are also
mutually exclusive of one another.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When <code>hvictl</code>.VTI = 1, the absence of an interrupt for VS level can be indicated
only by setting <code>hvictl</code>.IID = 9. Software might want to use the pair IID = 9,
IPRIO = 0 generally to represent <em>no interrupt</em> in <code>hvictl</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When no interrupt candidates satisfy the conditions of the list above,
<code>vstopi</code> is zero. Else, <code>vstopi</code> fields IID and IPRIO are determined by the
highest-priority interrupt from among the candidates. The usual priority
order for supervisor level applies, as specified by
<a href="#TableintrPrios-S">Table 12</a>, except that priority
numbers are taken from the candidate list above, not from the
supervisor-level <code>iprio</code> array. Ties in nominal priority are broken as usual by
the default priority order from
<a href="#TablemajorIntrs">Table 8</a>, unless <code>hvictl</code> fields VTI = 1 and
\({IID} \neq {9}\) (last item in the candidate list
above), in which case default priority order is determined solely by
<code>hvictl</code>.DPR. If bit IPRIOM (IPRIO Mode) of <code>hvictl</code> is zero, IPRIO in <code>vstopi</code> is 1; else, if the
priority number for the highest-priority candidate is within the range 1
to 255, IPRIO is that value; else, IPRIO is set to either 0 or 255 in
the manner documented for <code>stopi</code> in <a href="#stopi">Section 5.4.2</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="interrupt-traps-to-vs-mode"><a class="anchor" href="#interrupt-traps-to-vs-mode"></a>6.3.4. Interrupt traps to VS-mode</h4>
<div class="paragraph">
<p>The Advanced Interrupt Architecture modifies the H extension
such that an interrupt is pending at VS level if and only
if <code>vstopi</code> is not zero. CSRs <code>vsip</code> and <code>vsie</code> do not by themselves determine whether a
VS-level interrupt is pending, though they may do so indirectly through
their effect on <code>vstopi</code>.</p>
</div>
<div class="paragraph">
<p>Whenever <code>vstopi</code> is not zero, if either the current privilege mode is VS-mode
and the SIE bit in CSR <code>vsstatus</code> is one, or the current privilege mode is VU-mode,
a trap is taken to VS-mode for the interrupt indicated by field IID of <code>vstopi</code>.</p>
</div>
<div class="paragraph">
<p>The Exception Code field of <code>vscause</code> must implement at least as many bits as
needed to represent the largest value that field IID of <code>vstopi</code> can have for the
given hart.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="IPIs"><a class="anchor" href="#IPIs"></a>7. Interprocessor Interrupts (IPIs)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>By default, unless a platform has a different mechanism for
interprocessor interrupts (IPIs), the base RISC-V Privileged Architecture specifies
that a machine with multiple harts must provide for each hart an
implementation-defined memory address that can be written to signal a
machine-level <em>software interrupt</em> (major codeÂ 3) at that hart. IPIs at
machine level can thus be sent to any hart as machine-level software
interrupts.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A RISC-V software interrupt acts only as a minimal "doorbell" signal.
Software at the receiving hart is responsible for recognizing an
incoming software interrupt as an IPI and decoding its purpose further,
usually making use of additional data stored by the sender in ordinary
memory.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The same kind of mechanism (but with a different set of memory
addresses) may or may not exist for signaling supervisor-level software
interrupts (major codeÂ 1) at remote harts as well. If not directly
supported in this way, a supervisor-level software interrupt is
typically sent to another hart instead through an environment call from
supervisor mode to machine mode. An operating system running in S-mode
thus invokes a specific SBI function for delivering a software interrupt
to another hart, causing machine-level software at the originating hart
to send a machine-level IPI to the destination hart, where software then
sets the supervisor-level software interrupt-pending bit (SSIP) in CSR <code>mip</code>.</p>
</div>
<div class="paragraph">
<p>When harts have IMSICs, instead of using the base Privileged Architecture&#8217;s
mechanism for signaling software interrupts at remote harts, an IPI can
be sent to a hart by writing to the destination hart&#8217;s IMSIC, the same
as a regular message-signaled interrupt (MSI). In that case, an incoming
IPI appears at the destination hart as an <em>external interrupt</em> routed
through the IMSIC, rather than as a software interrupt as before.
However, so long as the same software (e.g. an operating system or
machine monitor) is in control at both endpoints of an IPI, source and
destination, there should be no reason for a destination hart to
misinterpret the purpose of an incoming external interrupt that
represents an IPI.</p>
</div>
<div class="paragraph">
<p>If harts do not have IMSICs, then the method specified by the base Privileged
Architecture is assumed to be used for IPIs, signaling software
interrupts at destination harts. On the other hand, when harts have
IMSICs, the machinery for triggering software interrupts at remote harts
is redundant with the capabilities of the IMSICs, so it is downgraded
from a requirement to an option, useful perhaps only to provide software
compatibility across a range of RISC-V systems, with and without IMSICs. If a
machine implements IMSICs and not the earlier software-interrupt
mechanism, then the bits of CSRs <code>mip</code> and <code>mie</code> for machine-level software
interrupts, MSIP and MSIE, are hardwired to zero in harts.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If a machine implements IMSICs but not the software-interrupt mechanism,
the latter can still be fully emulated at supervisor level for S-mode or
VS-mode, by trapping on writes to the special memory addresses that
should signal supervisor-level software interrupts at remote harts. On
such a trap, software can send a higher-level IPI via IMSIC to the
destination hart, where the higher-level software then can set the SSIP
bit in <code>sip</code> at the intended privilege level, S or VS.</p>
</div>
<div class="paragraph">
<p>Similarly, SBI environment calls for sending IPIs can easily continue to
be supported without clients being at all aware of a change in the
underlying hardware for delivering IPIs between harts.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When software sends IPIs by writing MSIs to the IMSICs of other harts,
programmers should consider also the need to execute a FENCE instruction
before each store instruction that writes such an MSI. In the absence of
FENCEs, many systems guarantee to preserve the order of a hart&#8217;s loads
and stores only to/from individual devices, not among multiple devices,
and not at all for accesses to main memory. With such a system, it must
be remembered that each IMSIC is likely to be considered a separate
device among the many. For example, if hart A wants to notify hart B
that it has completed a task involving accesses to some I/O device,
hart A may need to execute a FENCE before sending an MSI to B&#8217;s IMSIC,
to ensure that all of A&#8217;s accesses to the device have actually completed
before the MSI could arrive at B. Similarly, if hart A stores anything
to memory that should be visible at hart B, a FENCE is likely needed
before a subsequent store sending an MSI to B&#8217;s IMSIC.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="IOMMU"><a class="anchor" href="#IOMMU"></a>8. IOMMU Support for MSIs to Virtual Machines</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The existence of an IOMMU in a system makes it possible for a guest
operating system, running in a virtual machine, to be given direct
control of an I/O device with only minimal hypervisor intervention. A
guest OS with direct control of a device will program the device with
guest physical addresses, because that is all the OS knows. When the
device then performs memory accesses using those addresses, an IOMMU is
responsible for translating those guest physical addresses into machine
physical addresses, referencing address-translation data structures
supplied by the hypervisor.</p>
</div>
<div class="paragraph">
<p>To handle MSIs from a device controlled by a guest OS, an IOMMU must be
able to redirect those MSIs to a guest interrupt file in an IMSIC.
Systems that do not have IMSICs with guest interrupt files do not need
to implement the facilities described in this chapter.</p>
</div>
<div class="paragraph">
<p>Because MSIs from devices are simply memory writes, they would naturally
be subject to the same address translation that an IOMMU applies to
other memory writes. However, the Advanced Interrupt Architecture
requires that IOMMUs treat MSIs directed to virtual machines specially,
in part to simplify software, and in part to allow optional support for
<em>memory-resident interrupt files</em>.</p>
</div>
<div class="paragraph">
<p>This chapter uses the term <em>IOMMU</em> in a generic sense that encompasses
all translation and transaction processing services required to
virtualize device accesses and is concerned only with how an IOMMU
recognizes and processes MSIs directed to virtual machines. Most other
functions and details of an IOMMU are beyond the scope of this standard,
and must be specified elsewhere.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The RISC-V IOMMU Architecture Specification provides a detailed description of
the IOMMU architecture, dividing translation and transaction processing
functionality into blocks such as IOMMU, IO Bridge, etc. and describing
how those blocks are integrated into a system.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If a single physical I/O device can be subdivided for control by
multiple separate device drivers, each sub-device is referred to here as
one device.</p>
</div>
<div class="sect2">
<h3 id="IOMMU-deviceContexts"><a class="anchor" href="#IOMMU-deviceContexts"></a>8.1. Device contexts at an IOMMU</h3>
<div class="paragraph">
<p>The following assumptions are made about the IOMMUs in a system:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For each I/O device connected to the system through an IOMMU, software
can configure at the IOMMU a <em>device context</em>, which associates with the
device a specific virtual address space and any other per-device
parameters the IOMMU may support. By giving devices each their own
separate device context at an IOMMU, each device can be individually
configured for a separate operating system, which may be a guest OS or
the main (host) OS. On every memory access initiated by a device,
hardware indicates to the IOMMU the originating device by some form of
unique device identifier, which the IOMMU uses to locate the appropriate
device context within data structures supplied by software. For PCI, for
example, the originating device may be identified by the unique triple
of PCI bus number, device number, and function number.</p>
</li>
<li>
<p>An IOMMU optionally translates the addresses of a device&#8217;s memory
accesses using address-translation data structuresâ€”typically page
tablesâ€”specified by software via the corresponding device context. The
smallest granularity of address translation implemented by all IOMMUs is
not larger than a 4-KiB page, matching that of standard RISC-V
address-translation page tables. (An IOMMU may in fact employ page
tables in the same format as the page-based address translation defined
by the RISC-V Privileged Architecture, but this is not required.)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Advanced Interrupt Architecture adds to device contexts these
fields, as needed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>an <em>MSI address mask</em> and <em>address pattern</em>, used together to identify
pages in the guest physical address space that are the destinations of
MSIs; and</p>
</li>
<li>
<p>the real physical address of an <em>MSI page table</em> for controlling the
translation and/or conversion of MSIs from the device.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The MSI address mask and address pattern are each unsigned integers with
the same width as guest physical page numbers, i.e., 12 bits narrower
than the maximum supported width of a guest physical address. Their use
is explained in <a href="#IOMMU-identIncomingMSIs">Section 8.4</a>.</p>
</div>
<div class="paragraph">
<p>A device context&#8217;s MSI page table is separate from the usual
address-translation data structures used to translate other memory
accesses from the same device. The form and function of MSI page tables
are the subject of most of the rest of this chapter.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A device context is given an independent page table for MSIs for two
reasons:</p>
</div>
<div class="paragraph">
<p>First, hypervisors running under Linux or a similar OS can benefit from
separate control of MSI translations to help simplify the case when
virtual harts are migrated from one physical hart to another. As noted
in <a href="#virtHartMigration">Section 6.1.2</a>, when a
virtual hart&#8217;s interrupt files are mapped to guest interrupt files in
the real machine, migration of the virtual hart causes the physical
guest interrupt files underlying those virtual interrupt files to
change. However, because on other systems (not RISC-V) the migration of a
virtual hart does not affect the mapping from guest physical addresses
to real physical addresses, the internal functions of Linux that perform
this migration are not set up to modify an IOMMU&#8217;s address-translation
tables to adjust for the changing physical locations of RISC-V virtual
interrupt files. Giving a hypervisor control of a separate MSI
translation table at an IOMMU bypasses this limitation. The MSI page
table can be modified at will by the hypervisor and/or by the subsystem
that manages interrupts without coordinating with the many other OS
components concerned with regular address translation.</p>
</div>
<div class="paragraph">
<p>Second, specifying a separate MSI page table facilitates the use of
<em>memory-resident interrupt files</em> (MRIFs), which are introduced in
<a href="#IOMMU-MRIFs">Section 8.3</a>. A dedicated MSI page table can easily
support a special table entry format for MRIFs
(<a href="#IOMMU-MSIPTE-MRIF">Section 8.5.2</a>) that would be entirely foreign
and difficult to retrofit to any other address-translation data
structures.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="translation-of-addresses-for-msis-from-devices"><a class="anchor" href="#translation-of-addresses-for-msis-from-devices"></a>8.2. Translation of addresses for MSIs from devices</h3>
<div class="paragraph">
<p>To support the delivery of MSIs from I/O devices directly to RISC-V virtual
machines without hypervisor intervention, an IOMMU must be able to
translate the guest physical address of an MSI to the real physical
address of an IMSICâ€™s guest interrupt file in the machine, as
illustrated in <a href="#IOMMU-guestIntrFiles">Figure 6</a>. This address
translation is controlled by the MSI page table configured in the
appropriate device context at the IOMMU. Because every interrupt file,
real or virtual, occupies a naturally aligned 4-KiB page of address
space, the required address translation is from a virtual (guest) page
address to a physical page address, the same as supported by regular RISC-V
page-based address translation.</p>
</div>
<div id="IOMMU-guestIntrFiles" class="imageblock unresolved">
<div class="content">
<img src="IOMMU-guestIntrFiles.png" alt="IOMMU guestIntrFiles">
</div>
<div class="title">Figure 6. Translation of a device-sourced MSI that a guest OS intended to go to a (virtual) IMSIC interrupt file in the OS&#8217;s virtual machine. Referencing an MSI page table supplied by the controlling hypervisor, the IOMMU redirects the MSI to a guest interrupt file of the real machine.</div>
</div>
<div class="paragraph">
<p>Memory writes from a device are recognized as MSIs by the destination
address of the write. If an IOMMU determines that a 32-bit write is to
the location of a (virtual) interrupt file in the relevant virtual
machine, the write is considered an MSI within the VM, else not. The
exact formula for recognizing MSIs is documented in
<a href="#IOMMU-identIncomingMSIs">Section 8.4</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Although the translation of MSIs is controlled by its own separate page
table, the fact that MSI translations are at the same page granularity
as regular RISC-V address translations implies that an address translation
cache within an IOMMU requires little modification to also cache MSI
translations. Only on a translation cache miss does the IOMMU need to
treat MSIs significantly differently than other memory accesses from the
same device, to choose the correct translation table and to access and
interpret the table properly.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="IOMMU-MRIFs"><a class="anchor" href="#IOMMU-MRIFs"></a>8.3. Memory-resident interrupt files</h3>
<div class="paragraph">
<p>An IOMMU may optionally support memory-resident interrupt files (MRIFs).
If implemented, the use of memory-resident interrupt files can greatly
increase the number of virtual harts that can be given direct control of
one or more physical devices in a system, assuming the rest of the
system can still handle the added load.</p>
</div>
<div class="paragraph">
<p>Without memory-resident interrupt files, the number of virtual RISC-V harts
that can directly receive MSIs from devices is limited by the total
number of guest interrupt files implemented by all IMSICs in the system,
because all MSIs to RISC-V harts must go through IMSICs. For a single RISC-V hart, the
number of guest interrupt files is the <em>GEILEN</em> parameter defined by the
H extension, which can be at most 31 for RV32 and 63 for
RV64.</p>
</div>
<div class="paragraph">
<p>With the use of memory-resident interrupt files, on the other hand, the
total number of virtual RISC-V harts able to receive device MSIs is almost
unbounded, constrained only by the amount of real physical memory and
the additional processing time needed to handle them. As its name
implies, a memory-resident interrupt file is located in memory instead
of within an IMSIC. <a href="#IOMMU-MRIF">Figure 7</a> depicts how an IOMMU can
record an incoming MSI in an MRIF. When properly configured by a
hypervisor, an IOMMU recognizes certain incoming MSIs as intended for a
specific virtual interrupt file, and records each such MSI by setting an
interrupt-pending bit stored within the MRIF data structure in ordinary
memory. After each MSI is recorded in an MRIF, the IOMMU also sends a
<em>notice MSI</em> to the hypervisor to inform it that the MRIF contents may
have changed.</p>
</div>
<div id="IOMMU-MRIF" class="imageblock unresolved">
<div class="content">
<img src="IOMMU-MRIF.png" alt="IOMMU MRIF">
</div>
<div class="title">Figure 7. Recording an incoming MSI into a memory-resident interrupt file (MRIF) instead of sending it to a guest interrupt file as in <a href="#IOMMU-guestIntrFiles">Figure 6</a>.</div>
</div>
<div class="paragraph">
<p>While a memory-resident interrupt file provides a place to record MSIs,
it cannot interrupt a hart directly the way an IMSIC&#8217;s guest interrupt
files can. The notice MSIs that hypervisors receive only indicate that a
virtual hart <em>might</em> need interrupting; a hypervisor is responsible for
examining the MRIF contents each time to determine whether actually to
interrupt the virtual hart. Furthermore, whereas an IMSIC&#8217;s guest
interrupt file can directly act as a supervisor-level interrupt file for
a virtual hart, keeping a virtual hart&#8217;s interrupt file in an MRIF while
the virtual hart executes requires that the hypervisor emulate a
supervisor-level interrupt file for the virtual hart, hiding the
underlying MRIF. Depending on how often the virtual hart touches its
interrupt file and the implementation&#8217;s level of support for MRIFs, the
cost of this emulation may be significant.</p>
</div>
<div class="paragraph">
<p>Consequently, MRIFs are expected most often to be used for virtual harts
that are more-or-less "swapped out" of a physical hart due to being
idle, or nearly so. When a hypervisor determines that an MSI that landed
in an MRIF should wake up a particular virtual hart that was idle, the
virtual hart can be assigned a guest interrupt file in an IMSIC and its
interrupt file moved from the MRIF into this guest interrupt file before
the virtual hart is resumed. The process of allocating a guest interrupt
file for the newly wakened virtual hart may of course force the
interrupt file of another virtual hart to be evicted to its own MRIF.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Not all systems need to accommodate large numbers of idle virtual harts.
Many batch-processing servers, for example, strive to keep all virtual
worker threads as busy as possible from start to finish, throttled only
by I/O delays and limits on processing resources. In such environments,
support for MRIFs may not be useful, so long as parameter GEILEN is not
too small.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>An IOMMU can have one of these three levels of support for
memory-resident interrupt files:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>no memory-resident interrupt files;</p>
</li>
<li>
<p>memory-resident interrupt files without atomic update; or</p>
</li>
<li>
<p>memory-resident interrupt files with atomic update.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Memory-resident interrupt files are most efficient when the memory
system supports logical atomic memory operations (AMOs) corresponding to RISC-V
instructions AMOAND and AMOOR, for memory accesses made both from harts
and from the IOMMU. The AMOAND and AMOOR operations are required for
<em>atomic update</em> of a memory-resident interrupt file. A reduced level of
support is possible without AMOs, relying solely on basic memory reads
and writes.</p>
</div>
<div class="sect3">
<h4 id="IOMMU-MRIFFormat"><a class="anchor" href="#IOMMU-MRIFFormat"></a>8.3.1. Format of a memory-resident interrupt file</h4>
<div class="paragraph">
<p>A memory-resident interrupt file occupies 512 bytes of memory, naturally
aligned to a 512-byte address boundary. The 512 bytes are organized as
an array of 32 pairs of 64-bit doublewords, 64 doublewords in all. Each
doubleword is in little-endian byte order (even for systems where all
harts are big-endian-only).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Big-endian-configured harts that make use of MRIFs are expected to
implement the REV8 byte-reversal instruction defined by standard RISC-V
extension Zbb, or pay the cost of endianness conversion using a sequence
of instructions.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The pairs of doublewords contain the interrupt-pending and
interrupt-enable bits for external interrupt identities 1-2047, in this
arrangement:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>offset</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>size</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>contents</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x000</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>8 bytes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>interrupt-pending bits for (minor) identities 1-63</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x008</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>8 bytes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>interrupt-enable bits for identities 1-63</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x010</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>8 bytes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>interrupt-pending bits for identities 64-127</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x018</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>8 bytes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>interrupt-enable bits for identities 64-127</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>â€¦</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>â€¦</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1F0</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>8 bytes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>interrupt-pending bits for identities 1984-2047</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1F8</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>8 bytes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>interrupt-enable bits for identities 1984-2047</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>In general, the pair of doublewords at address offsets
\(k\times{16}\) and
\(k\times16+8\) for integer \(k\)
contain the interrupt-pending and interrupt-enable bits for external
interrupt minor identities in the range \(k\times64\)
to \(k\times64+63\). For
identity \(i\) in this range, bit
\((i\bmod 64)\) of the first (even) doubleword is the
interrupt-pending bit, and the same bit of the second (odd) doubleword
is the interrupt-enable bit.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The interrupt-pending and interrupt-enable bits are stored interleaved
by doublewords within an MRIF to facilitate the possibility of an IOMMU
examining the relevant enable bit to determine whether to send a notice
MSI after updating a pending bit, rather than the default behavior of
always sending a notice MSI after an update without regard for the
interrupt-enable bits. The memory arrangement matters only when MRIFs
are supported without atomic update.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Bit 0 of the first doubleword of an MRIF stores a faux interrupt-pending
bit for nonexistent interrupt 0. If a write from an I/O device appears
to be an MSI that should be stored in an MRIF, yet the data to write
(the interrupt identity) is zero, the IOMMU acts as though zero were a
valid interrupt identity, setting bit 0 of the target MRIF&#8217;s first
doubleword and sending a notice MSI as usual.</p>
</div>
<div class="paragraph">
<p>All MRIFs are the size to accommodate 2047 valid interrupt identities,
the maximum allowed for an IMSIC interrupt file. If a systemâ€™s actual
IMSICs have interrupt files that implement only \(N\)
interrupt identities, \(N &lt; 2047\), then the contents
of MRIFs for identities greater than \(N\) may be ignored by
software. IOMMUs, however, treat every MRIF as though all interrupt
identities in the range 0-2047 are valid, even as software ignores
invalid identity 0 and all identities greater than \(N\).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>There is no need to specify to an IOMMU a desired size \(N\)
for an MRIF smaller than 2047 valid interrupt identities. The only use
an IOMMU would make of this information would be to discard any MSIs
indicating an interrupt identity greater than \(N\). If
devices are properly configured by software, such errant MSIs should not
occur; but even if they do, it is just as effective for software to
ignore spurious interrupt identities <em>after</em> they have been recorded in
an MRIF as for an IOMMU to discard them before recording them in the
MRIF.</p>
</div>
<div class="paragraph">
<p>It is likewise unnecessary for IOMMUs to check for and discard MSIs
indicating an invalid interrupt identity of zero.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="recording-of-incoming-msis-to-memory-resident-interrupt-files"><a class="anchor" href="#recording-of-incoming-msis-to-memory-resident-interrupt-files"></a>8.3.2. Recording of incoming MSIs to memory-resident interrupt files</h4>
<div class="paragraph">
<p>The data component of an MSI write specifies the interrupt identity to
raise in the destination interrupt file. (Recall
<a href="#MSIEncoding">Section 3.2</a>.) This data may be in
little-endian or big-endian byte order. If an IOMMU supports
memory-resident interrupt files, it can store to an MRIF MSIs of the
same endianness that the machine&#8217;s IMSICs accept. All IMSIC interrupt
files are required to accept MSIs in little-endian byte order written to
memory-mapped register <code>seteipnum_le</code> (<a href="#IMSIC-memRegion">Section 3.5</a>). IMSIC interrupt
files may also accept MSIs in big-endian byte order if register <code>seteipnum_be</code> is
implemented alongside <code>seteipnum_le</code>.</p>
</div>
<div class="paragraph">
<p>If the interrupt identity indicated by an MSI&#8217;s data (when interpreted
in the correct byte order) is in the range 0-2047, an IOMMU stores the
MSI to an MRIF by setting to one the interrupt-pending bit in the MRIF
for that identity. If atomic update is supported for MRIFs, the pending
bit is set using an AMOOR operation, else it is set using a non-atomic
read-modify-write sequence. After the interrupt-pending bit is set in
the MRIF, the IOMMU sends the notice MSI that software has configured
for the MRIF.</p>
</div>
<div class="paragraph">
<p>The exact process of storing an MSI to an MRIF is specified more
precisely in <a href="#IOMMU-MSIPTE-MRIF">Section 8.5.2</a>, which covers MSI
page table entries configured in <em>MRIF mode</em>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It is an open question whether an IOMMU might optionally examine the
matching interrupt-enable bit within a destination MRIF to decide
whether to send a notice MSI after setting an interrupt-pending bit.
Currently, an IOMMU is required always to send a notice MSI after
storing an MSI to an MRIF, even when the corresponding enable bit for
the interrupt identity is zero.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="use-of-memory-resident-interrupt-files-with-atomic-update"><a class="anchor" href="#use-of-memory-resident-interrupt-files-with-atomic-update"></a>8.3.3. Use of memory-resident interrupt files with atomic update</h4>
<div class="paragraph">
<p>To make use of a memory-resident interrupt file with support for atomic
update, software must have memory locations to save an IMSIC interrupt
file&#8217;s <code>eidelivery</code> and <code>eithreshold</code> registers, in addition to the MRIF structure itself from <a href="#IOMMU-MRIFFormat">Section 8.3.1</a>.</p>
</div>
<div class="paragraph">
<p>Moving a virtual hart&#8217;s interrupt file from an IMSIC into an MRIF
involves these steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Prepare the MRIF by zeroing all of its interrupt-pending bits (the
even doublewords) and by copying the IMSIC interrupt file&#8217;s <code>eie</code> array to the
MRIF&#8217;s interrupt-enable bits (the odd doublewords).</p>
</li>
<li>
<p>Save to memory the existing values of the IMSIC interrupt file&#8217;s
registers <code>eidelivery</code> and <code>eithreshold</code>, and set <code>eidelivery</code> = 0.</p>
</li>
<li>
<p>Modify all relevant translation tables at IOMMUs so that MSIs for this
virtual interrupt file are now stored in the MRIF. If necessary,
synchronize with all IOMMUs to ensure that no straggler MSIs will arrive
at the IMSIC interrupt file after this step.</p>
</li>
<li>
<p>Logically OR the contents of the IMSIC interrupt file&#8217;s <code>eip</code> array into the
interrupt-pending bits of the MRIF, using AMOOR operations.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Once this sequence is complete, the IMSIC interrupt file is no longer in
use.</p>
</div>
<div class="paragraph">
<p>Each time a notice MSI arrives indicating that an MSI has been stored in
the MRIF, the controlling hypervisor should scan the MRIF&#8217;s
interrupt-pending and interrupt-enable bits to determine if any enabled
interrupt is now both pending and enabled and thus should interrupt the
virtual hart.</p>
</div>
<div class="paragraph">
<p>With atomic update of MRIFs, a virtual hart may continue executing with
its interrupt file contained in an MRIF, so long as the hypervisor
emulates for the virtual hart a proper IMSIC interrupt file to hide the
underlying MRIF. Hypervisor software can safely set and clear the
interrupt-pending and interrupt-enable bits of the MRIF using AMOOR and
AMOAND operations, even as an IOMMU may be storing incoming MSIs into
the same MRIF.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If an IOMMU is ever configured to examine an MRIF&#8217;s interrupt-enable
bits to decide whether to send notice MSIs, then modifying those enable
bits will generally require coordination with the IOMMU. But so long as
IOMMUs ignore the interrupt-enable bits as is currently assumed, the
bits can be changed by software without risk.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To move the same interrupt file from the MRIF back to an IMSIC:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>At the new IMSIC interrupt file, set <code>eidelivery</code> = 0, and zero the <code>eip</code> array.</p>
</li>
<li>
<p>Modify all relevant translation tables at IOMMUs so that MSIs for this
virtual interrupt file are now sent to the IMSIC interrupt file. If
necessary, synchronize with all IOMMUs to ensure that no straggler MSIs
will be stored in the MRIF after this step.</p>
</li>
<li>
<p>Logically OR the interrupt-pending bits from the MRIF into the IMSIC
interrupt file, using instruction CSRS to write to the <code>eip</code> array. Also, copy
the interrupt-enable bits from the MRIF to the IMSIC interrupt file&#8217;s <code>eie</code> array.</p>
</li>
<li>
<p>Load the IMSIC interrupt file&#8217;s registers <code>eithreshold</code> and <code>eidelivery</code> with the values that were earlier saved.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="use-of-memory-resident-interrupt-files-without-atomic-update"><a class="anchor" href="#use-of-memory-resident-interrupt-files-without-atomic-update"></a>8.3.4. Use of memory-resident interrupt files without atomic update</h4>
<div class="paragraph">
<p>Without support for atomic update, the use of memory-resident interrupt
files is similar to the atomic-update case of the previous subsection,
but with some added complexities.</p>
</div>
<div class="paragraph">
<p>First, if the I/O devices that a virtual hart controls are behind
multiple IOMMUs, then multiple MRIF structures are needed, one per
IOMMU, not just a single MRIF structure. Furthermore, in addition to
locations for storing <code>eidelivery</code> and <code>eithreshold</code>, software needs a place for a complete copy
of the interrupt file&#8217;s implemented <code>eip</code> array, apart from the MRIFs. While a
virtual interrupt file is in memory, its interrupt-pending bits will be
split across all the MRIFs and the saved <code>eip</code> array. The interrupt-enable
bits may exist only in the MRIFs.</p>
</div>
<div class="paragraph">
<p>To move a virtual hart&#8217;s interrupt file from an IMSIC into memory, with
one MRIF per IOMMU:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Prepare all MRIFs by zeroing their interrupt-pending bits (the even
doublewords) and by copying the IMSIC interrupt file&#8217;s <code>eie</code> array to the
MRIFs' interrupt-enable bits (the odd doublewords).</p>
</li>
<li>
<p>Save to memory the existing values of the IMSIC interrupt file&#8217;s
registers <code>eidelivery</code> and <code>eithreshold</code>, and set <code>eidelivery</code> = 0.</p>
</li>
<li>
<p>At each IOMMU, modify all relevant translation tables so that MSIs for
this virtual interrupt file are now stored in the individual MRIF
matched to the IOMMU. If necessary, synchronize with all IOMMUs to
ensure that no straggler MSIs will arrive at the IMSIC interrupt file
after this step.</p>
</li>
<li>
<p>Dump the IMSIC interrupt file&#8217;s <code>eip</code> array to its separate location outside
the MRIFs.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Once this sequence is complete, the IMSIC interrupt file is no longer in
use.</p>
</div>
<div class="paragraph">
<p>While a virtual hart&#8217;s interrupt file remains in memory, an interrupt
identity&#8217;s true pending bit is the logical OR of its bit in all MRIFs
and its bit in the saved <code>eip</code> array. All pending bits in the MRIFs start as
zeros, but interrupts may become pending there as MSIs for this virtual
hart arrive at IOMMUs and are stored in the corresponding MRIFs.</p>
</div>
<div class="paragraph">
<p>Without atomic update of MRIFs, an interrupt-pending bit is not easily
cleared in an MRIF. (Clearing a single pending bit in one MRIF requires
that a new MRIF be allocated and initialized and the corresponding IOMMU
reconfigured to store MSIs into the new MRIF.) For this reason, it may
or may not be practical to have a virtual hart execute while keeping one
of its interrupt files in memory. When an MRIF records an interrupt that
should wake a virtual hart, the simplest strategy is to always move the
interrupt file back into an IMSIC&#8217;s guest interrupt file before resuming
execution of the virtual hart.</p>
</div>
<div class="paragraph">
<p>To transfer an interrupt file from memory back to an IMSIC:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>At the new IMSIC interrupt file, set <code>eidelivery</code> = 0, and zero the <code>eip</code> array.</p>
</li>
<li>
<p>Modify all relevant translation tables at IOMMUs so that MSIs for this
virtual interrupt file are now sent to the IMSIC interrupt file. If
necessary, synchronize with all IOMMUs to ensure that no straggler MSIs
will be stored in MRIFs after this step.</p>
</li>
<li>
<p>Merge by bitwise logical OR the interrupt-pending bits of all MRIFs
and the saved <code>eip</code> array, and logically OR these merged bits into the IMSIC
interrupt file, using instruction CSRS to write to the <code>eip</code> array. Also, copy
the interrupt-enable bits from one of the MRIFs to the IMSIC interrupt
file&#8217;s <code>eie</code> array.</p>
</li>
<li>
<p>Load the IMSIC interrupt file&#8217;s registers <code>eithreshold</code> and <code>eidelivery</code> with the values that were earlier saved.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="allocation-of-guest-interrupt-files-for-receiving-notice-msis"><a class="anchor" href="#allocation-of-guest-interrupt-files-for-receiving-notice-msis"></a>8.3.5. Allocation of guest interrupt files for receiving notice MSIs</h4>
<div class="paragraph">
<p>The processing a hypervisor does in response to notice MSIs can be
minimized by assigning a separate interrupt identity for each MRIF, so
the identity encoded in a notice MSI always indicates which one MRIF may
have changed. However, if there are very many MRIFs (potentially in the
thousands), a hypervisor may run short of interrupt identities within
the supervisor-level interrupt files available in IMSICs. In that case,
the hypervisor can increase its supply of interrupt identities by
allocating one or more of the IMSICsâ€™ guest interrupt files to itself
for the purpose of receiving notice MSIs.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Although guest interrupt files exist primarily to act as
supervisor-level interrupt files for virtual harts, the IMSIC hardware
does not police exactly how they are used by software.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="IOMMU-identIncomingMSIs"><a class="anchor" href="#IOMMU-identIncomingMSIs"></a>8.4. Identification of page addresses of a VM&#8217;s interrupt files</h3>
<div class="paragraph">
<p>When an I/O device is configured directly by a guest operating system,
MSIs from the device are expected to be targeted to virtual IMSICs
within the guest OS&#8217;s virtual machine, using guest physical addresses
that are inappropriate and unsafe for the real machine. An IOMMU must
recognize certain incoming writes from such devices as MSIs and convert
them as needed for the real machine. (Recall
<a href="#IOMMU-guestIntrFiles">Figure 6</a>.)</p>
</div>
<div class="paragraph">
<p>MSIs originating from a single device that require conversion are
expected to have been configured at the device by a single guest OS
running within one RISC-V virtual machine. Assuming the VM itself conforms to
the Advanced Interrupt Architecture, MSIs are sent to virtual harts
within the VM by writing to the memory-mapped registers of the interrupt
files of virtual IMSICs. Each of these virtual interrupt files occupies
a separate 4-KiB page in the VM&#8217;s guest physical address space, the same
as real interrupt files do in a real machine&#8217;s physical address space. A
write to a guest physical address can thus be recognized as an MSI to a
virtual hart if the write is to a page occupied by an interrupt file of
a virtual IMSIC within the VM.</p>
</div>
<div class="paragraph">
<p>The MSI address mask and address pattern specified in a device context
(<a href="#IOMMU-deviceContexts">Section 8.1</a>) are used to identify the 4-KiB
pages of virtual interrupt files in the guest physical address space of
the relevant VM. An incoming 32-bit write made by a device is recognized
as an MSI write to a virtual interrupt file if the destination guest
physical page matches the supplied address pattern in all bit positions
that are zeros in the supplied address mask. In detail, a memory access
to guest physical address \(A\) is an access to a virtual
interrupt fileâ€™s memory-mapped page if</p>
</div>
<div class="paragraph text-center">
<p>((A &gt;&gt; 12) &amp; ~address mask) = (address pattern &amp; ~address mask)</p>
</div>
<div class="paragraph">
<p>where &gt;&gt; 12 represents shifting right by 12 bits, an ampersand (&amp;)
represents bitwise logical AND, and "~address mask"
is the bitwise logical complement of the address mask.</p>
</div>
<div class="paragraph">
<p>When a memory access is found to be to a virtual interrupt file, an
<em>interrupt file number</em> is extracted from the original guest physical
address as</p>
</div>
<div class="paragraph text-center">
<p>interrupt file number = extract(A &gt;&gt; 12, address mask)</p>
</div>
<div class="paragraph">
<p>Here, extract(\(x\), \(y\)) is a "bit extract"
that discards all bits from \(x\) whose matching bits in the
same positions in the mask \(y\) are zeros, and packs the
remaining bits from \(x\) contiguously at the
least-significant end of the result, keeping the same bit order as
\(x\) and filling any other bits at the most-significant end
of the result with zeros. For example, if the bits of \(x\)
and \(y\) are</p>
</div>
<div class="paragraph text-center">
<p>\(x\) = a b c d e f g h</p>
</div>
<div class="paragraph text-center">
<p>\(y\) = 1 0 1 0 0 1 1 0</p>
</div>
<div class="paragraph">
<p>then the value of extract(\(x\), \(y\)) has bits
0 0 0 0 a c f g.</p>
</div>
</div>
<div class="sect2">
<h3 id="msi-page-tables"><a class="anchor" href="#msi-page-tables"></a>8.5. MSI page tables</h3>
<div class="paragraph">
<p>When an IOMMU determines that a memory access is to a virtual interrupt
file as specified in the previous section, the access is translated or
converted by consulting the MSI page table configured for the device,
instead of using the regular translation data structures that apply to
all other memory accesses from the same device.</p>
</div>
<div class="paragraph">
<p>An MSI page table is a flat array of MSI page table entries (MSI PTEs),
each 16 bytes. MSI page tables have no multi-level hierarchy like
regular RISC-V page tables do. Rather, every MSI PTE is a leaf entry specifying
the translation or conversion of accesses made to a particular 4-KiB
guest physical page that a virtual interrupt file occupies (or may
occupy) in the relevant virtual machine. To select an individual MSI PTE
from an MSI page table, the PTE array is indexed by the interrupt file
number extracted from the destination guest physical address of the
incoming memory access by the formula of the previous section. Each MSI
PTE may specify either the address of a real guest interrupt file that
substitutes for the targeted virtual interrupt file (as in
<a href="#IOMMU-guestIntrFiles">Figure 6</a>), or a memory-resident interrupt
file in which to store incoming MSIs for the virtual interrupt file (as
in <a href="#IOMMU-MRIF">Figure 7</a>).</p>
</div>
<div class="paragraph">
<p>The number of entries in an MSI page table is \({2}^{k}\)
where \(k\) is the number of bits that are ones in the MSI
address mask used to extract the interrupt file number from the
destination guest physical address. If an MSI page table has 256 or
fewer entries, the start of the table is aligned to a 4-KiB page address
in real physical memory. If an MSI page table has
\({{2}^{k} &gt; {256}}\) entries, the table must be
naturally aligned to a \({2}^{k}\times {16-byte}\)
address boundary. If an MSI page table is not aligned as required, all
entries in the table appear to an IOMMU as UNSPECIFED, and any address an IOMMU
may compute and use for reading an individual MSI PTE from the table is
also UNSPECIFIED.</p>
</div>
<div class="paragraph">
<p>Every 16-byte MSI PTE is interpreted as two 64-bit doublewords. If an
IOMMU also references standard RISC-V page tables, defined by the RISC-V Privileged
Architecture, for regular address translation, then the byte order for
each of the two doublewords in memory, little-endian or big-endian,
should be the same as the endianness of the regular RISC-V page tables
configured for the same device context. Otherwise, the endianness of the
doublewords of an MSI PTE is implementation-defined.</p>
</div>
<div class="paragraph">
<p>Bit 0 of the first doubleword of an MSI PTE is field V (Valid). When
V = 0, the PTE is invalid, and all other bits of both doublewords are
ignored by an IOMMU, making them free for software to use.</p>
</div>
<div class="paragraph">
<p>If V = 1, bit 63 of the first doubleword is field C (Custom), designated
for custom use. If an MSI PTE has V = 1 and C = 1, interpretation of the
rest of the PTE is implementation-defined.</p>
</div>
<div class="paragraph">
<p>If V = 1 and the custom-use bit C = 0, then bits 2:1 of the first
doubleword contain field M (Mode). If M = 3, the MSI PTE specifies
<em>basic translate mode</em> for accesses to the page, and if M = 1, it
specifies <em>MRIF mode</em>. Values of 0 and 2 for M are reserved. The
interpretation of an MSI PTE for each of the two defined modes is
detailed further in the next two subsections.</p>
</div>
<div class="sect3">
<h4 id="msi-pte-basic-translate-mode"><a class="anchor" href="#msi-pte-basic-translate-mode"></a>8.5.1. MSI PTE, basic translate mode</h4>
<div class="paragraph">
<p>When an MSI PTE has fields V = 1, C = 0, and M = 3 (basic translate
mode), the PTE&#8217;s complete format is:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top" rowspan="4"><p class="tableblock"><code>First doubleword:</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bit 63</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>C, = 0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bits 53:10</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PPN</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bits 2:1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>M, = 3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bit 0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>V, = 1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Second doubleword:</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ignored</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>All other bits of the first doubleword are reserved and must be set to
zeros by software. The second doubleword is ignored by an IOMMU so is
free for software to use.</p>
</div>
<div class="paragraph">
<p>A memory access within the page covered by the MSI PTE is translated by
replacing the access&#8217;s original address bits 12 and above (the guest
physical page number) with field PPN (Physical Page Number) from the
PTE, while retaining the original address bits 11:0 (the page offset).
This translated address is either zero-extended or clipped at the upper
end as needed to make it the width of a real physical address for the
machine. The original memory access from the device is then passed
onward to the memory system with the new address.</p>
</div>
<div class="paragraph">
<p>An MSI PTE in basic translate mode allows a hypervisor to route an MSI
write intended for a virtual interrupt file to go instead to a guest
interrupt file of a real IMSIC in the machine.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>An IOMMU that also employs standard RISC-V page tables for regular address
translation can maximize the overlap between the handling of MSI PTEs
and regular RISC-V leaf PTEs as follows:</p>
</div>
<div class="paragraph">
<p>For RV64, the first doubleword of an MSI PTE in basic translate mode has
the same encoding as a regular RISC-V leaf PTE for Sv39, Sv48, Sv57, Sv39x4,
Sv48x4, or Sv57x4 page-based address translation, with PTE fields D, A,
G, U, and X all zeros and W = R = 1. Hence, the MSI PTE&#8217;s first
doubleword appears the same as a regular PTE that grants read and write
permission (R = W = 1) but not execute permissions (X = 0). This
same-encoded regular PTE would translate an MSI write the same as the
actual MSI PTE, except that what would be the PTE&#8217;s accessed (A), dirty
(D), and user (U) bits are all zeros. An IOMMU needs to treat only these
three bits differently for an MSI PTE versus a regular RV64 leaf PTE.</p>
</div>
<div class="paragraph">
<p>The address computation used to select a PTE from a regular RISC-V page table
must be modified to select an MSI PTE&#8217;s first doubleword from an MSI
page table. However, the extraction of an interrupt file number from a
guest physical address to obtain the index for accessing the MSI page
table already creates an unavoidable difference in PTE addressing.</p>
</div>
<div class="paragraph">
<p>For RV32, the lower 32-bit word of an MSI PTE&#8217;s first doubleword has the
same format as a leaf PTE for Sv32 or Sv32x4 page-based address
translation, except again for what would be PTE bits A, D, and U, which
must be treated differently.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="IOMMU-MSIPTE-MRIF"><a class="anchor" href="#IOMMU-MSIPTE-MRIF"></a>8.5.2. MSI PTE, MRIF mode</h4>
<div class="paragraph">
<p>If memory-resident interrupt files are supported and an MSI PTE has
fields V = 1, C = 0, and M = 1 (MRIF mode), the PTE&#8217;s complete format
is:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top" rowspan="4"><p class="tableblock"><code>First doubleword:</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bit 63</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>C, = 0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bits 53:7</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MRIF Address[55:9]</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bits 2:1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>M, = 1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bit 0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>V, = 1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Second doubleword:</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bit 60</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NID[10]</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bits 53:10</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NPPN</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bits 9:0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NID[9:0]</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>All other PTE bits are reserved and must be set to zeros by software.</p>
</div>
<div class="paragraph">
<p>The PTE&#8217;s MRIF Address field provides bits 55:9 of the physical address
of a memory-resident interrupt file in which to store incoming MSIs,
referred to as the <em>destination MRIF</em>. As every memory-resident
interrupt file is naturally aligned to a 512-byte address boundary, bits
8:0 of the destination MRIF&#8217;s address must be zero and are not specified
in the PTE.</p>
</div>
<div class="paragraph">
<p>Field NPPN (Notice Physical Page Number) and the two NID (Notice
Identifier) fields together specify a destination and value for a
<em>notice MSI</em> that is sent after each time the destination MRIF is
updated as a result of consulting this PTE to store an incoming MSI.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Typically, NPPN will be the page address of an IMSIC&#8217;s interrupt file in
the real machine, and NID will be the interrupt identity to make pending
in that interrupt file to indicate that the destination MRIF may have
changed. However, NPPN is not required to be a valid interrupt file
address, and an IOMMU must not attempt to restrict it to only such
addresses. Any page address must be accepted for NPPN.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Memory accesses by I/O devices to addresses within a page covered by an
MRIF-mode PTE are handled by the IOMMU instead of being passed through
to the memory system. If a memory access, read or write, is not for
32 bits of data, or if the access address is not aligned to a 4-byte
boundary (including accesses that straddle the page boundary), the
access should be aborted as unsupported. For a naturally aligned 32-bit
read, the IOMMU should preferably return zero as the read value but may
alternatively abort the access. A naturally aligned 32-bit write is
either interpreted as an MSI, resulting in an update of the destination
MRIF, or is discarded.</p>
</div>
<div class="paragraph">
<p>When the IMSIC interrupt files in the system implement memory-mapped
register <code>seteipnum_be</code> for receiving MSIs in big-endian byte order
(<a href="#IMSIC-memRegion">Section 3.5</a>), then an IOMMU
must be able to store MSIs in both little-endian and big-endian byte
orders to the destination MRIF. If the IMSIC interrupt files in the
system do not implement register <code>seteipnum_be</code>, an IOMMU should ordinarily store only
little-endian MSIs to the destination MRIF. The data of an incoming MSI
is assumed to be in little-endian byte order if bit 2 of the destination
address is zero, and in big-endian byte order if bit 2 of the
destination address is one.</p>
</div>
<div class="paragraph">
<p>If a naturally aligned 32-bit write is to guest physical
address \(A\) within a page covered by an MRIF-mode PTE, and
if the write data is \(D\) when interpreted in the byte order
indicated by bit 2 of \(A\), then the write is processed as
follows: If either \(A\)[11:3] or \(D\)[31:11] is not
zero, or if bit 2 of \(A\) is one and big-endian MSIs are not
supported, then the incoming write is accepted but discarded. Else, the
original incoming write is recognized as an MSI and is replaced by one
of the following memory accesses, setting the interrupt-pending bit that
corresponds to the interrupt identity \(D\) in the destination
MRIF to one:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>an atomic AMOOR operation, if atomic updates are supported; or</p>
</li>
<li>
<p>a non-atomic read-modify-write sequence, if atomic updates are not supported.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Once the MRIF update operation is visible to all agents in the system,
the 11-bit NID value is zero-extended to 32 bits, and this value is
written to the address NPPN&lt;&lt;12 (i.e., physical page number NPPN, page
offset zero) in little-endian byte order.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>While IOMMUs are expected typically to cache MSI PTEs that are
configured in basic translate mode (M = 3), they might not cache PTEs
configured in MRIF mode (M = 1). Two reasons together justify not
caching MSI PTEs in MRIF mode: First, the information and actions
required to store an MSI to an MRIF are far different than normal
address translation; and second, by their nature, MSIs to MRIFs should
occur less frequently. Hence, an IOMMU might perform MRIF-mode
processing solely as an extension of cache-miss page table walks,
leaving its address translation cache oblivious to MRIF-mode MSI PTEs.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</article>  </div>
</main>
<div class="modal micromodal-slide" id="modal-versions" aria-hidden="true">
    <div class="modal__overlay" tabindex="-1" data-micromodal-close>
        <div class="modal__container" role="dialog" aria-modal="true">
            <main class="modal__content" id="modal-versions-content">
              <button data-micromodal-close class="modal-versions-close">
                <svg width="28px" height="28px" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><defs><style>.cls-1h{fill:none;stroke:#000;stroke-linecap:round;stroke-linejoin:round;stroke-width:2px;}</style></defs><title/><g id="cross"><line class="cls-1h" x1="7" x2="25" y1="7" y2="25"/><line class="cls-1h" x1="7" x2="25" y1="25" y2="7"/></g></svg>
              </button>
                  <ul class="nav-versions">
                      <li class="component">
                        <div>
                          <a class="title" href="../../ffh/v1.0/index.html">ACPI Functional Fixed Hardware</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../ffh/v1.0/index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="index.html">Advanced Interrupt Architecture</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../etrace/v1.0/index.html">E-Trace Encapsulation Specification</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../etrace/v1.0/index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../psabi/v1.0/index.html">ELF psABI Specification</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../psabi/v1.0/index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../iommuArch/v1.0/index.html">IOMMU Architecture</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../iommuArch/v1.0/index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../isa/index.html">ISA Specifications</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../isa/index.html">
      default
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../reri/v1.0/index.html">RERI Architecture</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../reri/v1.0/index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../qos/v1.0/index.html">RISC-V Capacity and Bandwidth QoS Register Interface</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../qos/v1.0/index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../plic/v1.0.0/index.html">RISC-V Platform-Level Interrupt Controller</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../plic/v1.0.0/index.html">
      v1.0.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../semihost/v1.0/index.html">semihosting</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../semihost/v1.0/index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                  </ul>
            </main>
        </div>
    </div>
</div>

</div>
<footer class="hidden">
</footer><script src="../../_/js/vendor/import.js"></script>
<script src="../../_/js/site.js"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
<script async src="../../_/js/vendor/spring-tabs.js" data-sync-storage-key="docs:preferred-tab"></script>
  </body>
</html>
